<!DOCTYPE html>     
     

<html class="theme-next mist use-motion" lang="zh-CN">

<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">
<!-- <script>
  
  (function () {
    if ('') {
      if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
      }
    }
  })();
</script> -->













<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  



 <meta name="description" content="总结">
<meta name="keywords" content="js">
<meta property="og:type" content="article">
<meta property="og:title" content="工作宝典">
<meta property="og:url" content="www.0li.xin/2012/07/02/工作宝典/index.html">
<meta property="og:site_name" content="Candice">
<meta property="og:description" content="总结">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/2/28/1708a05c3331acfd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:updated_time" content="2022-04-07T15:03:04.764Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="工作宝典">
<meta name="twitter:description" content="总结">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2020/2/28/1708a05c3331acfd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">






  <link rel="canonical" href="www.0li.xin/2012/07/02/工作宝典/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>工作宝典 | Candice</title>
  








 <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

  <!-- <script src="//tencent.beecdn.cn/libs/vConsole/3.2.0/vconsole.min.js"></script>
  <script>
    var vConsole = new VConsole();

  </script> -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

     

  <div class="container sidebar-position-left page-post-detail"> 
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Candice</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">candiceBlog</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div> 
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.0li.xin/2012/07/02/工作宝典/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="candice">
      <meta itemprop="description" content="平凡的你的不平凡">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Candice">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">工作宝典
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2012-07-02 00:00:00" itemprop="dateCreated datePublished" datetime="2012-07-02T00:00:00Z">2012-07-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2022-04-07 15:03:04" itemprop="dateModified" datetime="2022-04-07T15:03:04Z">2022-04-07</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          
              <div class="post-description">总结</div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h1><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>在软件领域，中间件是在应用与应用之间充当连接服务的<br>1.express 2.koa</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="打开浏览器，输入-URL，到页面展示出来的过程及优化："><a href="#打开浏览器，输入-URL，到页面展示出来的过程及优化：" class="headerlink" title="打开浏览器，输入 URL，到页面展示出来的过程及优化："></a>打开浏览器，输入 URL，到页面展示出来的过程及优化：</h2><p>传送门: <a href="https://blog.csdn.net/weixin_33709590/article/details/88567259" target="_blank" rel="noopener">https://blog.csdn.net/weixin_33709590/article/details/88567259</a></p>
<ol>
<li><p>输入 URL<br>(浏览器查找当前 URL 是否存在缓存) 服务器对静态资源设置浏览器缓存信息，浏览器在有缓存的情况下直接从本地读取资源。<br>传送门：<a href="https://www.cnblogs.com/chenq.." target="_blank" rel="noopener">https://www.cnblogs.com/chenq..</a>. 关键词: 强制缓存 协商缓存 Cache-Control</p>
</li>
<li><p>DNS 解析<br>地址栏输入的域名并不是最后资源所在的真实位置，域名只是与 IP 地址的一个映射。网络服务器的 IP 地址那么多，我们不可能去记一串串的数字，因此域名就产生了，域名解析的过程实际是将域名还原为 IP 地址的过程。 无优化点</p>
</li>
<li><p>TCP 握手<br>DNS 解析后得到了服务器的 ip，接下来就是和服务器建立起连接，这通过 TCP 的三次握手完成。 无优化点</p>
</li>
<li><p>HTTP 请求<br>完整的 HTTP 请求包含请求起始行、请求头部、请求主体三部分。缓存信息是存储在请求头中，在阶段 1 上的连接有介绍<br>优化点: 减少请求次数</p>
<blockquote>
<p>合并外部请求的 js、css 文件<br>对 icon 文件进行处理。运用 CSS 精灵合并处理多个 icon 文件、运用图标字体、把小图标转为 base64 等</p>
</blockquote>
</li>
<li><p>HTTP 响应返回数据</p>
</li>
<li><p>浏览器解析并渲染页面<br>1&gt; js 会阻塞页面渲染的，那么解决方法有很多，可以把 js 放在 body 的底部，或者是异步加载 js(script 标签的 async 和 defer 属性)。 <a href="https://blog.csdn.net/qq_34986769/article/details/52155871" target="_blank" rel="noopener">https://blog.csdn.net/qq_34986769/article/details/52155871</a><br>2&gt; 以及 js 代码的优化 如 尽可能少声明变量,减少闭包的使用,少使用循环<br>3&gt; 分页加载 图片懒加载 使用精灵图等<br>4&gt; 如果是 vue 项目 页面渲染全靠 js 的 render，如果这个入口 js 过大，必然会导致页面白屏时间过长。可以对入口的 js 进行代码分割<br>webpack 在编译时，会静态地解析代码中的 require.ensure()，同时将模块添加到一个分开的 chunk 当中。这个新的 chunk 会被 webpack 通过 jsonp 来按需加载。</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写在主入口main.js中?</span></span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'button'</span>).onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">require</span>.ensure([], ()=&gt; &#123;</span><br><span class="line">      <span class="comment">// 引入异步加载的js</span></span><br><span class="line">      <span class="keyword">let</span> loadJS = <span class="built_in">require</span>(<span class="string">'./asyncJS'</span>)</span><br><span class="line">      alert(loadJS.flag)</span><br><span class="line">    &#125;, <span class="string">'asyncJS'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//webpack的配置文件?</span></span><br><span class="line">  output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, <span class="string">'./dist'</span>),</span><br><span class="line">  filename: <span class="string">'[name].bundle.js'</span>,</span><br><span class="line">  publicPath: <span class="string">'../dist/'</span>,</span><br><span class="line">  chunkFilename: <span class="string">'chunks/[name]-[hash].js'</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>5&gt; webpack 优化</p>
<ol>
<li><p>优化 loader 配置<br>1.1 缩小文件匹配范围(include/exclude) 缩小了 loader 加载搜索范围 高概率命中文件<br>1.2 缓存 loader 的执行结果(cacheDirectory) 减少 webpack 构建时 Babel 重新编译过程<br>loaders: [<br> {</p>
<pre><code>test: /\.jsx?$/,
exclude: /node_modules/,
loader: &quot;babel-loader?optional=runtime&amp;cacheDirectory&quot;
</code></pre><p> }<br>]</p>
</li>
<li><p>HappyPack 多进程打包<br>HappyPack 是让 webpack 对 loader 的执行过程，从单一进程形式扩展为多进程模式，也就是将任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。从而加速代码构建 与 DLL 动态链接库结合来使用更佳。</p>
</li>
<li><p>多进程压缩 ParallelUglifyPlugin 开启多个子进程同时压缩</p>
</li>
<li><p>提取公共代码 webpack3 使用 CommonsChunkPlugin webpack4 使用 splitChunks</p>
</li>
<li><p>生产环境关闭 sourceMap (开启得话打包出来的 js 文件中的代码可以映射到代码文件的具体位置,这种映射关系会帮助我们直接找到在源代码中的错误。)</p>
</li>
</ol>
<h1 id="uni-app"><a href="#uni-app" class="headerlink" title="uni.app"></a>uni.app</h1><p>常见问题<br>uni 打包的时候 会报错会出现不同的兼容问题<br>因为打包的设备不同 也要设定不同的方法</p>
<p>平台兼容性<br><a href="https://blog.csdn.net/Sunshine0508/article/details/104820498" target="_blank" rel="noopener">https://blog.csdn.net/Sunshine0508/article/details/104820498</a></p>
<p>ios app 真机测试到上架 App Store 详细教程<br><a href="http://blog.applicationloader.net/blog/zh/88.html" target="_blank" rel="noopener">http://blog.applicationloader.net/blog/zh/88.html</a></p>
<p>发布流程<br>uniapp 通过 appuploader 下载发布证书 描述文件 然后通过 HB 打包下载 IPA 文件，通过 appuploader 上传 ipa, 成功后去苹果官网构建版本发布版本</p>
<p>分包优化<br>多开一条 subPage</p>
<p>底层设计原理?</p>
<h1 id="html"><a href="#html" class="headerlink" title="html"></a>html</h1><h2 id="前端常用设计模式"><a href="#前端常用设计模式" class="headerlink" title="前端常用设计模式"></a>前端常用设计模式</h2><p>工厂模式/观察者模式/单例模式<br><a href="https://www.jianshu.com/p/4f3014fb8b8b" target="_blank" rel="noopener">https://www.jianshu.com/p/4f3014fb8b8b</a></p>
<h2 id="什么是设计模式，设计模式的作用。"><a href="#什么是设计模式，设计模式的作用。" class="headerlink" title="什么是设计模式，设计模式的作用。"></a>什么是设计模式，设计模式的作用。</h2><p>设计模式是一套被反复使用的、多数人知晓、经过分类编目的优秀代码设计经验的总结。<br>特定环境下特定问题的处理方法。</p>
<p>1）重用设计和代码 重用设计比重用代码更有意义，自动带来代码重用<br>2）提高扩展性 大量使用面向接口编程，预留扩展插槽，新的功能或特性很容易加<br>入到系统中来<br>3）提高灵活性 通过组合提高灵活性，可允许代码修改平稳发生，对一处修改不会<br>波及到其他模块<br>4） 提高开发效率 正确使用设计模式，可以节省大量的时间</p>
<h2 id="写出你用过的设计模式"><a href="#写出你用过的设计模式" class="headerlink" title="写出你用过的设计模式"></a>写出你用过的设计模式</h2><p><a href="https://blog.csdn.net/zhongqw_00/article/details/98469433" target="_blank" rel="noopener">https://blog.csdn.net/zhongqw_00/article/details/98469433</a></p>
<ol>
<li>工厂设计模式<br>思路说明：由一个工厂类根据传入的参数（一般是字符串参数），动态决定应该<br>创建哪一个产品子类（这些产品子类继承自同一个父类或接口）的实例，并以父类<br>形式返回</li>
</ol>
<p>优点：客户端不负责对象的创建，而是由专门的工厂类完成；客户端只负责对象的<br>调用，实现了创建和调用的分离，降低了客户端代码的难度；<br>缺点：如果增加和减少产品子类，需要修改简单工厂类，违背了开闭原则；如果产<br>品子类过多，会导致工厂类非常的庞大，违反了高内聚原则，不利于后期维护。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreatePerson</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  obj.name = name;</span><br><span class="line">  obj.age = age;</span><br><span class="line">  obj.sex = sex;</span><br><span class="line">  obj.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> CreatePerson(<span class="string">"longen"</span>, <span class="string">"28"</span>, <span class="string">"男"</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> CreatePerson(<span class="string">"tugenhua"</span>, <span class="string">"27"</span>, <span class="string">"女"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回都是object 无法识别对象的类型 不知道他们是哪个对象的实列</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> p1); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> p2); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>单列设计模式<br>保证一个类只有一个实例，并提供一个全局访问点。<br>实现方法：先判断实例是否存在，不存在先创建后返回，存在则直接返回。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> CreateDiv = <span class="function"><span class="keyword">function</span> (<span class="params">html</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.html = html;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> Singleton = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">html</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> CreateDiv(html);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Singleton(<span class="string">"seven1"</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Singleton(<span class="string">"seven2"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">console</span>.log(a === b); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>实际应用<br>模态框，以及弹框</p>
<h2 id="vue-双向绑定模式"><a href="#vue-双向绑定模式" class="headerlink" title="vue 双向绑定模式"></a>vue 双向绑定模式</h2><p>vue 数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的</p>
<p>Object.defineProperty( )是用来做什么的？<br>它可以来控制一个对象属性的一些特有操作，比如读写权、是否可以枚举，它对应的两个描述属性 get 和 set<br>get 就是在读取 name 属性这个值触发的函数，set 就是在设置 name 属性这个值触发的函数</p>
<p><a href="https://www.cnblogs.com/canfoo/p/6891868.html" target="_blank" rel="noopener">https://www.cnblogs.com/canfoo/p/6891868.html</a></p>
<h2 id="SVG-和-CANVAS-的区别"><a href="#SVG-和-CANVAS-的区别" class="headerlink" title="SVG 和 CANVAS 的区别"></a>SVG 和 CANVAS 的区别</h2><ol>
<li>svg 绘制出来的每一个图形元素都是独立的 DOM 节点，可方便后期绑定事件或修改，而 canvas 输出的是一整幅画布；</li>
<li>svg 输出的图形是矢量的，后期可以修改参数来自由放大缩小，无失真，canvas 输出标量画布，就像一张图片一样</li>
</ol>
<h2 id="哪些浏览器有自主内核"><a href="#哪些浏览器有自主内核" class="headerlink" title="哪些浏览器有自主内核?"></a>哪些浏览器有自主内核?</h2><p>IE 火狐 谷歌 欧朋 Safari</p>
<h2 id="前端页面有哪三层构成，分别是什么-作用是什么"><a href="#前端页面有哪三层构成，分别是什么-作用是什么" class="headerlink" title="前端页面有哪三层构成，分别是什么?作用是什么?"></a>前端页面有哪三层构成，分别是什么?作用是什么?</h2><p>结构 html、表现 css、和行为 js</p>
<h2 id="html5-css3-新特性"><a href="#html5-css3-新特性" class="headerlink" title="html5/css3 新特性"></a>html5/css3 新特性</h2><blockquote>
<p>参考 <a href="https://www.cnblogs.com/star91/p/5659134.html" target="_blank" rel="noopener">https://www.cnblogs.com/star91/p/5659134.html</a></p>
</blockquote>
<p>更多的语义化标签：例如用于定义头部(header)、尾部(footer)、导航区域(nav)、侧边栏(aside)<br>良好的多媒体支持：对于先前的以插件的方式播放音频、视频带来的麻烦，HTML5 有了解决方案，audio 标签和 video 标签能够方便的实现应变。<br>HTML5 拥有多个新的表单输入类型。这些新特性提供了更好的输入控制和验证。email、number、tel<br>提供了对 WebSockets 的支持 新增了两个存储方式(sessionStorage localeStorage)<br>HTML5 提供了对 Web Sockets 的支持</p>
<p>新增选择器： li:nth-child(odd)奇(even)偶行、a:hover,复选框等，代码标记更少。<br>新增阴影 box-shadow、圆角 border-radius、<br>渐变 background-image:-webkit-gradient(linear,0% 0%,100% 0%,from(#2A8BBE),to(#FE280E))、<br>动画 animation,过渡 Transition,2D 转换效果 Transforms,等视觉效果</p>
<h2 id="HTML5-提供了对-Web-Sockets-的支持。"><a href="#HTML5-提供了对-Web-Sockets-的支持。" class="headerlink" title="HTML5 提供了对 Web Sockets 的支持。"></a>HTML5 提供了对 Web Sockets 的支持。</h2><p>( WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。在 WebSocket API 中，<br>浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。<br>浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。<br>当你获取 Web Socket 连接后，你可以通过 send() 方法来向服务器发送数据，并通过 onmessage 事件来接收服务器返回的数据。以下 API 用于创建 WebSocket 对象。)</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h3><p>建立在 TCP 协议之上，服务器端的实现比较容易。<br>与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443 ，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。<br>数据格式比较轻量，性能开销小，通信高效。<br>可以发送文本，也可以发送二进制数据。<br>没有同源限制，客户端可以与任意服务器通信。<br>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。</p>
<h3 id="连接保持-心跳"><a href="#连接保持-心跳" class="headerlink" title="连接保持 + 心跳"></a>连接保持 + 心跳</h3><p>WebSocket 为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的 TCP 通道保持连接没有断开。<br>然而，对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。</p>
<p>WebSocket.onopen 用于指定连接成功后的回调函数<br>WebSocket.onmessage 用于指定当从服务器接受到信息时的回调函数<br>WebSocket.send(data) 对要传输的数据进行排队<br>WebSocket.onerror 用于指定连接失败后的回调函数</p>
<p>WebSocket.readyState(只读) 当前的链接状态</p>
<h2 id="状态-readyState属性返回实例对象的当前状态-有4种；"><a href="#状态-readyState属性返回实例对象的当前状态-有4种；" class="headerlink" title="状态 readyState属性返回实例对象的当前状态,有4种；"></a>状态 readyState属性返回实例对象的当前状态,有4种；</h2><p> CONNECTING：值为0，表示正在连接。<br> OPEN：值为1，表示连接成功，可以通信了。<br> CLOSING：值为2，表示连接正在关闭。<br> CLOSED：值为3，表示连接已经关闭，或者打开连接失败。</p>
<h2 id="新增了两个存储方式-老的-cookie-4kb-时间限制-明文存储"><a href="#新增了两个存储方式-老的-cookie-4kb-时间限制-明文存储" class="headerlink" title="新增了两个存储方式 [老的-cookie(4kb 时间限制 明文存储)]"></a>新增了两个存储方式 [老的-cookie(4kb 时间限制 明文存储)]</h2><p>sessionStorage(5mb 标签页关闭就会清除 不会跨标签页存储,只存在当前页)，<br>localeStorage(5mb 长期储存 会跨标签页存储)</p>
<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>content,padding,border,margin.</p>
<p>标准盒模型 的宽高只是内容（content）的宽高，</p>
<p>IE 盒模型 的宽高是内容(content)+填充(padding)+边框(border)的总宽高。</p>
<p>css 如何设置两种模型 使用 CSS3 的属性 box-sizing<br>即 box-sizing 属性可以指定盒子模型种类，content-box 指定盒子模型为 W3C（标准盒模型），border-box 为 IE 盒子模型（怪异盒模型）。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 标准模型 */</span></span><br><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">content-box</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*IE模型*/</span></span><br><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span>;</span><br></pre></td></tr></table></figure>
<h1 id="BCF-Block-Format-Content"><a href="#BCF-Block-Format-Content" class="headerlink" title="BCF( Block Format Content)"></a>BCF( Block Format Content)</h1><p>BFC 布局规则：<br>内部的 Box 会在垂直方向，一个接一个地放置。<br>Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠<br>每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。<br>BFC 的区域不会与 float box 重叠。<br>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。<br>计算 BFC 的高度时，浮动元素也参与计算<br>BFC 会阻止垂直外边距（margin-top、margin-bottom）折叠</p>
<p>我们可以利用 BFC 的第三条特性来“清浮动”:<br>float 为 left|right<br>overflow 为 hidden|auto|scroll<br>display 为 table-cell|table-caption|inline-block<br>position 为 absolute|fixed</p>
<h1 id="css-部分"><a href="#css-部分" class="headerlink" title="css 部分"></a>css 部分</h1><h2 id="最小字体"><a href="#最小字体" class="headerlink" title="最小字体"></a>最小字体</h2><p>PC 端的浏览器进行最小 12px 的限制，手机端默认没有开该限制，还是可以直接通过 CSS 设置最小字体的<br>PC 使用 transform: scale(); 属性缩放字体所在元素即可实现小字体显示</p>
<h2 id="使元素水平垂直居中方案"><a href="#使元素水平垂直居中方案" class="headerlink" title="使元素水平垂直居中方案"></a>使元素水平垂直居中方案</h2><ol>
<li><p>flex<br>display: flex;<br>justify-content: center;<br>align-items: center;</p>
</li>
<li><p>fixed<br>position:fixed;<br>left:0;<br>top:0;<br>reight:0;<br>bottom:0;<br>margin:auto;</p>
</li>
<li><p>absolute<br>position:absolute;<br>left:0;<br>top:0;<br>right:0;<br>bottom:0;<br>margin:auto;</p>
</li>
<li><p>display: table</p>
</li>
</ol>
<h2 id="flex-常用参数"><a href="#flex-常用参数" class="headerlink" title="flex 常用参数"></a>flex 常用参数</h2><ol>
<li><p>flex-direction: row | row-reverse | column | column-reverse; 排列方向</p>
</li>
<li><p>flex-wrap: nowrap | wrap | wrap-reverse; 是否允许换行</p>
</li>
<li><p>定义项目在主轴的对齐方式 (主轴取决于 flex-direction 默认横轴)<br>justify-content: flex-start | flex-end | center |<br>space-between(两端对齐项目之间的间隔都相等) | space-around(每个项目两侧的间隔相等)</p>
</li>
<li><p>定义项目在交叉轴上如何对齐。<br>align-items: flex-start | flex-end | center(中点对齐) |<br>baseline(项目的第一行文字的基线对齐)<br>stretch(默认值如果项目未设置高度或 auto，将占满整个容器的高度);</p>
</li>
</ol>
<h2 id="移动端-1px-解决方案"><a href="#移动端-1px-解决方案" class="headerlink" title="移动端 1px 解决方案"></a>移动端 1px 解决方案</h2><p>归根结底有两种方案，一种是利用 css 中的 transfrom：scaleY(0.5)，另一种是设置 媒体查询根据不同 DPR 缩放</p>
<p>参考文章 <a href="https://zhuanlan.zhihu.com/p/100752129" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/100752129</a></p>
<ol>
<li>解决方法 1<br>利用 css 的 伪元素::after + transfrom 的 scale 缩小一半<br>为什么用伪元素？ 因为伪元素::after 或::before 是独立于当前元素，可以单独对其缩放而不影响元素本身的缩放</li>
</ol>
<blockquote>
<p>伪元素大多数浏览器默认单引号也可以使用，和伪类一样形式，而且单引号兼容性（ie）更好些</p>
</blockquote>
<ol start="2">
<li><p>解决方案二（升级方案一）<br>使用 less 对公共代码（方案一）封装，同时增加媒体查询分别对不同 DPR 的设备，进行不同的缩放</p>
</li>
<li><p>有缺憾的解决方式<br>使用图片：兼容性最好，灵活行最差，不能改变颜色、长度<br>使用 viewport 和 rem，js 动态改变 viewport 中 scale 缩放，缺点在于不适用于已有的项目，例如：使用 vh 和 vw 布局的<br><meta name="viewport" id="WebViewport" content="initial-scale=1,    maximum-scale=1, minimum-scale=1, user-scalable=no"><br>使用 css 渐变 linear-gradient 或者 box-shadow</p>
</li>
</ol>
<h2 id="less-和-sass-或者-scss-有什么区别吗？"><a href="#less-和-sass-或者-scss-有什么区别吗？" class="headerlink" title="less 和 sass 或者 scss 有什么区别吗？"></a>less 和 sass 或者 scss 有什么区别吗？</h2><ol>
<li><p>声明和使用变量<br>LESS 采用 @ 符号，SCSS 采用 \$ 符号。</p>
</li>
<li><p>变量插值（Variable Interpolation）<br>LESS 采用 @{xxxx} 的形式，SCSS 采用 \${xxxx} 的形式。</p>
</li>
<li><p>Mixins 的定义、使用及参数<br>定义一个 Mixin：LESS 使用 dot 符号（也就是句点）来定义一个 Mixin， 使用 Mixin 仍是使用句点,如果 Mixin 没有参数的话可以省略后面的圆括号<br>SCSS 使用 @mixin 指令来定义一个 Mixin。 SCSS 使用 @include 指令来引入一个 Mixin。</p>
</li>
<li><p>Sass 支持条件语句，可以使用 if{}else{},for{}循环等等。而 Less 不支持</p>
</li>
</ol>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if-else if-else示例</span></span><br><span class="line">@<span class="keyword">mixin</span> txt(<span class="variable">$weight</span>) &#123;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$weight</span> == bold &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  &#125; @<span class="keyword">else</span> if <span class="variable">$weight</span> == light &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">100</span>;</span><br><span class="line">  &#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: normal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.txt1</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> txt(bold);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for</span></span><br><span class="line">@<span class="keyword">for</span> <span class="variable">$i</span> from 1 to 10 &#123;</span><br><span class="line">  <span class="selector-class">.border-</span>#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">border</span>: #&#123;<span class="variable">$i</span>&#125;px solid blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>引用外部 CSS 文件<br>scss@import 引用的外部文件如果不想编译时多生成同名的.css 文件，命名必须以<em>开头, 文件名如果以下划线</em>开头的话，Sass 会认为该文件是一个引用文件，不会将其编译为同名 css 文件. 如: @import “_test1.scss”;<br>Less 引用外部文件和 css 中的@import 没什么差异。</li>
</ol>
<h2 id="css-选择器"><a href="#css-选择器" class="headerlink" title="css 选择器"></a>css 选择器</h2><h3 id="高级选择器"><a href="#高级选择器" class="headerlink" title="高级选择器"></a>高级选择器</h3><p>$(“A+B”) 就是查找A元素后面的第一个兄弟B节点<br>$(“A~B”) 查找 A 元素后面的所有兄弟 B 节点<br>A&gt;B 表示选择 A 元素的所有第一级子 B 元素。<br>属性 href 的值以”http:”开头的元素 a[href^=”http:”]<br>属性 href 的值以”http:”结尾的元素 a[href$=”http:”]<br>属性 href 的值包含”http:”字符串的元素 a[href*=”http:”]</p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>不同级别优先级排序<br>!important &gt; 行内样式 &gt; ID 选择器 &gt; 类选择器 &gt; 元素 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</p>
<p>同一级别优先级排序</p>
<ol>
<li>同级别中后写的会覆盖先写的样式</li>
<li>同级别 css 引入方式不同，优先级不同<br>总结排序：内联(行内)样式 &gt; 内部样式表 &gt; 外部样式表 &gt; 导入样式(@import)。</li>
</ol>
<h1 id="JS-部分"><a href="#JS-部分" class="headerlink" title="JS 部分"></a>JS 部分</h1><h2 id="拷贝对象"><a href="#拷贝对象" class="headerlink" title="拷贝对象"></a>拷贝对象</h2><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>JSON.parse() string-&gt;json<br>JSON.stringify() json-&gt;string<br>深拷贝 a 对象赋值给 b 对象 修改 b 对象会影响到 a 应为他们在内存中地址是一样的 我们在赋值的时候用深拷贝就不会了<br>JSON.parse(JSON.stringify(XXXX))</p>
<p>我们在使用 JSON.parse(JSON.stringify(xxx))时应该注意一下几点：<br>由于 json 不支持函数、undefined、NaN，!!!<br>所以使用 JSON 方法转换时，对象的函数、NaN 属性会被忽略，undefined 会被转换为 null。<br>1、如果 obj 里面存在时间对象，JSON.parse(JSON.stringify(obj))之后，时间对象变成了字符串。<br>2、如果 obj 里有 RegExp、Error 对象，则序列化的结果将只得到空对象。<br>3、如果 obj 里有函数，undefined，则序列化的结果会把函数， undefined 丢失。<br>4、如果 obj 里有 NaN、Infinity 和-Infinity，则序列化的结果会变成 null。<br>5、JSON.stringify()只能序列化对象的可枚举的自有属性。如果 obj 中的对象是有构造函数生成的， 则使用 JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的 constructor。<br>6、如果对象中存在循环引用的情况也无法正确实现深拷贝。</p>
<blockquote>
<p>深拷贝处理空值会怎么样? 会被转换为 null</p>
</blockquote>
<h3 id="浅拷贝-Object-assign-ES6-的展开运算符…"><a href="#浅拷贝-Object-assign-ES6-的展开运算符…" class="headerlink" title="浅拷贝 Object.assign() ES6 的展开运算符…"></a>浅拷贝 Object.assign() ES6 的展开运算符…</h3><h2 id="js-常用操作"><a href="#js-常用操作" class="headerlink" title="js 常用操作"></a>js 常用操作</h2><p>push() 写入数组<br>splice() 方法用于插入、删除或替换数组的元素。 Array.splice(start,deleteCount,itemN)<br>从末尾删除 只保留最前面一位 [1,2,3,4].splice(1) 只留下[1]</p>
<p>split(‘,’) 分割字符串并返回数组 string.split(‘,’)<br>join() 方法用于把数组中的所有元素放入一个字符串。 array.join()</p>
<p>slice(开始位置,结束位置) 结束位置是可选的。<br>开始位置必选，可以是正数，也可是负数 负数时，就是倒着来的。</p>
<p>parseInt() 一般用它返回整数 number<br>toFixed() 四舍五入返回指定小数位的数字</p>
<p>String()可以将 null 和 undefined 转换为字符串，但是没法转进制字符串<br>.toString()可以将所有的的数据都转换为字符串，但是要排除 null 和 undefined 括号中的可以写一个数字，代表进制，对应进制字符串 toString(8)<br>replace() 方法用于在字符串中用一些字符替换另一些字符,或替换一个与正则表达式匹配的子串。</p>
<h2 id="原生-js-查找-操作元素方法"><a href="#原生-js-查找-操作元素方法" class="headerlink" title="原生 js 查找/操作元素方法"></a>原生 js 查找/操作元素方法</h2><p>document.createElement(“div”); //创建一个元素节点 重要!<br>node.appendChild(newNode);// 在指定元素后面新增子节点<br>document.createTextNode(“hello world!”); //创建一个文本节点<br>newNode.cloneNode(true);//克隆一个节点，参数 true 表示会克隆当前节点以及他的所有子节点，flase 表示只克隆当前节点，默认为 false<br>parentNode.removeChild(item);//删除指定的子节点，并返回 deleteNode 只是在 dom 树中删除了，但在内存中还可以访问</p>
<p>document.getElementById(“list”);//返回第一个带有指定 id 的元素<br>document.getElementsByClassName(“wrapper”); //返回所有带有指定 class 的元素的集合(返回数组形式)</p>
<p>document.getElementsByName() 获取所有指定 name 的元素集合<br>document.getElementsByTagName(“li”);//返回所有指定标签的元素集合 (数组形式)</p>
<p>document.querySelector(“.wrapper”);//返回第一个带有指定 id 或 class 的元素<br>document.querySelectorAll(“.wrapper”);//返回所有带有指定 id 或 class 的元素</p>
<p>获取元素属性 .setAttribute(“属性”)<br>设置属性 .setAttribute(“属性”,”值”)<br>删除属性 .removeAttribute</p>
<p>unbind() 方法移除被选元素的事件处理程序 \$(window).unbind(‘mouseup’)</p>
<h2 id="js-数据类型"><a href="#js-数据类型" class="headerlink" title="js 数据类型"></a>js 数据类型</h2><ol>
<li><p>js 的数据类型分为两种：原始类型（即基本数据类型）和对象类型（即引用数据类型）；</p>
</li>
<li><p>js 常用的基本数据类型(栈)包括 undefined、null、number、boolean、string；以及 es6 新增的 Symbol</p>
</li>
<li><p>js 的引用数据类型(堆)也就是对象类型 Object，如：（对象、数组、函数）；</p>
</li>
</ol>
<h2 id="基本数据类型特点"><a href="#基本数据类型特点" class="headerlink" title="基本数据类型特点"></a>基本数据类型特点</h2><ol>
<li><p>基本数据类型是按值访问的，就是说我们可以操作保存在变量中的实际的值；</p>
</li>
<li><p>基本数据类型的值是不可变的，任何方法都无法改变一个基本数据类型的值;</p>
</li>
<li><p>基本数据类型不可以添加属性和方法;</p>
</li>
<li><p>基本数据类型的赋值是简单的赋值（如果从一个变量向另一个变量赋值基本类型的值，会在变量对象上创建一个新值，然后把该值赋值到位新变量分配的位置上）;</p>
</li>
<li><p>基本数据类型的比较是值的比较;</p>
</li>
<li><p>基本类型的值在内存中占据固定大小的空间，被保存在栈内存中;</p>
</li>
</ol>
<p>(看不懂就点击看详解)[<a href="https://blog.csdn.net/lareinalove/article/details/79895760]" target="_blank" rel="noopener">https://blog.csdn.net/lareinalove/article/details/79895760]</a></p>
<h2 id="typeof-共返回-6-种数据格式："><a href="#typeof-共返回-6-种数据格式：" class="headerlink" title="typeof 共返回 6 种数据格式："></a>typeof 共返回 6 种数据格式：</h2><p>“number”、”string”、”boolean”、”object”、”function”、”undefined”</p>
<p>(如果检测 null,对象和数组都会返回’object’)</p>
<h2 id="null-和-undefined-的区别"><a href="#null-和-undefined-的区别" class="headerlink" title="null 和 undefined 的区别"></a>null 和 undefined 的区别</h2><p>null 表示没有对象，即该处不应该有值 默认转成 0<br>undefined 表示缺少值，即此处应该有值，但没有定义 默认转成 NaN</p>
<h2 id="如何判断是否为数组"><a href="#如何判断是否为数组" class="headerlink" title="如何判断是否为数组"></a>如何判断是否为数组</h2><ol>
<li>instanceof</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>instanceof 是怎么实现判断数组的<br><a href="https://zhidao.baidu.com/question/757412065588762204.html?fr=iks&amp;word=js%D6%D0%B5%C4instanceof+%C5%D0%B6%CF%CA%FD%D7%E9%B5%C4%D4%AD%C0%ED%CA%C7&amp;ie=gbk" target="_blank" rel="noopener">https://zhidao.baidu.com/question/757412065588762204.html?fr=iks&amp;word=js%D6%D0%B5%C4instanceof+%C5%D0%B6%CF%CA%FD%D7%E9%B5%C4%D4%AD%C0%ED%CA%C7&amp;ie=gbk</a></p>
</blockquote>
<ol start="2">
<li>Array 对象的 isArray 方法</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>Object.prototype.toString</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">"[object Array]"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用的数组方法"><a href="#常用的数组方法" class="headerlink" title="常用的数组方法"></a>常用的数组方法</h2><p>数组循环方法<br>reduce() 数组扁平化、数组去重、统计数组 原数组不变<br>map() 原数组被“映射”到新数组 原数组不变<br>filter() 通过测试的元素集合成新数组，都没通过则返回空数组 原数组不变<br>some() 用于检测数组中的元素是否满足指定条件<br>every() 方法用于检测数组所有元素是否都符合指定条件（通过函数提供）<br>includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false。</p>
<p>indexOf() 返回符合条件的第一个值的索引 无则返回-1 原数组不变<br>find() 返回符合条件的第一个数组的值 无则返回 undefined 原数组不变</p>
<p>splice() 通过删除现有元素/或添加新元素来修改数组,并以数组返回原数组中被修改的内容<br>push pop(删最后一个) shift(删第一个) reverse(倒叙) sort(排序)这些都会改变原数组</p>
<p>注解：arr.sort((a,b)=&gt;a-b) 操作 a-b 数字小到大排列反之大到小排列</p>
<p>数组七个原生方法<br>“push”, //添加到末尾<br>“pop”, //删最后一个<br>“shift”, //删第一个<br>“unshift”, // 添加到开头。 arr.unshift(1,2))<br>“splice”, //通过删除现有元素/或添加新元素来修改数组 Array.splice(start,deleteCount 个数,itemN 要添的内容)<br>“sort”, //排序<br>“reverse”, //倒序</p>
<h2 id="for-in-和-for-of的区别详解以及为for-in的输出顺序"><a href="#for-in-和-for-of的区别详解以及为for-in的输出顺序" class="headerlink" title="for in 和 for of的区别详解以及为for in的输出顺序"></a>for in 和 for of的区别详解以及为for in的输出顺序</h2><p>使用foreach遍历数组的话，使用break不能中断循环，使用return也不能返回到外层函数。<br>重点!!! for in遍历的是数组的索引（即键名），而for of遍历的是数组元素值</p>
<p>一.  for in遍历数组的毛病<br>1.index索引为字符串型数字，不能直接进行几何运算<br>2.遍历顺序有可能不是按照实际数组的内部顺序<br>3.使用for in会遍历数组所有的可枚举属性，包括原型。例如上栗的原型方法method和name属性<br>所以for in更适合遍历对象，不要使用for in遍历数组。</p>
<p>for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引name<br>for of 不同与 forEach, 它可以与 break、continue和return 配合使用,也就是说 for of 循环可以随时退出循环。</p>
<h2 id="ES6-Proxy属性"><a href="#ES6-Proxy属性" class="headerlink" title="ES6 Proxy属性"></a>ES6 Proxy属性</h2><p><a href="https://www.cnblogs.com/gaozonghui/p/13419556.html" target="_blank" rel="noopener">https://www.cnblogs.com/gaozonghui/p/13419556.html</a><br><a href="https://www.jianshu.com/p/ee181bd7e711" target="_blank" rel="noopener">https://www.jianshu.com/p/ee181bd7e711</a></p>
<p>Proxy 用于修改某些操作的默认行为(如属性查找，赋值，枚举，函数调用等)，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。<br>语法<br>let proxy = new Proxy(target, handler);<br>1、set(target, key, value, receiver)   拦截对象属性的设置<br>2、get(target, key, receiver)  拦截对象属性的读取<br> get方法拦截了读取操作，set方法拦截了改写操作<br>3、has(target, Key)  判断对象是否具有某个属性。<br>4、apply(target, thisArgs, args)  拦截函数的调用、call和apply操作<br>5、construct(target, args，newTarget)  拦截new命令</p>
<p>Vue3解决问题之Proxy在Vue中的作用👇<br><a href="https://www.cnblogs.com/xiaonian8/p/13764938.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaonian8/p/13764938.html</a></p>
<h2 id="返回各种数字"><a href="#返回各种数字" class="headerlink" title="返回各种数字"></a>返回各种数字</h2><ul>
<li><p>数学对象 Math。 包含了 js 中一切和数学有关的功能；如：随机数函数 Math.random() 可以产生任意的浮点数</p>
</li>
<li><p>Math.round() 四舍五入得出一个最接近的整数</p>
</li>
<li><p>toFixed() 把 Number 四舍五入为指定小数位数的数字。 num.toFixed(‘2’) 但是这个方法并不能够精确保留</p>
<p>四舍五入精确保留两位小数 公式: Math.round(9.225 <em> Math.pow(10,2) )/Math.pow(10,2); 或者 Math.round(2.128</em>100)/100<br>把一个数字舍入为最接近的整数。比如 0.5 将舍入为 1，而 -0.5 将舍入为 0 公式: Math.round(x)</p>
</li>
<li><p>isNaN() 判断传入值是否为数字 返回布尔值</p>
</li>
<li><p>parseInt(参数) 将字符型的数字转化为数字，去掉小数点只保留整数。</p>
</li>
</ul>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象停留在堆内存中，产生了内存泄漏。</p>
<ol>
<li>意外的全局变量（在 js 中，一个未声明变量的使用，会在全局对象中创建一个新的变量；在浏览器环境下，全局对象就是 window）</li>
<li>计时器和回调函数 timers</li>
<li>js 闭包</li>
<li>console</li>
</ol>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>JavaScript 引擎中有一个后台进程称为垃圾回收器，它监视所有对象，并删除那些不可访问的对象。<br>无法访问的数据块</p>
<h2 id="es6-新增"><a href="#es6-新增" class="headerlink" title="es6 新增"></a>es6 新增</h2><p>箭头函数 let const 模板字符串 展开运算符 解构赋值<br>新的数组结构 set(可以存放任何数据类型的唯一值) 和 map(传统对象 key 值必须为字符串 这个可以声明任何类型的 key)<br>Promise(es6) async 和 await(es7) 用法更加简单且 async/await 的优势在于处理 then 链式操作<br>新的数组方法 Array.of() Array.from find() includes()</p>
<h2 id="var-与-let、const-的区别"><a href="#var-与-let、const-的区别" class="headerlink" title="var 与 let、const 的区别"></a>var 与 let、const 的区别</h2><blockquote>
<p>什么是变量提升？<br>JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。<br>JavaScript 中，变量可以先使用再声明。</p>
</blockquote>
<ol>
<li>var 声明变量存在变量提升，let 和 const 不存在变量提升</li>
<li>let、const 都是块级局部变量</li>
<li>同一作用域下只有 var 可以声明同名变量</li>
</ol>
<h3 id="const-的特性和-let-完全一样，const-不同的只是"><a href="#const-的特性和-let-完全一样，const-不同的只是" class="headerlink" title="const 的特性和 let 完全一样，const 不同的只是"></a>const 的特性和 let 完全一样，const 不同的只是</h3><p>1）声明时候必须赋值<br>2）只能进行一次赋值，即声明后不能再修改<br>3）如果声明的是复合类型数据，可以修改其属性</p>
<h2 id="解构赋值及其原理"><a href="#解构赋值及其原理" class="headerlink" title="解构赋值及其原理"></a>解构赋值及其原理</h2><p><a href="https://segmentfault.com/a/1190000018628030" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018628030</a></p>
<p>// 基础类型解构<br>let [a, b, c] = [1, 2, 3]<br>console.log(a, b, c) // 1, 2, 3</p>
<p>使用场景 浅拷贝 交换变量等</p>
<p>解构是 ES6 提供的语法糖，其实内在是针对可迭代对象的 Iterator 接口，通过遍历器按顺序获取对应的值进行赋值。这里需要提前懂得 ES6 的两个概念：Iterator 可迭代对象</p>
<h2 id="对-promise-的理解和-解决回调地狱"><a href="#对-promise-的理解和-解决回调地狱" class="headerlink" title="对 promise 的理解和 解决回调地狱"></a>对 promise 的理解和 解决回调地狱</h2><p>没有 Promise 之前,解决异步都是依赖回调,操作多时就会回调中嵌着回调,这就是回调地狱.<br>Promise 让代码变得更具有可读性和可维护性，将请求和数据处理明确的区分开</p>
<blockquote>
<p>总结: 状态三个 方法四个.then .catch、.all、.race</p>
</blockquote>
<p>三个状态：Pending(进行中)、Fulfilled(已成功)、Rejected(已失败)<br>Promise 存在 resolve 和 reject 两个回调函数作为自身参数：new Promise((resolve, reject){});</p>
<p>四个方法:<br>.then 方法，解决回调地狱问题，可以传递两个参数，一个是成功的回调一个是失败的回调。</p>
<p>.catch 异常处理</p>
<p>.all(传入一个数组,每一项分别是一个 Promise 实例), 当数据里的 Promise 状态都变为 resolve 时,.all 状态才变为 resolve<br>(里面的请求是同时执行的)</p>
<p>.race(传入一个数组,每一项分别是 Promise 实例), 与.all 相反, 只要有一个 Promise 状态变为 resolve, .all 就变为 resolve<br>(里面的请求是同时执行的)</p>
<h2 id="Promise-静态方法-all-race-的差别"><a href="#Promise-静态方法-all-race-的差别" class="headerlink" title="Promise 静态方法 all/race 的差别"></a>Promise 静态方法 all/race 的差别</h2><p>Promise.all: 在所有的 Promise 异步操作完成之后，执行某个任务就可以使用 Promise.all<br>Promise.race: 在第一个 Promise 异步操作完成之后，就执行某个任务</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"执行完成"</span>); <span class="comment">//1秒之后输出： 执行完成</span></span><br><span class="line">    resolve(<span class="string">"我的数据-成功"</span>);</span><br><span class="line">    <span class="comment">// reject('我的数据-失败')</span></span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"我先执行"</span>); <span class="comment">//先输出：我先执行</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">//100</span></span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p, p, p]).then(<span class="function">(<span class="params">values</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Date</span>.now(), values);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="手写一个-promise"><a href="#手写一个-promise" class="headerlink" title="手写一个 promise"></a>手写一个 promise</h2><p><a href="https://blog.csdn.net/chenjuan1993/article/details/81632465" target="_blank" rel="noopener">https://blog.csdn.net/chenjuan1993/article/details/81632465</a></p>
<h2 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h2><p>async/await 则直接将异步操作变成了同步的写法</p>
<p>async 表示函数里有异步操作，<br>await 表示紧跟在后面的表达式需要等待结果。 (await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。)</p>
<p>await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try…catch 代码块中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> somethingThatReturnsAPromise();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> somethingThatReturnsAPromise().catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="export-与-export-default-区别"><a href="#export-与-export-default-区别" class="headerlink" title="export 与 export default 区别"></a>export 与 export default 区别</h2><p>都可以导出常量 函数 文件和模块<br>在一个文件或者模块中 export default 只能有一个 而 export,import 可以有多个<br>通过 export 方式导出 在导入的时候要加{} export default 则不用<br>使用 export default 为模块指定默认输出 所以加载的时候不需要知道加载模块的变量名 而 export default 需要知道</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归函数就是在函数体内调用本函数；</p>
<p>递归函数的使用要注意函数终止条件避免死循环</p>
<h2 id="闭包是什么，有什么特性，对页面有什么影响"><a href="#闭包是什么，有什么特性，对页面有什么影响" class="headerlink" title="闭包是什么，有什么特性，对页面有什么影响?"></a>闭包是什么，有什么特性，对页面有什么影响?</h2><p>闭包是指可以访问另一个函数作用域中的变量的函数。<br>创建闭包的常见方式就是在一个函数内部创建另一个函数。</p>
<p>为什么要用：1.可以在全局作用域中读取内部函数的的变量，2.可以重复使用变量，并且不会造成变量污染 3.可以让闭包中引用的变量始终保存在内存中。</p>
<p>注意：闭包的变量会保存在内存中比其他函数占更多内存 滥用闭包会导致性能问题以及内存泄漏。因此可以手动解除对匿名函数的引用(赋值 null)，以便释放内存。<br>生命周期-&gt; 回收机制</p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>原型: 每一个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，实例都包含一个指向原型对象的内部指针。</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>原型链: js 中所有对象都是由原型对象继承而来，而原型对象自身也是一个对象，他也有自己的原型对象。这样层层递进，就是原型链的基本概念。-原型链上的所有元素都是对象</p>
<p>原型链的终点是 obj 函数的 prototype 属性，而 objec.prototype 指向的原型对象同样拥有原型 他的原型就是 null</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>就是一个独立的地盘，让变量不会外泄、暴露出去. 最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。<br>全局作用域和函数作用域 块级作用域</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>当前作用域没有定义的变量，这成为自由变量 。<br>一层一层向上寻找自由变量的值，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 作用域链</p>
<h2 id="js-是怎么实现继承的"><a href="#js-是怎么实现继承的" class="headerlink" title="js 是怎么实现继承的"></a>js 是怎么实现继承的</h2><p><a href="https://segmentfault.com/a/1190000020184298?utm_source=tag-newest" target="_blank" rel="noopener">链接 👉</a><br><a href="https://segmentfault.com/a/1190000037460216" target="_blank" rel="noopener">链接 👉</a></p>
<ol>
<li><p>原型链继承(prototype) —不能向父级传参，原型对象属性会被所有实例共享</p>
</li>
<li><p>借用构造函数 通过使用 apply(最多接受两个参)和 call(可以接受多个参)方法在新创建的对象上执行构造函数<br>–可以向父级传参 不会被共享 缺点是无法实现构造函数复用，只能继承父类构造函数的属性</p>
</li>
<li><p>组合继承<br>–每个实例引入的构造函数都是私有的 缺点是调用了两次父类构造函数耗内存<br>将原型链和借用构造函数的技术组合到一块，从而发挥二组之所长的一种继承模式。使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承</p>
</li>
<li><p>原型式继承 –所有实例都会继承原型上的属性。 无法实现复用（新实例属性都是后面添加的）</p>
</li>
<li><p>寄生式继承 –没用到原型，无法复用</p>
</li>
<li><p>寄生组合式继承（常用） –重点：修复了组合继承的问题</p>
</li>
<li><p>es6 新增 extends 继承 class 可以通过 extends 关键字实现继承</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  test() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassExtends</span> <span class="keyword">extends</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">super</span>(value); <span class="comment">//子类构造函数中必须调用 super</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">var</span> demo = <span class="keyword">new</span> ClassExtends(<span class="string">"我是测试语句"</span>);</span><br><span class="line">demo.test(); <span class="comment">//我是测试语句</span></span><br><span class="line"><span class="built_in">console</span>.log(demo.__proto__);</span><br></pre></td></tr></table></figure>
<h2 id="事件绑定和普通事件有什么区别"><a href="#事件绑定和普通事件有什么区别" class="headerlink" title="事件绑定和普通事件有什么区别?"></a>事件绑定和普通事件有什么区别?</h2><p>事件绑定 事件叠加<br>事件只能回收 不精准<br>能精准的解除哪个函数<br>如:document.addEventListener(“mousemove”, myFunction);<br>document.removeEventListener(“mousemove”, myFunction);</p>
<h2 id="对事件循环的理解"><a href="#对事件循环的理解" class="headerlink" title="对事件循环的理解"></a>对事件循环的理解</h2><p>JavaScript 的事件分两种，宏任务(macro-task)和微任务(micro-task)</p>
<p>宏任务：包括整体代码 script，setTimeout，setInterval<br>微任务：Promise.then(非 new Promise)，process.nextTick(node 中)</p>
<p>事件的执行顺序，是先执行宏任务，然后执行微任务，这个是基础，任务可以有同步任务和异步任务，<br>同步任务进入主线程，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。这个过程的不断重复就是事件循环</p>
<p><a href="https://blog.csdn.net/yun_hou/article/details/88697954" target="_blank" rel="noopener">https://blog.csdn.net/yun_hou/article/details/88697954</a></p>
<h2 id="事件委托-事件代理-是什么"><a href="#事件委托-事件代理-是什么" class="headerlink" title="事件委托(事件代理)是什么"></a>事件委托(事件代理)是什么</h2><p>利用事件冒泡的原理，让父元素代替执行自己所触发的事件！<br>适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。<br>不适合的：mouseover 和 mouseout 虽然也有事件冒泡，因为需要经常计算它们的位置，处理起来不太容易。<br>不能的：focus，blur 之类的，本身就没用冒泡的特性，自然就不能用事件委托了。</p>
<h2 id="如何阻止事件冒泡？"><a href="#如何阻止事件冒泡？" class="headerlink" title="如何阻止事件冒泡？"></a>如何阻止事件冒泡？</h2><p>stopPropagation();<br>cancelBubble = true;</p>
<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><ol>
<li><p>for 加 if</p>
</li>
<li><p>new Map()通过 filter 过滤</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">a</span>) =&gt;</span> !res.has(a) &amp;&amp; res.set(a, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>new Set()数据类型 可以存储任何数据类型,并且是唯一的(不重复的值)<br>再通过 Array.from()转化成数组类型</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</span><br><span class="line">&#125;</span><br><span class="line">dedupe([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<h2 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h2><ol>
<li><p>外形不同：箭头函数使用箭头定义，普通函数中没有</p>
</li>
<li><p>箭头函数都是匿名函数<br>普通函数可以有匿名函数，也可以有具体名函数，但是箭头函数都是匿名函数。</p>
</li>
<li><p>箭头函数不能用于构造函数，不能使用 new<br>普通函数可以用于构造函数，以此创建对象实例。</p>
</li>
<li><p>箭头函数中 this 的指向不同<br>在普通函数中，this 总是指向调用它的对象，如果用作构造函数，this 指向创建的对象实例。 1.箭头函数本身不创建 this<br>也可以说箭头函数本身没有 this，但是它在声明时可以捕获其所在上下文的 this 供自己使用。<br>注意：this 一旦被捕获，就不再发生变化</p>
</li>
</ol>
<h2 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h2><p>this 永远指向的是最终调用它的对象 除非改变 this 指向或者箭头函数这种特殊情况</p>
<h2 id="call-和-apply-和-bind-的区别"><a href="#call-和-apply-和-bind-的区别" class="headerlink" title="call 和 apply 和 bind 的区别?"></a>call 和 apply 和 bind 的区别?</h2><p>都是改变 this 的指向<br>call 和 apply 都是可以把函数直接调用, bind 不会直接调用函数</p>
<p>call -&gt; 从第二个参数 开始 就是指的调用的函数的形参<br>apply -&gt; 第二个参数 是一个数组</p>
<p>bind() 最简单的用法是创建一个函数，不论怎么调用，这个函数都有同样的 this 值<br>call和apply都是对函数的直接调用，而bind方法返回的仍然是一个函数，因此后面还需要()来进行调用才可以。</p>
<p>call()方法的作用和 apply() 方法类似，<br>区别：call 传参的时候要求我们给函数传参是一个个传的，而 apply 的要传的参数是以一个数组保存起来；</p>
<p>call 的性能要比 apply 好一些（尤其是传递给函数的参数超过三个的时候）<br>　　let arr = [10, 20, 30],<br>　　obj = { }<br>　　function fn (x, y, z) { }</p>
<p>　　fn.apply (obj, arr);<br>　　fn.call (obj, …arr);  =》基于 ES6 的展开运算符也可以实现把数组中的每一项一次传递给函数<br>   fn.bind(obj)(…arr);  //但是由于bind返回的仍然是一个函数，所以我们还可以在调用的时候再进行传参。</p>
<h2 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h2><ol>
<li><p>防抖：指触发事件后在规定时间内回调函数只能执行一次，如果在规定时间内又触发了该事件，则会重新开始算规定时间。 用途：按钮提交<br>做法：通过定时器将回调函数进行延时.如果在规定时间内继续回调,发现存在之前的定时器,则将该定时器清除,并重新设置定时器.这里有个细节,就是后面所有的回调函数都要能访问到之前设置的定时器,这时就需要用到闭包</p>
</li>
<li><p>节流：当持续触发事件时，在规定时间段内只能调用一次回调函数。如果在规定时间内又触发了该事件，则什么也不做,也不会重置定时器.<br>用途 拖拽</p>
</li>
</ol>
<p>总结：防抖是将多次执行变为最后一次执行，节流是将多次执行变为在规定时间内只执行一次</p>
<h1 id="Git-部分"><a href="#Git-部分" class="headerlink" title="Git 部分"></a>Git 部分</h1><p>git clone –初始化仓库<br>git checkout ‘分支名字’ –切换到某分支<br>git checkout –放弃分支修改<br>git add –将修改加入缓存<br>git commit -m ‘备注修改内容’ –提交到本地仓库<br>git pull –拉取远程仓库变化<br>git push –将本地仓库改动提交到远程<br>git log –查看当前提交日志</p>
<h2 id="提交代码流程"><a href="#提交代码流程" class="headerlink" title="提交代码流程"></a>提交代码流程</h2><p>1、git add .<br>(后面有一个点，意思是将你本地所有修改了的文件添加到暂存区）</p>
<p>2、git commit -m””<br>(引号里面是你的介绍，就是你的这次的提交是什么内容，便于你以后查看，这个是将索引的当前内容与描述更改的用户和日志消息一起存储在新的提交中)</p>
<p>3、git pull origin<br>远程分支名   这是下拉代码，将远程最新的代码先跟你本地的代码合并一下，如果确定远程没有更新，可以不用这个，最好是每次都执行以下，完成之后打开代码查看有没有冲突，并解决，如果有冲突解决完成以后再次执行 1 跟 2 的操作</p>
<p>4、git push origin master<br>(git push origin  本地分支名:refs/remotes/远程分支名） 将代码推至远程就可以了</p>
<h2 id="不提交修改的代码时切换分支的方法"><a href="#不提交修改的代码时切换分支的方法" class="headerlink" title="不提交修改的代码时切换分支的方法"></a>不提交修改的代码时切换分支的方法</h2><ol>
<li>git stash 暂存当前修改的代码 (git stash 的栈会直接给一个 hash 值作为版本的说明)</li>
<li>git stash pop 查看其他分支代码后，切换回来当前分支找回修改的代码。 (将 git stash 栈中最后一个版本取出来)</li>
</ol>
<h2 id="将某个分支的某个文件合并到当前分支"><a href="#将某个分支的某个文件合并到当前分支" class="headerlink" title="将某个分支的某个文件合并到当前分支"></a>将某个分支的某个文件合并到当前分支</h2><p>在当前分支 使用命令 👉 git checkout 某分支名字 某些要合并过来的文件(文件之间用空格隔开)</p>
<h1 id="请求这一块的"><a href="#请求这一块的" class="headerlink" title="请求这一块的"></a>请求这一块的</h1><h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><blockquote>
<p>参考<a href="https://zhuanlan.zhihu.com/p/57142784" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/57142784</a><br>HTTP 协议通过请求/响应的方式，在客户端和服务端之间进行通信。<br>http 和 https http 传输不安全 它的内容容易被第三方截获 https 在 http 的基础上增加了 ssl 安全层</p>
</blockquote>
<h2 id="HTTP-请求头属性"><a href="#HTTP-请求头属性" class="headerlink" title="HTTP 请求头属性"></a>HTTP 请求头属性</h2><p>Accpet</p>
<p>告诉服务端,客户端接收什么类型的响应<br>Referer</p>
<p>表示这是请求是从哪个 URL 进来的,比如想在网上购物,但是不知道选择哪家电商平台,你就去问度娘,说哪家电商的东西便宜啊,然后一堆东西弹出在你面前,第一给就是某宝,当你从这里进入某宝的时候,这个请求报文的 Referer 就是<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a><br>Cache-Control</p>
<p>对缓存进行控制,如一个请求希望响应的内容在客户端缓存一年,或不被缓可以通过这个报文头设置<br>Accept-Encoding</p>
<p>这个属性是用来告诉服务器能接受什么编码格式,包括字符编码,压缩形式(一般都是压缩形式)</p>
<p>例如:Accept-Encoding:gzip, deflate(这两种都是压缩格式)<br>Host</p>
<p>指定要请求的资源所在的主机和端口<br>User-Agent 作用：告诉服务器，客户端使用的操作系统、浏览器版本和名称</p>
<h2 id="浏览器缓存-强制缓存和协商缓存"><a href="#浏览器缓存-强制缓存和协商缓存" class="headerlink" title="浏览器缓存-强制缓存和协商缓存"></a>浏览器缓存-强制缓存和协商缓存</h2><p>原理：浏览器在本地磁盘对用户最近请求过的资源进行存储，当再次访问同一页面时，按照特定的策略加载缓存中的资源。<br>浏览器缓存的优点有： 减少多余的数据传输，减少服务器的负担，提升网站的性能 加快了客户端加载网页的速度</p>
<p>强制缓存—— 状态码 200 不发送请求直接从缓存取 F5 刷新和 Ctrl+F5 强制刷新会致 Expires/Cache-Control 失效<br>浏览器会先获取该资源缓存的 header 信息，根据其中的 expires 和 cahe-control(用来表示资源的缓存时间)判断是否命中强缓存，若命中则直接从缓存中获取资源，包括缓存的 header 信息，本次请求不会与服务器进行通信；<br>Cache-Control:max-age=3600，代表着资源的有效期是 3600 秒。<br>Cache-Control 还有其他的一些常用值 no-cache：不使用本地缓存。 no-store：直接禁止游览器缓存数据</p>
<p>协商缓存—— 状态码 304 不发送请求通过服务器来告知缓存是否可用 Ctrl+F5 强制刷新会致 Last-Modied/Etag 失效<br>如果没有命中强缓存，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的 header 字段信息（Last-Modified/IF-Modified-Since、Etag/IF-None-Match）,由服务器根据请求中的相关 header 信息来对比结果是否命中协商缓存，若命中，则服务器返回新的响应 header 信息更新缓存中的对应 header 信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容</p>
<h2 id="前端常见的攻击以及防御"><a href="#前端常见的攻击以及防御" class="headerlink" title="前端常见的攻击以及防御"></a>前端常见的攻击以及防御</h2><ol>
<li>XSS（Cross Site Scripting）跨站脚本攻击</li>
</ol>
<p>（1）原理：页面渲染的数据中包含可运行的脚本<br>（2）攻击的基本类型：反射型（url 参数直接注入）和存储型（存储到 DB 后读取时注入）<br>（3）注入点：HTML 节点内的内容（text）；HTML 中 DOM 元素的属性；Javascript 代码；富文本<br>解决: 1.我们可以在 http 响应头中设置 Content-Security-Policy 2.浏览器自带防御机制，http 响应头中自动添加 x-xss-protection，值为 0（关闭），1（打开），默认打开</p>
<p>//同时 meta 中也支持设置 Content-Security-Policy</p>
<ol start="2">
<li><p>CSRF（Cross Site Request Forgy）跨站请求伪造<br>原理：在第三方网站向本网站发起请求<br>（1）用户在 a 站前端页面发起登录（身份认证）请求<br>（2）a 站后端确认身份，登录成功，cookie 中存在用户的身份认证信息<br>（3）b 站前端页面向 a 站后端发起请求，带着 a 站的 cookie 信息（身份认证信息），请求成功<br>解决: 1.禁止第三方网站携带本网站的 cookie 信息 2.本网站前端页面添加验证信息：使用验证码或者添加 token 验证</p>
</li>
<li><p>点击劫持</p>
</li>
</ol>
<p>原理：第三方网站通过 iframe 内嵌某一个网站，并且将 iframe 设置为透明不可见，将其覆盖在其他经过伪装的 DOM 上，伪装的可点击 DOM（按钮等）与实际内嵌网站的可点击 DOM 位置相同，当用户点击伪装的 DOM 时，实际上点击的是 iframe 中内嵌的网页的 DOM 从而触发请求操作<br>特点：用户自己做了点击操作；用户毫不知情；<br>解决:禁止内嵌</p>
<p>看这个 <a href="https://www.cnblogs.com/zhiying/p/11018331.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhiying/p/11018331.html</a></p>
<h2 id="Iframe-有什么好处，有什么坏处？"><a href="#Iframe-有什么好处，有什么坏处？" class="headerlink" title="Iframe 有什么好处，有什么坏处？"></a>Iframe 有什么好处，有什么坏处？</h2><p>1.建立长连接 2.可以跨越通信(如多页面的中的音乐播放器) 3.</p>
<p><a href="https://www.zhihu.com/question/20653055" target="_blank" rel="noopener">https://www.zhihu.com/question/20653055</a></p>
<h2 id="javascript-的同源策略"><a href="#javascript-的同源策略" class="headerlink" title="javascript 的同源策略?"></a>javascript 的同源策略?</h2><p>一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是主机名、协议和端口号的组合</p>
<h2 id="浏览器为什么要有同源策略"><a href="#浏览器为什么要有同源策略" class="headerlink" title="浏览器为什么要有同源策略"></a>浏览器为什么要有同源策略</h2><p>一个重要原因就是保护 cookie，cookie 中存着用户的登陆凭证，就相当于用户的账号密码。<br>如:<br>想象以下场景，你突然收到一封邮件说你的银行账号存在安全隐患，点击<a href="http://www.shazilai.com修复。虽然银行的官方网站是www.anquan.com，慌乱的你没有注意这么多点击链接输入帐号密码进行登陆。这个网站其实是" target="_blank" rel="noopener">www.shazilai.com修复。虽然银行的官方网站是www.anquan.com，慌乱的你没有注意这么多点击链接输入帐号密码进行登陆。这个网站其实是</a></p>
<p><iframe src="www.anquan.com"><br>在你输入帐号密码的时候，如果没有同源策略，外部已经有脚本获取你的输入或者直接通过document.cookie窃取了你的信息并且发送给攻击者了。</iframe></p>
<h2 id="ajax-请求的时候-get-和-post-方式的区别"><a href="#ajax-请求的时候-get-和-post-方式的区别" class="headerlink" title="ajax 请求的时候 get 和 post 方式的区别?"></a>ajax 请求的时候 get 和 post 方式的区别?</h2><p>get 请求和发送数据的内容都在 地址栏里 明文传输 不安全 32k<br>post (参数是有一个包的 所以比较安全) 比较安全 2g</p>
<h2 id="既然如此那么-get-还有什么存在的意义"><a href="#既然如此那么-get-还有什么存在的意义" class="headerlink" title="既然如此那么 get 还有什么存在的意义"></a>既然如此那么 get 还有什么存在的意义</h2><p>GET 有如下几个特点：get 表达的是一种幂等的，只读的，纯粹的操作，即它除了返回结果不应该会产生其它副作用（如写数据库），因此绝大部分 get 请求（通常超过 90%）都直接被 CDN 缓存了，这能大大减少 web 服务器的负担。</p>
<p>POST 请求有如下特点：而 post 所表达的语义是非幂等的，有副作用的操作，所以必须交由 web 服务器处理。</p>
<p>问“为什么不用 POST 代替 GET”是没有意义的，就像“为什么不用写代替读”一样没有意义。</p>
<h2 id="跨域解决方案-造成跨域是因为（域名不同、端口不同，IP-不同）"><a href="#跨域解决方案-造成跨域是因为（域名不同、端口不同，IP-不同）" class="headerlink" title="跨域解决方案? 造成跨域是因为（域名不同、端口不同，IP 不同）"></a>跨域解决方案? 造成跨域是因为（域名不同、端口不同，IP 不同）</h2><p>参考 <a href="https://www.cnblogs.com/itmacy/p/6958181.html" target="_blank" rel="noopener">https://www.cnblogs.com/itmacy/p/6958181.html</a></p>
<ol>
<li>使用 ajax 的 jsonp 利用&lt; script\ &gt;标签的 src 可以跨域,就有了 jsonp 这种非正式传输协议<br>请求方式只能是 get 请求 与服务端协商 callback 返回值 返回的数据也是 jsonp 格式的-回调函数名(json 数据)</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:<span class="string">''</span>,</span><br><span class="line">    type:<span class="string">'get'</span>,</span><br><span class="line">    dataType:<span class="string">'jsonp'</span>, <span class="comment">//接收服务器数据的类型</span></span><br><span class="line">    jsonp:<span class="string">'callback'</span>, <span class="comment">//用于服务端的获取函数的参数</span></span><br><span class="line">    jsonpCallback:<span class="string">'callback-success'</span> <span class="comment">//函数名称</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>还有使用 jQuery 的 jsonp 插件 与方式一相比，请求方式不只局限于 get 请求，还可以是 post 请求，但从服务器从获取的数据依然是 jsonp 格式</p>
<ol start="2">
<li>vue 在 Config/index.js 里面进行配置 proxyTable: {}</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">proxytable&#123;</span><br><span class="line"></span><br><span class="line">  <span class="string">'/apis'</span>:&#123;</span><br><span class="line"></span><br><span class="line">  target:<span class="string">'http://www.news.com'</span>,<span class="comment">//接口域名</span></span><br><span class="line"></span><br><span class="line">  changeOrgin:<span class="literal">true</span>,<span class="comment">//是否跨域</span></span><br><span class="line"></span><br><span class="line">      pathRewrite:&#123;</span><br><span class="line"></span><br><span class="line">      <span class="string">'^/apis'</span>:<span class="string">' '</span><span class="comment">//需要rewrite重写的</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>关闭 chrome 安全策略实现跨域</li>
</ol>
<h2 id="多级域名跨域吗"><a href="#多级域名跨域吗" class="headerlink" title="多级域名跨域吗"></a>多级域名跨域吗</h2><p>应该算跨域的 但这里有两个关键字 父域 cookie 和认证中心</p>
<h2 id="TCP-IP-协议"><a href="#TCP-IP-协议" class="headerlink" title="TCP/IP 协议"></a>TCP/IP 协议</h2><p>按照层次由上到下，层层包装。<br>最上面的是应用层，这里面有 http，ftp,等等我们熟悉的协议。<br>而第二层则是传输层，著名的 TCP 和 UDP 协议就在这个层次。<br>第三层是网络层，IP 协议就在这里，它负责对数据加上 IP 地址和其他的数据以确定传输的目标。<br>第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行 CRC 编码，为最后的数据传输做准备。</p>
<h2 id="http-的三次握手和四次挥手"><a href="#http-的三次握手和四次挥手" class="headerlink" title="http 的三次握手和四次挥手"></a>http 的三次握手和四次挥手</h2><blockquote>
<p><a href="https://www.jianshu.com/p/bd31d3b23725" target="_blank" rel="noopener">https://www.jianshu.com/p/bd31d3b23725</a></p>
</blockquote>
<p>第一次握手：主机 A 发送位码为 syn ＝ 1,随机产生 seq number=1234567 的数据包到服务器，主机 B 由 SYN=1 知道，A 要求建立联机；<br>第二次握手：主机 B 收到请求后要确认联机信息，向 A 发送 ack number=(主机 A 的 seq+1),syn=1,ack=1,随机产生 seq=7654321 的包；<br>第三次握手：主机 A 收到后检查 ack number 是否正确，即第一次发送的 seq number+1,以及位码 ack 是否为 1，若正确，主机 A 会再发送 ack number=(主机 B 的 seq+1),ack=1，主机 B 收到后确认 seq 值与 ack=1 则连接建立成功。</p>
<p>第一次挥手：TCP 发送一个 FIN(结束)，用来关闭客户到服务端的连接。<br>第二次挥手：服务端收到这个 FIN，他发回一个 ACK(确认)，确认收到序号为收到序号+1，和 SYN 一样，一个 FIN 将占用一个序号。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。（服务器端继续发送未发送完的数据）<br>第三次挥手：服务端发送一个 FIN(结束)到客户端，服务端关闭客户端的连接。<br>第四次挥手：客户端发送 ACK(确认)报文确认，并将确认的序号+1，这样关闭完成。<br>注：1、那么为什么是 4 次挥手呢？tcp 握手的时候为何 ACK(确认)和 SYN(建立连接)是一起发送。挥手的时候为什么是分开的时候发送呢？<br>因为当 Server 端收到 Client 端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当 Server 端收到 FIN 报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉 Client 端，”你发的 FIN 报文我收到了”。只有等到我 Server 端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。故需要四步握手。</p>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码:"></a>状态码:</h2><p>状态码的第一位数字表示了响应状态的类型，其中<br>1xx 信息提示<br>2xx 成功<br>3xx 重定向<br>4xx 客户端错误<br>5xx 服务器错误<br>100 继续。客户端应继续其请求<br>101 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议<br>200 表示从客户端发来的请求在服务器端被正常处理了。<br>204 该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中 不含实体的主体部分。<br>206 该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。<br>301 永久重定向。该状态码表示请求的资源已被分配了新的 URI，以后 应使用资源现在所指的 URI。<br>302 临时重定向。该状态码表示请求的资源已被分配了新的 URI，希望 用户（本次）能使用新的 URI 访问。<br>400 该状态码表示请求报文中存在语法错误。<br>401 该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、 DIGEST 认证）的认证信息。<br>403 该状态码表明对请求资源的访问被服务器拒绝了。<br>404 该状态码表明服务器上无法找到请求的资源。</p>
<h2 id="打开浏览器，输入-URL，到页面展示出来的过程："><a href="#打开浏览器，输入-URL，到页面展示出来的过程：" class="headerlink" title="打开浏览器，输入 URL，到页面展示出来的过程："></a>打开浏览器，输入 URL，到页面展示出来的过程：</h2><p>输入 URL<br>DNS 解析<br>TCP 握手<br>HTTP 请求<br>HTTP 响应返回数据<br>浏览器解析并渲染页面</p>
<h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><h2 id="对于-MVC-MVVM-的理解？"><a href="#对于-MVC-MVVM-的理解？" class="headerlink" title="对于 MVC MVVM 的理解？"></a>对于 MVC MVVM 的理解？</h2><p>MVC: MVC 是一种设计思想 分成 3 个核心模块，业务层(负责实现应用程序的业务逻辑，封装有各种对数据的处理方法)-视图层(负责应用程序对用户的显示)-控制层(负责控制应用程序的流程)<br>优点: 1.有利于代码的复用 2.有利于开发人员分工 3.有利于降低程序模块间的耦合，便于程序的维护与扩展。<br>所有通信都是单向的</p>
<p>MVVM: 数据模型 视图 视图模型 通过双向数据绑定把 View 层和 Model 层连接了起来 开发者只需关注业务逻辑,不需要手动操作 DOM.</p>
<h2 id="双向数据绑定原理"><a href="#双向数据绑定原理" class="headerlink" title="双向数据绑定原理"></a>双向数据绑定原理</h2><ol>
<li><p>Vue2：通过 es5 的 Object.defineProperty，中的 set 方法来实现数据劫持的，在数据发生变动的时候通知订阅着触发相应的回调。<br>但是有一个弊端就是无法兼听到数组内部的数据变化(当然我们可以通过 arr = arr.concat([]))，来实现内部数据变化的检测。相比 Vue3 有一定的性能问题。</p>
</li>
<li><p>Vue3：是用 ES6 的语法 Proxy 对象来实现的，这个玩意儿也可以实现数据的劫持，相比 Object.defineProperty 的优势是：可以检测到数组内部数据的变化<br>（IE 系列都不兼容 Proxy，所以可能还是用 Object.</p>
</li>
</ol>
<h2 id="Object-defineProperty-是怎么监听数组变化的"><a href="#Object-defineProperty-是怎么监听数组变化的" class="headerlink" title="Object.defineProperty 是怎么监听数组变化的"></a>Object.defineProperty 是怎么监听数组变化的</h2><p>通过重写 Array 的原型方法 原理就是重写数组的七个原始方法,当使用者执行这些方法时,我们就可以监听到数据的变化,然后做些跟新操作<br><a href="https://blog.csdn.net/lyh6665/article/details/107929324" target="_blank" rel="noopener">https://blog.csdn.net/lyh6665/article/details/107929324</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> orginalProto = <span class="built_in">Array</span>.prototype;</span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Object</span>.create(orginalProto); <span class="comment">// 先克隆一份Array的原型出来</span></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">"push"</span>,</span><br><span class="line">  <span class="string">"pop"</span>,</span><br><span class="line">  <span class="string">"shift"</span>,</span><br><span class="line">  <span class="string">"unshift"</span>,</span><br><span class="line">  <span class="string">"splice"</span>,</span><br><span class="line">  <span class="string">"sort"</span>,</span><br><span class="line">  <span class="string">"reverse"</span>,</span><br><span class="line">];</span><br><span class="line">methodsToPatch.forEach(<span class="function">(<span class="params">method</span>) =&gt;</span> &#123;</span><br><span class="line">  arrayProto[method] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 执行原始操作</span></span><br><span class="line">    orginalProto[method].apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"监听赋值成功"</span>, method);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="数组下标更改数组的值不生效"><a href="#数组下标更改数组的值不生效" class="headerlink" title="数组下标更改数组的值不生效"></a>数组下标更改数组的值不生效</h2><p>Vue2并不支持数组下标的响应式。也就是说Vue2检测不到通过下标更改数组的值。<br>为何Object.defineProperty已经实现了对对象属性和数组已有元素的监听 确不支持数组下标修改的双向绑定呢? 对此尤大的回答是性能代价和获得的用户体验收益不成正比</p>
<p>解决办法：使用Vue官网提供的方法更改数组下标的值 this.$set(this.list, index, this.list[index])</p>
<h2 id="Proxy-的优势如下"><a href="#Proxy-的优势如下" class="headerlink" title="Proxy 的优势如下"></a>Proxy 的优势如下</h2><p>Proxy 可以直接监听整个对象而非属性。<br>Proxy 可以直接监听数组的变化。<br>Proxy 有 13 中拦截方法，如 ownKeys、deleteProperty、has 等是 Object.defineProperty 不具备的。<br>Proxy 返回的是一个新对象，我们可以只操作新的对象达到目的，而 Object.defineProperty 只能遍历对象属性直接修改;<br>Proxy 做为新标准将受到浏览器产商重点持续的性能优化,也就是传说中的新标准的性能红利。</p>
<p>Object.defineProperty 的优势如下<br>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平。</p>
<p>Object.defineProperty 不足在于：<br>Object.defineProperty 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。<br>Object.defineProperty 不能监听数组。是通过重写数据的那 7 个可以改变数据的方法来对数组进行监听的。<br>Object.defineProperty 也不能对 es6 新产生的 Map,Set 这些数据结构做出监听。<br>Object.defineProperty 也不能监听新增和删除操作，通过 Vue.set()和 Vue.delete 来实现响应式的。</p>
<h2 id="proxy-都有哪些参数"><a href="#proxy-都有哪些参数" class="headerlink" title="proxy 都有哪些参数"></a>proxy 都有哪些参数</h2><p><a href="https://www.cnblogs.com/xiaonian8/p/13764938.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaonian8/p/13764938.html</a></p>
<h2 id="Object-defineProperty-将属性变为不可修改"><a href="#Object-defineProperty-将属性变为不可修改" class="headerlink" title="Object.defineProperty() 将属性变为不可修改"></a>Object.defineProperty() 将属性变为不可修改</h2><p><a href="http://cn.voidcc.com/question/p-xqtmixbf-uc.html" target="_blank" rel="noopener">http://cn.voidcc.com/question/p-xqtmixbf-uc.html</a><br>防止在Javascript原型对象中更改属性的值<br>我有一个对象，我有一个名为“country”的属性作为Ireland。我想阻止开发人员在尝试更新代码时修改这个属性</p>
<p>一个可能的方法与Object.defineProperty()定义在init()这个属性为不可写<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Car = &#123;<span class="attr">country</span>:<span class="string">'England'</span>&#125;; </span><br><span class="line"></span><br><span class="line">Car.prototype = &#123; </span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, <span class="string">'country'</span>, &#123; </span><br><span class="line">     value: <span class="keyword">this</span>.country, </span><br><span class="line">     enumerable: <span class="literal">true</span>, </span><br><span class="line">    &#125;); </span><br><span class="line">    &#125;, </span><br><span class="line">    country: <span class="string">'Ireland'</span>, </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="单向数据流和双向数据绑定"><a href="#单向数据流和双向数据绑定" class="headerlink" title="单向数据流和双向数据绑定"></a>单向数据流和双向数据绑定</h2><p>单向数据流： 数据是单向的 流动方向单一方便跟踪 追查问题更快速 缺点就是写起来不太方便<br>双休数据绑定： 数据之间相通 将数据变更操作隐藏在框架内部 会简化大量业务代码 但是出错时增加了追查问题的难度</p>
<h2 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h2><p>2.0 生命生命周期变化感觉变得更加语义化一点（有规律可寻，更好记了），而且增加了 beforeUpdate、updated、activated、deactivated，删除了 attached、detached。<br>(Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载 Dom→ 渲染、更新 → 渲染、销毁等一系列过程，称之为 Vue 的生命周期。)</p>
<ol>
<li>beforeCreate（创建前）<br>在数据观测和初始化事件还未开始</li>
<li>created（创建后）<br>完成数据观 vue 测，属性和方法的运算，初始化事件，\$el 属性还没有显示出来</li>
<li>beforeMount（载入前）<br>在挂载开始之前被调用，相关的 render 函数首次被调用。实例已完成以下的配置：编译模板，把 data 里面的数据和模板生成 html。注意此时还没有挂载 html 到页面上。</li>
<li>mounted（载入后）<br>在 el 被新创建的 vm.\$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的 html 内容替换 el 属性指向的 DOM 对象。完成模板中的 html 渲染到 html 页面中。此过程中进行 ajax 交互。</li>
<li>beforeUpdate（更新前）<br>在数据更新之前调用，发生在虚拟 DOM 重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。</li>
<li>updated（更新后）<br>在由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用。调用时，组件 DOM 已经更新，所以可以执行依赖于 DOM 的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li>
<li>activated keep-alive<br>  组件激活时调用。该钩子在服务器端渲染期间不被调用</li>
<li>deactivated keep-alive<br>  组件停用时调用。该钩子在服务器端渲染期间不被调用</li>
<li>beforeDestroy（销毁前）<br>在实例销毁之前调用。实例仍然完全可用。</li>
<li>destroyed（销毁后）<br>在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</li>
<li>errorCaptured（2.5.0+ 新增）<br>  当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生 错误的组件实例以及一个包含错误来源信息的字符串，此钩子可以返回 false 以阻止该错误继续 向上传播</li>
</ol>
<h2 id="父子组件的生命周期顺序"><a href="#父子组件的生命周期顺序" class="headerlink" title="父子组件的生命周期顺序"></a>父子组件的生命周期顺序</h2><p>父 beforeCreate-&gt; 父 created-&gt; 父 beforeMount-&gt; 子 beforeCreate-&gt; 子 created-&gt; 子 beforeMount-&gt; 子 mounted-&gt; 父 mounted</p>
<p>子组件在父组件的 beforemounted 生命钩子完后才能后就开始实例化自己，并走完自己的整个生命周期<br>等子组件的生命周期构建完成后挂载到父组件上，父组件的 mounted 才会执行，所以子组件先父组件完成生命周期。这也就是为什么在只有在 mounted 中的 children 属性才能看有子组件值，而不是空数组</p>
<h2 id="子组件更新过程"><a href="#子组件更新过程" class="headerlink" title="子组件更新过程"></a>子组件更新过程</h2><p>父 beforeUpdate-&gt; 子 beforeUpdate-&gt; 子 updated-&gt; 父 updated</p>
<h2 id="父组件更新过程"><a href="#父组件更新过程" class="headerlink" title="父组件更新过程"></a>父组件更新过程</h2><p>父 beforeUpdate-&gt; 父 updated</p>
<h2 id="销毁过程"><a href="#销毁过程" class="headerlink" title="销毁过程"></a>销毁过程</h2><p>父 beforeDestroy-&gt; 子 beforeDestroy-&gt; 子 destroyed-&gt; 父 destroyed</p>
<h2 id="第一次页面加载会触发哪几个钩子？"><a href="#第一次页面加载会触发哪几个钩子？" class="headerlink" title="第一次页面加载会触发哪几个钩子？"></a>第一次页面加载会触发哪几个钩子？</h2><p>答：会触发 下面这几个 beforeCreate, created, beforeMount, mounted 。</p>
<h2 id="DOM-渲染在-哪个周期中就已经完成？"><a href="#DOM-渲染在-哪个周期中就已经完成？" class="headerlink" title="DOM 渲染在 哪个周期中就已经完成？"></a>DOM 渲染在 哪个周期中就已经完成？</h2><p>答：DOM 渲染在 mounted 中就已经完成了。</p>
<h2 id="在哪个生命周期内调用异步请求"><a href="#在哪个生命周期内调用异步请求" class="headerlink" title="在哪个生命周期内调用异步请求"></a>在哪个生命周期内调用异步请求</h2><p>一般来说，可以在，created，mounted 中都可以发送数据请求，但是，大部分时候，会在 created 发送请求。</p>
<p>在 created 钩子函数触发时，组件的 data 数据、通过路由注入的数据已经具备，此时可以使用这些数据发送 ajax 请求。<br>在 mounted 钩子函数中发起也可以，但是相对比 created 稍微迟了一些。<br>如果不需要依赖任何数据发起 ajax 请求，那么在 beforeCreate 发起也可以。</p>
<p>有两个优点：<br>第一点：能更快获取到服务端数据，减少页面 loading 时间；<br>第二点：放在 created 中有助于一致性，因为 ssr 不支持 beforeMount 、mounted 钩子函数。</p>
<h2 id="created-与-activated-有什么区别"><a href="#created-与-activated-有什么区别" class="headerlink" title="created 与 activated 有什么区别"></a>created 与 activated 有什么区别</h2><p>created(): 在创建 vue 对象时，当 html 渲染之前就触发，但是全局 vue.js 不强制刷新或者重启时只创建一次，就是说 created()只会触发一次</p>
<p>activated()：是在路由设置<keep-alive></keep-alive>时，才会有这个生命周期。在被 keep-alive 缓存的组件激活时调用。</p>
<h2 id="keep-alive-两个属性-gt-include、exclude-属性"><a href="#keep-alive-两个属性-gt-include、exclude-属性" class="headerlink" title="keep-alive 两个属性-&gt; include、exclude 属性"></a>keep-alive 两个属性-&gt; include、exclude 属性</h2><p><a href="https://www.jianshu.com/p/4b55d312d297" target="_blank" rel="noopener">https://www.jianshu.com/p/4b55d312d297</a></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">"bookLists,bookLists"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">exclude</span>=<span class="string">"indexLists"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>include 属性表示只有 name 属性为 bookLists，bookLists 的组件会被缓存，（注意是组件的名字，不是路由的名字）其它组件不会被缓存 exclude 属性表示除了 name 属性为 indexLists 的组件不会被缓存，其它组件都会被缓存</p>
<h2 id="vue-js-的两个核心是什么？"><a href="#vue-js-的两个核心是什么？" class="headerlink" title="vue.js 的两个核心是什么？"></a>vue.js 的两个核心是什么？</h2><p>答：数据驱动、组件系统</p>
<h2 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h2><p>父组件传给子组件：子组件通过 props 方法接受数据;<br>父组件调用子组件函数:ref this.$refs.子组件.function();<br>子组件传给父组件：\$emit 方法传递参数<br>子组件调用父组件函数:$emit</p>
<p>兄弟组件传参:1.eventBus 2.Vuex<br>跨组件传参： 1.Vuex 2.Bus 3.( provide/inject ) 4.( $attrs/$listeners )</p>
<h2 id="v-model-的原理？"><a href="#v-model-的原理？" class="headerlink" title="v-model 的原理？"></a>v-model 的原理？</h2><p>v-model 是个语法糖:<br>v-bind:value=”value”<br>v-on:input=”e =&gt; value = e.target.value”<br>因为 V-model 并不仅限于 Form 表单, 目前还支持更改事件名称和变量名称<br>model: {<br>prop: ‘checked’,<br>event: ‘change’<br>}</p>
<h2 id="对-vue-的表单修饰符-lazy-的理解"><a href="#对-vue-的表单修饰符-lazy-的理解" class="headerlink" title="对 vue 的表单修饰符.lazy 的理解"></a>对 vue 的表单修饰符.lazy 的理解</h2><p>input 标签 v-model 用 lazy 修饰之后，vue 并不会立即监听 input Value 的改变，会在 input 失去焦点之后，才会触发 input Value 的改变</p>
<h2 id="vue-给组件绑定自定义事件无效怎么解决？"><a href="#vue-给组件绑定自定义事件无效怎么解决？" class="headerlink" title="vue 给组件绑定自定义事件无效怎么解决？"></a>vue 给组件绑定自定义事件无效怎么解决？</h2><p>两种方式</p>
<ol>
<li>组件外部加修饰符.navtive</li>
<li>组件内部声明\$emit(‘自定义事件’)</li>
</ol>
<h2 id="vue-的-sync-修饰符用法"><a href="#vue-的-sync-修饰符用法" class="headerlink" title="vue 的 sync 修饰符用法"></a>vue 的 sync 修饰符用法</h2><p>答：sync 修饰符是一个语法糖，类似 v-model，它主要是解决了父子组件的双向绑定问题。sync 不能使用表达式</p>
<p>使用: 传值通过 变量.sync=’变量’ 接收也是props 子组件修改必须this.$emit(“update:变量”, 新值);</p>
<p>因为 vue 提倡的是单向数据流动，因此不能直接在子组件里面修改父组件传过来的数据，父子组件一个数据修改要带一个自定义事件才能实现双向绑定，但是有了 sync 可以这么写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;visible = true&quot;&gt;点击&lt;/button&gt;</span><br><span class="line">    &lt;my-alert :visible.sync=&quot;visible&quot;&gt;&lt;/my-alert&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;scrip &gt;</span><br><span class="line">import myalert from &quot;./components/myalert&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;App&quot;,</span><br><span class="line">  components: &#123; &quot;my-alert&quot;: myalert &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      visible: false,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt; /scrip&gt;</span><br><span class="line"></span><br><span class="line">// myalert.vue:</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;cont&quot; v-show=&quot;visible&quot;&gt;</span><br><span class="line">    &lt;h2&gt;这是一个对话框&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;closeAlert&quot;&gt;关闭&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script &gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;myalert&quot;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    visible: &#123;</span><br><span class="line">      type: Boolean,</span><br><span class="line">      default: false,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    closeAlert() &#123;</span><br><span class="line">      this.$emit(&quot;update:visible&quot;, false);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script &gt;</span><br></pre></td></tr></table></figure>
<h2 id="sync-和-v-model-的区别"><a href="#sync-和-v-model-的区别" class="headerlink" title="sync 和 v-model 的区别"></a>sync 和 v-model 的区别</h2><p>v-model 必须是 input 标签，它做了两步动作：<br>1、父组件传给子组件 value<br>2、子组件通过触发 input 事件来修改 value<br>因此，子组件必须有 input 标签才行。<br>而 sync 不限制标签，因此子组件在修改数据时，就必须约定使用@update:xxx</p>
<h2 id="如何在子组件中访问父组件的实例？"><a href="#如何在子组件中访问父组件的实例？" class="headerlink" title="如何在子组件中访问父组件的实例？"></a>如何在子组件中访问父组件的实例？</h2><p>父组件想调用子组件的方法，可以在子组件中加上 ref，然后通过 this.\$refs.ref.method <a href="https://www.cnblogs.com/jin-zhe/p/9523029.html" target="_blank" rel="noopener">调用</a></p>
<p>Vue 中子组件调用父组件的方法，这里有三种方法提供参考：</p>
<ol>
<li>直接在子组件中通过 this.\$parent.event 来调用父组件的方法</li>
<li>在子组件里用\$emit 向父组件触发一个事件，父组件监听这个事件</li>
<li>父组件把方法传入子组件中，在子组件里直接调用<a href="https://www.cnblogs.com/jin-zhe/p/9523782.html" target="_blank" rel="noopener">这个方法</a></li>
</ol>
<h2 id="为什么父组件更新而子组件不更新"><a href="#为什么父组件更新而子组件不更新" class="headerlink" title="为什么父组件更新而子组件不更新"></a>为什么父组件更新而子组件不更新</h2><p>在子组件中加入 watch 进行数据监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;&gt;</span><br><span class="line">data()&#123;</span><br><span class="line">  return&#123;</span><br><span class="line">    msg:&quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch:&#123;</span><br><span class="line">    parendData(n,o)&#123; //n为新值,o为旧值;</span><br><span class="line">      this.msg = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">props:[&quot;parendData&quot;],</span><br><span class="line">mounted()&#123;</span><br><span class="line">  this.msg = this.parendData;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="视图不更新"><a href="#视图不更新" class="headerlink" title="视图不更新"></a>视图不更新</h2><p><a href="https://blog.csdn.net/bigbear00007/article/details/102594645" target="_blank" rel="noopener">参考</a></p>
<ol>
<li>Vue.set( target, key, value ) 或者 this.\$set(target, key, value); target 可以是 obj 或 arr 如 Vue.set( arr, arr[i], ‘newText’ )</li>
<li>nextick 可在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数在 DOM 更新完成后就会调用。例如：</li>
</ol>
<p>this.tableData = []<br>for (let i in list) {<br>this.$set(this.tableData,i,list[i])<br>}<br>this.tableData.splice(1,0);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;&gt;</span><br><span class="line">data()&#123;</span><br><span class="line">  return&#123;</span><br><span class="line">    message:&quot;未更新&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    updataMessage()&#123;</span><br><span class="line">      this.message=&quot;已经更新&quot;</span><br><span class="line">      console.log(this.message) //未更新</span><br><span class="line">      this.$nextTick(=&gt;&#123;</span><br><span class="line">        console.log(this.message) //已经更新</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      // 因为 $nextTick()返回一个 Promise 对象，所以可以使用新的 ES2016 async/await简写为👇：</span><br><span class="line">      await this.$nextTick()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/&gt;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>数组数据变动，有些方法无法被 vue 监测 (如 arr.items[i] = newValue)<br>push()，pop()，shift()，unshift()，splice()，sort()，reverse()可被 vue 检测到<br>filter(), concat(), slice()。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组。</p>
</li>
<li><p>vue 多层循环，动态改变数据后渲染的很慢或者不渲染<br>添加 this.$forceUpdate();进行强制渲染。原因：因为数据层次太多，render 函数没有自动更新，需手动强制刷新。</p>
</li>
</ol>
<h2 id="nextTick-的内部实现原理"><a href="#nextTick-的内部实现原理" class="headerlink" title="nextTick 的内部实现原理"></a>nextTick 的内部实现原理</h2><p><a href="http://www.bubuko.com/infodetail-3219154.html" target="_blank" rel="noopener">http://www.bubuko.com/infodetail-3219154.html</a></p>
<p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p>
<p>数据的变化到 DOM 的重新渲染是一个异步过程!!! 当我们在实际开发中，比如从服务端接口去获取数据的时候，数据做了修改，如果我们的某些方法去依赖了数据修改后的 DOM 变化，我们就必须在 nextTick 后执行。如下：</p>
<p>getData(res).then(()=&gt;{<br>this.xxx = res.data<br>this.\$nextTick(() =&gt; {<br>// 这里我们可以获取变化后的 DOM<br>})<br>})</p>
<h2 id="vue-set-做了什么"><a href="#vue-set-做了什么" class="headerlink" title="vue.set 做了什么"></a>vue.set 做了什么</h2><p>总结的来说就是内部使用了数组原生方法 splice 通过去修改原数据触发更新</p>
<h2 id="跳转页面三种方式"><a href="#跳转页面三种方式" class="headerlink" title="跳转页面三种方式"></a>跳转页面三种方式</h2><p>总结就三种 router-link $router.push $router.replace</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&apos;需要跳转到的页面的路&gt;  &lt;/router-link &gt;</span><br><span class="line"></span><br><span class="line">&lt;router-link :to=&quot;&#123;path:&apos;/register&apos;,query:&#123;id:5,name:&apos;lili&apos;&#125;&#125;&quot;&gt; 注册 &lt;/router-link &gt;</span><br><span class="line"></span><br><span class="line">this.$router.push(&#123;</span><br><span class="line">name: &apos;page1&apos;,</span><br><span class="line">query: &#123;id: 3&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">this.$router.replace(&#123;path：&apos;/&apos; &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="push-会保存在历史记录-replace-没有历史记录"><a href="#push-会保存在历史记录-replace-没有历史记录" class="headerlink" title="push 会保存在历史记录 replace 没有历史记录"></a>push 会保存在历史记录 replace 没有历史记录</h3><ol>
<li><p>this.$router.push()<br>描述：跳转到不同的 url，但这个方法会向 history 栈添加一个记录，点击后退会返回到上一个页面。</p>
</li>
<li><p>this.$router.replace()<br>描述：同样是跳转到指定的 url，但是这个方法不会向 history 里面添加新的记录，点击返回，会跳转到上上一个页面。上一个记录是不存在的。</p>
</li>
</ol>
<h3 id="注：-query-和-params-都可以带参-但是！！"><a href="#注：-query-和-params-都可以带参-但是！！" class="headerlink" title="注： query 和 params 都可以带参 但是！！"></a>注： query 和 params 都可以带参 但是！！</h3><p>jquery 通过 path 来引入路由 展示在地址栏刷新不会丢：localhost:8080/users?id=123 不设置参数也可<br>params 通过 name 来引入路由 不展示在地址栏刷新会丢：localhost:8080/users/123 必须设置参数</p>
<p>this.$router.push({path:”地址”,query:{id:”123”}}); 这是传递参数<br>this.$route.query.id； 这是接受参数</p>
<p>this.$router.push({name:”地址”,params:{id:”123”}}); 这是传递参数<br>this.$route.params.id; 这是接受参数</p>
<h2 id="router-和-route-的区别"><a href="#router-和-route-的区别" class="headerlink" title="$router 和 $route 的区别"></a>$router 和 $route 的区别</h2><p>\$router 是 VueRouter 实例 想要导航到不同的 url 就用它</p>
<p>$route是当前router跳转对象里面可以获取name path query params  如：this.$route.query.id</p>
<h2 id="怎么定义-vue-router-的动态路由-怎么获取传过来的值"><a href="#怎么定义-vue-router-的动态路由-怎么获取传过来的值" class="headerlink" title="怎么定义 vue-router 的动态路由? 怎么获取传过来的值"></a>怎么定义 vue-router 的动态路由? 怎么获取传过来的值</h2><p>答：在 router 目录下的 index.js 文件中，对 path 属性加上 /:id，使用 router 对象的 params.id 获取。</p>
<h2 id="vue-怎么去掉-url-中的"><a href="#vue-怎么去掉-url-中的" class="headerlink" title="vue 怎么去掉 url 中的"></a>vue 怎么去掉 url 中的</h2><p>vue-router 默认使用 hash 模式 所以在路由加载的时候 url 会自带# 使用 history 模式就不会有了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Router(&#123; mode:&apos;history&apos;, routes:[] &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="怎么给-vue-定义全局的方法？"><a href="#怎么给-vue-定义全局的方法？" class="headerlink" title="怎么给 vue 定义全局的方法？"></a>怎么给 vue 定义全局的方法？</h2><ol>
<li>通过 prototype，这个非常方便。Vue.prototype[method]=method;</li>
<li>通过插件 Vue.use(plugin)；</li>
<li>通过 mixin，Vue.mixin(mixins);</li>
<li>👇</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建全局方法</span></span><br><span class="line"><span class="keyword">this</span>.$root.$on(<span class="string">"test"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"test"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁全局方法</span></span><br><span class="line"><span class="keyword">this</span>.$root.$off(<span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用全局方法</span></span><br><span class="line"><span class="keyword">this</span>.$root.$emit(<span class="string">"test"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="vue-如果想扩展某个现有的组件时"><a href="#vue-如果想扩展某个现有的组件时" class="headerlink" title="vue 如果想扩展某个现有的组件时"></a>vue 如果想扩展某个现有的组件时</h2><ol>
<li>使用 Vue.extend 直接扩展</li>
<li>使用 Vue.mixin 全局混入</li>
<li>HOC 封装</li>
<li>加 slot 扩展</li>
</ol>
<h2 id="vue-中怎么重置-data"><a href="#vue-中怎么重置-data" class="headerlink" title="vue 中怎么重置 data"></a>vue 中怎么重置 data</h2><p>bject.assign(this.$data, this.$options.data()) 或者逐个重新赋值或者强制刷新组件</p>
<p>如何是重置 data 中的某个表单数据 👇<br>this.params = this.\$options.data().params</p>
<h2 id="vue-组件的-data-为什么必须是函数"><a href="#vue-组件的-data-为什么必须是函数" class="headerlink" title="vue 组件的 data 为什么必须是函数"></a>vue 组件的 data 为什么必须是函数</h2><p>因为 data 是一个对象那么他就属于引用类型，当我们修改其中一个属性时 会影响所有 vue 实例数据<br>如果将 data 作为一个函数返回对象 那么 data 属性都是独立的 不会互相影响</p>
<h2 id="vue-变量名如果以-、-开头的属性会发生什么问题"><a href="#vue-变量名如果以-、-开头的属性会发生什么问题" class="headerlink" title="vue 变量名如果以_、\$开头的属性会发生什么问题"></a>vue 变量名如果以_、\$开头的属性会发生什么问题</h2><p>报错 变量未定义<br>以 _ 或 $ 开头的属性 不会 被 Vue 实例代理，因为它们可能和 Vue 内置的属性、API 方法冲突。<br>你可以使用例如 $data.xxx 或者_data.xxx 的方式访问这些属性。</p>
<h2 id="在使用计算属性的时，函数名和-data-数据源中的数据可以同名吗？"><a href="#在使用计算属性的时，函数名和-data-数据源中的数据可以同名吗？" class="headerlink" title="在使用计算属性的时，函数名和 data 数据源中的数据可以同名吗？"></a>在使用计算属性的时，函数名和 data 数据源中的数据可以同名吗？</h2><p>不该同名 这属于命名不规范</p>
<p>props、methods、data、computed、watch 会按这个顺序挂载在 vm 实例上，重名会覆盖前者 因此不能同名</p>
<h2 id="watch-和-computed-还有-methods-有什么区别？"><a href="#watch-和-computed-还有-methods-有什么区别？" class="headerlink" title="watch 和 computed 还有 methods 有什么区别？"></a>watch 和 computed 还有 methods 有什么区别？</h2><p>methods 只要发生重新渲染他就会执行<br>watch 不支持缓存，只要重新渲染就会执行，支持异步。<br>computed 基于依赖进行缓存 只有它的依赖发生改变时才会重新求值 不支持异步</p>
<h2 id="watch-和-created-哪个先执行"><a href="#watch-和-created-哪个先执行" class="headerlink" title="watch 和 created 哪个先执行"></a>watch 和 created 哪个先执行</h2><p>在 wacth 监控数据时，设置 immediate：true；会优先执行 watch,created 后执行; 反之则反</p>
<h2 id="watch-如何创建时就立即执行"><a href="#watch-如何创建时就立即执行" class="headerlink" title="watch 如何创建时就立即执行"></a>watch 如何创建时就立即执行</h2><p>要使用 handler 和 immediate</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//immediate设为true    监听方法会在创建的时候  执行handler里的方法</span></span><br><span class="line">watch: &#123;</span><br><span class="line">    value:&#123;</span><br><span class="line">      handler:<span class="function"><span class="keyword">function</span>(<span class="params">o,n</span>)</span>&#123;&#125;,</span><br><span class="line">      immediate: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="vue-中-mixins-和-extends-有什么区别？"><a href="#vue-中-mixins-和-extends-有什么区别？" class="headerlink" title="vue 中 mixins 和 extends 有什么区别？"></a>vue 中 mixins 和 extends 有什么区别？</h2><p>其实 mixins 和 extends 都可以理解为继承，mixins 接收对象数组（可理解为多继承），extends 接收的是对象或函数（可理解为单继承）</p>
<p>优先级 Vue.extend&gt;extends&gt;mixins&gt; 组件本身</p>
<h2 id="extends-和-Vue-extend-Vue-component"><a href="#extends-和-Vue-extend-Vue-component" class="headerlink" title="extends 和 Vue.extend,Vue.component"></a>extends 和 Vue.extend,Vue.component</h2><p>Vue.extend 创建组件的构造函数,为了复用。 其主要用来服务于 Vue.component</p>
<p>Vue.component 注册或获取全局组件,为了方便. 实际上当你直接传递选项给Vue.component()的时候，它会在背后调用Vue.extend()。</p>
<p>extends 为了扩展 与 mixins 类似</p>
<p><a href="https://www.jianshu.com/p/42bf342385a4?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">详解 👉</a></p>
<h2 id="vue-如何批量引入组件？"><a href="#vue-如何批量引入组件？" class="headerlink" title="vue 如何批量引入组件？"></a>vue 如何批量引入组件？</h2><ol>
<li>把需要批量引入的组件放在一个文件夹管理 用 require.context 函数(这个函数的目的是递归一个文件夹)，将所有文件都读出来，然后再配合 forEach，将所有组件批量注册即可。</li>
<li>如果是全局批量引入就把 👆 操作放在新建的 xxx.js 文件 然后在 main.js 引入</li>
<li>局部批量引入 第一步就够了</li>
</ol>
<p><a href="https://www.jianshu.com/p/a65076b6f3e7" target="_blank" rel="noopener">详解 👉</a></p>
<h2 id="vue-动态组件使用方法"><a href="#vue-动态组件使用方法" class="headerlink" title="vue 动态组件使用方法"></a>vue 动态组件使用方法</h2><p>引入组件还是用 import 的方式，但是渲染方式是直接使用 component，使用:is 来决定展示哪一个组件(is 的值为组件名称)，<br>但子组件每一次渲染都是全新的，会导致一个现象就是之前用户的操作丢失，为了保证用户的操作的原本性，使用缓存的标签(keep-alive)就可以了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-button @click=&quot;showChild(&apos;A&apos;)&quot;&gt;显示A组件&lt;/el-button&gt;</span><br><span class="line">    &lt;el-button @click=&quot;showChild(&apos;B&apos;)&quot;&gt;显示B组件&lt;/el-button&gt;</span><br><span class="line">    &lt;keep-alive&gt;</span><br><span class="line">      &lt;component :is=&quot;currCom&quot;&gt;&lt;/component&gt;</span><br><span class="line">    &lt;/keep-alive&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;&gt;</span><br><span class="line">import childA from &quot;../childComponent/childA.vue&quot;; //A组件</span><br><span class="line">import childB from &quot;../childComponent/childB.vue&quot;; //B组件</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    childA,</span><br><span class="line">    childB,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      currCom: childA,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    showChild(Str) &#123;</span><br><span class="line">      this.currCom = &quot;child&quot; + Str;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="vue-项目如何引入异步组件？"><a href="#vue-项目如何引入异步组件？" class="headerlink" title="vue 项目如何引入异步组件？"></a>vue 项目如何引入异步组件？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一:</span></span><br><span class="line">    <span class="keyword">const</span> LRC = Vue.component(<span class="string">"lrc"</span>,(resolve)=&gt;<span class="built_in">require</span>([<span class="string">"../components/LRC"</span>],resolve))</span><br><span class="line">    <span class="comment">// 全局组件:在引入组件的script中操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二:</span></span><br><span class="line">      components: &#123;</span><br><span class="line">        <span class="string">'my-component'</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./my-async-component'</span>)</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h2 id="怎么解决-vue-动态设置-img-的-src-不生效的问题？"><a href="#怎么解决-vue-动态设置-img-的-src-不生效的问题？" class="headerlink" title="怎么解决 vue 动态设置 img 的 src 不生效的问题？"></a>怎么解决 vue 动态设置 img 的 src 不生效的问题？</h2><p>因为动态添加 src 被当做静态资源处理了，没有进行编译，所以要加上 require。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"require('@/assets/images/xxx.png')"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="vue-路由的钩子函数"><a href="#vue-路由的钩子函数" class="headerlink" title="vue 路由的钩子函数"></a>vue 路由的钩子函数</h2><h3 id="全局钩子"><a href="#全局钩子" class="headerlink" title="全局钩子"></a>全局钩子</h3><ol>
<li><p>beforeEach 页面加载之前 主要有 3 个参数 to，from，next 判断需要登录的页面进行拦截，做登录跳转(读取 token，如果存在……)</p>
</li>
<li><p>router.afterEach 是页面加载之后</p>
</li>
</ol>
<h3 id="某个路由独享的钩子-beforeEnter"><a href="#某个路由独享的钩子-beforeEnter" class="headerlink" title="某个路由独享的钩子 beforeEnter"></a>某个路由独享的钩子 beforeEnter</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/foo'</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>
<h3 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h3><ol>
<li>beforeRouteEnter (to, from, next) {<br>// 在渲染该组件的对应路由被 confirm 前调用<br>// 不！能！获取组件实例 <code>this</code><br>// 因为当钩子执行前，组件实例还没被创建<br>},</li>
<li>beforeRouteUpdate (to, from, next) {<br>// 在当前路由改变，但是该组件被复用时调用<br>// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，<br>// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。<br>// 可以访问组件实例 <code>this</code><br>},</li>
<li>beforeRouteLeave (to, from, next) {<br>// 导航离开该组件的对应路由时调用<br>// 可以访问组件实例 <code>this</code><br>}</li>
</ol>
<h2 id="vue-实现判断页面是否编辑及编辑页面未保存离开弹窗提示"><a href="#vue-实现判断页面是否编辑及编辑页面未保存离开弹窗提示" class="headerlink" title="vue 实现判断页面是否编辑及编辑页面未保存离开弹窗提示"></a>vue 实现判断页面是否编辑及编辑页面未保存离开弹窗提示</h2><p>用 watch 监听数据，如果数据发生变化，用户点击了其他地方链接要离开页面，则根据 beforeRouteLeave 离开该页面时出发的卫士 弹窗提示，如果 watch 监听数据没发生变化，则不必提示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听代码</span></span><br><span class="line">watch: &#123;</span><br><span class="line">    datas: &#123;</span><br><span class="line">      handler (val) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val) &#123;</span><br><span class="line">          <span class="keyword">this</span>.count++ <span class="comment">//判断数据变化的次数，因为刚加载数据未完全加载的时候，datas是空对象，待加载完之后，则出现一次数据变化，</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      deep: <span class="literal">true</span> <span class="comment">// deep主要是深层次监听，因为数据是层层对象，比较复杂</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断要离开的代码是：</span></span><br><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.count &gt; <span class="number">1</span>) &#123; <span class="comment">// 判断数据是否修改，如果修改按这个执行，没修改，则直接执行离开此页面</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status) &#123;</span><br><span class="line">      next()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 弹窗显示</span></span><br><span class="line">    <span class="keyword">this</span>.$refs.leaveTip.changeLimitDialog(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">this</span>.leave = to</span><br><span class="line">    next(<span class="literal">false</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><p>简介：每一个 Vuex 应用的核心就是仓库(store) 它包含着应用中大部分的状态(state)。<br>场景有：组件之间的状态、音乐播放、登录状态、加入购物车</p>
<h3 id="五个核心"><a href="#五个核心" class="headerlink" title="五个核心"></a>五个核心</h3><ol>
<li><p>store 存放只用于读取数据 -通过 this.\$store.state 读数据</p>
</li>
<li><p>getters 就像计算属性一样 用来过滤和计算数据 (它接受 state 作为第一个参数) -通过 this.\$store.getters 读数据</p>
</li>
<li><p>mutations 同步操作 更改 Vuex 的 store 中的状态的唯一方法 必须是同步函数 通过 store.commit 方法触发<br>👇 以下写法都可以</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment(state) &#123;</span><br><span class="line">      state.count++;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发</span></span><br><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">"increment"</span>);</span><br><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">"increment"</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">"increment"</span>, &#123;</span><br><span class="line">  age: <span class="number">10</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">this</span>.$store.commit(&#123;</span><br><span class="line">  type: <span class="string">"increment"</span>,</span><br><span class="line">  age: <span class="number">10</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>mutations 规则：👇<br>最好提前在 store 中初始化所需属性。<br>当需要在对象上添加新属性时，应该使用 Vue.set(obj, ‘newProp’, 123), 或者以新对象替换老对象如利用对象展开运算符 state.obj = { …state.obj, newProp: 123 }</p>
<ol start="4">
<li><p>action 异步操作 提交的是 mutation，而不是直接变更状态。可以包含任意异步操作。 通过 store.dispatch 方法触发</p>
</li>
<li><p>Module 将 store 分割成模块（module）</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    actionA (&#123; commit &#125;) &#123; <span class="comment">// dispatch可以处理函数返回的Promise，且dispatch仍旧返回Promise</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          commit(<span class="string">'someMutation'</span>)</span><br><span class="line">          resolve()</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">      <span class="keyword">return</span> dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">'someOtherMutation'</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 假设actionA和actionB返回的都是Promise</span></span><br><span class="line">    actions: &#123;</span><br><span class="line">      <span class="keyword">async</span> actionA (&#123; commit &#125;) &#123;</span><br><span class="line">        commit(<span class="string">'gotData'</span>, <span class="keyword">await</span> getData())</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">async</span> actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">        <span class="keyword">await</span> dispatch(<span class="string">'actionA'</span>)</span><br><span class="line">        commit(<span class="string">'gotOtherData'</span>, <span class="keyword">await</span> getOtherData())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">'increment'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Vuex-和单纯的全局对象有以下两点不同："><a href="#Vuex-和单纯的全局对象有以下两点不同：" class="headerlink" title="Vuex 和单纯的全局对象有以下两点不同："></a>Vuex 和单纯的全局对象有以下两点不同：</h3><ol>
<li><p>Vuex 的状态存储是响应式的。 当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p>
</li>
<li><p>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交(commit) mutation。</p>
</li>
</ol>
<h3 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h3><p>在 computed 通过 👇store.state(getters)来获取 state(getters)中的状态：<br>this.$store.state.xxx来获取vuex中的state<br>this.$store.getters.xxx (getter 这种通过属性访问时是可以缓存的)<br>this.\$store.getters.xxx(10) (当 getter 返回一个函数 通过方法访问时，每次都会调用不会缓存结果)</p>
<p>mutations 同步操作操作通过 commit 方法触发<br>action 异步操作通过 dispatch 方法触发</p>
<h3 id="为什么不在-data-中取-vuex-值？"><a href="#为什么不在-data-中取-vuex-值？" class="headerlink" title="为什么不在 data 中取 vuex 值？"></a>为什么不在 data 中取 vuex 值？</h3><p>因为 data 中的内容只会在 created 钩子触发前初始化一次， 而 Vuex 的状态存储是响应式的 则之后 vuex 状态的变化影响不到初始值<br>而 computed 则是通过【依赖追踪】在它的相关依赖发生改变时会重新求值</p>
<h3 id="辅助函数-mapState-mapGetters-mapMutations-mapActions"><a href="#辅助函数-mapState-mapGetters-mapMutations-mapActions" class="headerlink" title="辅助函数 mapState mapGetters mapMutations mapActions"></a>辅助函数 mapState mapGetters mapMutations mapActions</h3><ul>
<li>当一个组件需要获取多个状态的时候，我们可以使用辅助函数帮助我们生成计算属性 让代码更加简洁</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState,mapGetters,mapMutations,mapActions    &#125; <span class="keyword">from</span> <span class="string">"vuex"</span>; <span class="comment">//先引入</span></span><br><span class="line">computed: &#123;</span><br><span class="line">    <span class="comment">// 两种写法</span></span><br><span class="line">    ...mapState([<span class="string">"1xx"</span>, <span class="string">"2xx"</span>]),</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      <span class="number">1</span>xx名字不一样: <span class="string">'xx1'</span>,</span><br><span class="line">      <span class="number">2</span>xx个名字不一样: <span class="string">'xx2'</span>,,</span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也是两种写法</span></span><br><span class="line">    ...mapGetters([<span class="string">"1xx"</span>, <span class="string">"2xx"</span>])</span><br><span class="line">    ...mapGetters(&#123;</span><br><span class="line">      <span class="number">1</span>xx名字不一样: <span class="string">'xx1'</span>,</span><br><span class="line">      <span class="number">2</span>xx个名字不一样: <span class="string">'xx2'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapMutations([</span><br><span class="line">    <span class="string">'increment'</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.commit('increment')`</span></span><br><span class="line">  ]),</span><br><span class="line">  ...mapMutations(&#123;</span><br><span class="line">    add: <span class="string">'increment'</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.commit('increment')`</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions([</span><br><span class="line">    <span class="string">'increment'</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.commit('increment')`</span></span><br><span class="line">  ]),</span><br><span class="line">  ...mapActions(&#123;</span><br><span class="line">    add: <span class="string">'increment'</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.commit('increment')`</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>列如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-----store</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  userData: &#123;</span><br><span class="line">    xxx: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------matution</span></span><br><span class="line">setValue(state,xxx)&#123;</span><br><span class="line">    state.userData.xxx= xxx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----组件内存值</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  fn() &#123;</span><br><span class="line">        <span class="keyword">this</span>.$store.commit(<span class="string">'xxx'</span>, <span class="number">10</span>)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dispatch 异步操作 this.$store.dispatch('actions的方法'，arg)</span></span><br><span class="line"><span class="comment">// commit 同步操作 this.$store.commit('mutations的方法'，arg)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//组件内取值</span></span><br><span class="line"> computed: &#123;</span><br><span class="line">    value() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.userData.xxx;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Vue-observable-你有了解过吗"><a href="#Vue-observable-你有了解过吗" class="headerlink" title="Vue.observable 你有了解过吗"></a>Vue.observable 你有了解过吗</h2><p>vue2.6 发布一个新的 API 类轻量级 vuex，可以处理一些简单的跨组件共享数据状态的问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//store.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> store = Vue.observable(&#123; <span class="attr">count</span>: <span class="number">0</span>, <span class="attr">name</span>: <span class="string">"张三"</span> &#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> mutations = &#123;</span><br><span class="line">  setCount(count) &#123;</span><br><span class="line">    store.count = count;</span><br><span class="line">  &#125;,</span><br><span class="line">  setName(name) &#123;</span><br><span class="line">    store.name = name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="vue-cli-如何新增自定义指令？"><a href="#vue-cli-如何新增自定义指令？" class="headerlink" title="vue-cli 如何新增自定义指令？"></a>vue-cli 如何新增自定义指令？</h2><p>场景 <a href="https://blog.51cto.com/u_15302032/3068128" target="_blank" rel="noopener">https://blog.51cto.com/u_15302032/3068128</a></p>
<p>directives()</p>
<p>Vue.directive(id, definition)<br>传入的两个参数，id 是指指令 ID，definition 是指定义对象。其中，定义对象可以提供一些钩子函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">"my-directive"</span>, &#123;</span><br><span class="line">  <span class="comment">// 一个指令定义对象可以提供如下几个钩子函数</span></span><br><span class="line">  bind: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置</span></span><br><span class="line">  &#125;,</span><br><span class="line">  inserted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//按钮权限一般用这个钩子 https://www.jianshu.com/p/6a072b906cef</span></span><br><span class="line">    <span class="comment">//被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</span></span><br><span class="line">  &#125;,</span><br><span class="line">  update: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//根据获得的新值执行对应的更新</span></span><br><span class="line">    <span class="comment">//对于初始值也会调用一次</span></span><br><span class="line">  &#125;,</span><br><span class="line">  componentUpdated: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//指令所在组件的 VNode 及其子 VNode 全部更新后调用。</span></span><br><span class="line">  &#125;,</span><br><span class="line">  unbind: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 只调用一次，指令与元素解绑时调用。 做清理操作</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>场景-输入框自动聚焦</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册一个全局自定义指令 `v-focus`</span></span><br><span class="line">Vue.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line">  <span class="comment">// 当被绑定的元素插入到 DOM 中时</span></span><br><span class="line">  inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 聚焦元素</span></span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;input v-focus&gt;</span><br></pre></td></tr></table></figure>
<p>场景-相对时间转换 类似微博、朋友圈发布动态后的相对时间，比如刚刚、两分钟前等等</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-relativeTime=<span class="string">"time"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    time: <span class="number">1565753400000</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Vue.directive(<span class="string">"relativeTime"</span>, &#123;</span><br><span class="line">  bind(el, binding) &#123;</span><br><span class="line">    <span class="comment">// Time.getFormatTime() 方法，自行补充</span></span><br><span class="line">    el.innerHTML = Time.getFormatTime(binding.value);</span><br><span class="line">    el.__timeout__ = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      el.innerHTML = Time.getFormatTime(binding.value);</span><br><span class="line">    &#125;, <span class="number">6000</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  unbind(el) &#123;</span><br><span class="line">    clearInterval(el.innerHTML);</span><br><span class="line">    <span class="keyword">delete</span> el.__timeout__;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="vue-几种常用的指令"><a href="#vue-几种常用的指令" class="headerlink" title="vue 几种常用的指令"></a>vue 几种常用的指令</h3><p>答：v-for 、 v-if 、v-bind、v-on、v-show、v-else</p>
<h2 id="监听多个事件"><a href="#监听多个事件" class="headerlink" title="监听多个事件"></a>监听多个事件</h2><p>使用 v-on 指令绑定多个事件 –第四种方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--1.  普通绑定方法 --&gt;</span><br><span class="line">&lt;button v-on:click=&quot;onClick&quot;&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--2.  内联语句，传参 --&gt;</span><br><span class="line">&lt;button v-on:click=&quot;onClick(&apos;hello&apos;, $event)&quot;&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 3.  缩写 --&gt;</span><br><span class="line">&lt;button @click=&quot;onClick&quot;&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--4.  对象语法 (2.4.0+) --&gt;</span><br><span class="line">&lt;button v-on=&quot;&#123; click: onClick, focus: onFocus, blur: onBlur &#125;&quot;&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<h2 id="v-if-和-v-show-哪个优先级更高？"><a href="#v-if-和-v-show-哪个优先级更高？" class="headerlink" title="v-if 和 v-show 哪个优先级更高？"></a>v-if 和 v-show 哪个优先级更高？</h2><p>v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。<br>v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。<br>相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。<br>注意，v-show 不支持 &lt; template &gt; 元素，也不支持 v-else。</p>
<p>一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p>
<h2 id="v-show-指令算是重排吗？"><a href="#v-show-指令算是重排吗？" class="headerlink" title="v-show 指令算是重排吗？"></a>v-show 指令算是重排吗？</h2><p>页面渲染时，当页面中元素的位置，大小或结构、定位发生改变，或者对 HTML 结构增删查改时，浏览器会对所有的 dom 进行重新排序，这就是 DOM 回流，严重影响浏览器性能。</p>
<p>因 v-show 指令改变 display 的属性，会发生重排。</p>
<h2 id="v-if-和-v-for-的优先级是什么？"><a href="#v-if-和-v-for-的优先级是什么？" class="headerlink" title="v-if 和 v-for 的优先级是什么？"></a>v-if 和 v-for 的优先级是什么？</h2><p>如果这两个同时出现时，那应该怎么优化才能得到更好的性能？</p>
<p>答： v-for 的优先级更高<br>这意味着 v-if 将分别重复运行于每个 v-for 循环中，所以不推荐同时使用 v-if 和 v-for</p>
<p>避免出现这种情况，如果实在需要，则在外嵌套 template，在这一层进行 v-if 判断，然后在内部进行 v-for 循环</p>
<h2 id="v-for-如何倒序输出"><a href="#v-for-如何倒序输出" class="headerlink" title="v-for 如何倒序输出"></a>v-for 如何倒序输出</h2><ol>
<li>先把数组做一层 reverse()倒叙处理，然后在执行 v-for ❀</li>
<li>据说我没测 css 的 flex 容器的 order 也是种骚方法</li>
</ol>
<p>温习：<br>push() 数组末尾添加<br>pop() 数组末尾取出<br>shift() 数组开头取出<br>unshift() 数组开头添加<br>splice() 删除并插入<br>sort() 排序<br>reverse() 数组顺序颠倒</p>
<h2 id="vue-如何自定义一个过滤器？"><a href="#vue-如何自定义一个过滤器？" class="headerlink" title="vue 如何自定义一个过滤器？"></a>vue 如何自定义一个过滤器？</h2><ul>
<li>Vue2.0 不再支持这种写法<br>像金钱格式\$7000.00, 时间格式 ,小数点<br>filters: {} 里面定义函数 filtersName</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  &#123;&#123;msg| filtersName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>目前能用的是</li>
</ul>
<ol>
<li>全局方法（推介）</li>
<li>computed 属性</li>
<li>\$options.filters（推介）</li>
</ol>
<p><a href="https://blog.csdn.net/qq_34971175/article/details/79719058" target="_blank" rel="noopener">详解 👉</a></p>
<h2 id="vue-怎么实现强制刷新组件？"><a href="#vue-怎么实现强制刷新组件？" class="headerlink" title="vue 怎么实现强制刷新组件？"></a>vue 怎么实现强制刷新组件？</h2><p>强制重新渲染</p>
<ol>
<li>this.\$forceUpdate()</li>
<li>v-if<br>强制重新刷新某组件</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模版上绑定key</span></span><br><span class="line">&lt;SomeComponent :key=<span class="string">"theKey"</span>/&gt;</span><br><span class="line"><span class="comment">//选项里绑定data</span></span><br><span class="line">data()&#123;</span><br><span class="line">  <span class="keyword">return</span>&#123;</span><br><span class="line">      theKey:<span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//刷新key达到刷新组件的目的</span></span><br><span class="line">theKey++;</span><br></pre></td></tr></table></figure>
<h2 id="跟-keep-alive-有关的生命周期是哪些？描述下这些生命周期"><a href="#跟-keep-alive-有关的生命周期是哪些？描述下这些生命周期" class="headerlink" title="跟 keep-alive 有关的生命周期是哪些？描述下这些生命周期"></a>跟 keep-alive 有关的生命周期是哪些？描述下这些生命周期</h2><ul>
<li><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。</p>
<p>keep-alive 的生命周期</p>
<ol>
<li>activated： 页面第一次进入的时候，钩子触发的顺序是 created-&gt;mounted-&gt;activated</li>
<li>deactivated: 页面退出的时候会触发 deactivated，当再次前进或者后退的时候只触发 activated</li>
</ol>
</li>
</ul>
<h2 id="如何在-keep-alive-缓存界面实时获取后台数据"><a href="#如何在-keep-alive-缓存界面实时获取后台数据" class="headerlink" title="如何在 keep-alive 缓存界面实时获取后台数据"></a>如何在 keep-alive 缓存界面实时获取后台数据</h2><p>实时获取数据用 websoket 或者轮询<br>由于用到了 keepalive, 所以页面在再次加载时不会触发 created 而是触发 activated 所以接收数据，重置数据要用 Vue.set()方法写到 activated 方法下</p>
<h2 id="你知道-vue-中-key-的原理吗？说说你对它的理解"><a href="#你知道-vue-中-key-的原理吗？说说你对它的理解" class="headerlink" title="你知道 vue 中 key 的原理吗？说说你对它的理解"></a>你知道 vue 中 key 的原理吗？说说你对它的理解</h2><ul>
<li>vue 中 key 值的作用？ 给元素标记的唯一性 作用主要是为了高效的更新虚拟 DOM。</li>
</ul>
<p>需要使用 key 来给每个节点做一个唯一标识，Diff 算法就可以正确的识别此节点，找到正确的位置区插入新的节点。<br>作用：便于 diff 算法的更新，key 的唯一性，能让算法更快的找到需要更新的 dom（高效的更新虚拟 DOM）</p>
<h2 id="vue-业务代码阐述"><a href="#vue-业务代码阐述" class="headerlink" title="vue 业务代码阐述"></a>vue 业务代码阐述</h2><ul>
<li><p>style 标签中写入 scoped 即可只在当前组件起作用</p>
</li>
<li><p>列举样式穿透符 1. /deep/ 2. &gt;&gt;&gt; 3. ::v-deep</p>
</li>
</ul>
<h2 id="vue-等单页面应用及其优缺点"><a href="#vue-等单页面应用及其优缺点" class="headerlink" title="vue 等单页面应用及其优缺点"></a>vue 等单页面应用及其优缺点</h2><p>答：优点：Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件，核心是一个响应的数据绑定系统。MVVM、数据驱动、组件化、轻量、简洁、高效、快速、模块友好。<br>缺点：不支持低版本的浏览器，最低只支持到 IE9；不利于 SEO 的优化（如果要支持 SEO，建议通过服务端来进行渲染组件）；第一次加载首页耗时相对长一些；不可以使用浏览器的导航按钮需要自行实现前进、后退。</p>
<h2 id="使用-vue-后怎么针对搜索引擎做-SEO-优化？"><a href="#使用-vue-后怎么针对搜索引擎做-SEO-优化？" class="headerlink" title="使用 vue 后怎么针对搜索引擎做 SEO 优化？"></a>使用 vue 后怎么针对搜索引擎做 SEO 优化？</h2><p>ssr,即单页面后台渲染</p>
<p>vue-meta-info 与 prerender-spa-plugin 预渲染</p>
<p>nuxt 服务器配置 node 环境。</p>
<p>phantomjs 针对爬虫做处理</p>
<h2 id="解决-vue-首次白屏"><a href="#解决-vue-首次白屏" class="headerlink" title="解决 vue 首次白屏"></a>解决 vue 首次白屏</h2><p>路由懒加载 使用 CDN 使用首页广告</p>
<h2 id="优化性能"><a href="#优化性能" class="headerlink" title="优化性能"></a>优化性能</h2><p>分页 图片跟路由懒加载 精灵图 打包压缩</p>
<h3 id="懒加载怎么做"><a href="#懒加载怎么做" class="headerlink" title="懒加载怎么做"></a>懒加载怎么做</h3><p>以往 compont 的引入方式就是（../../啥的）<br>现在要改成 resolve =&gt; require([‘../components/PromiseDemo’], resolve)</p>
<h2 id="ajax、fetch、axios-这三都有什么区别？"><a href="#ajax、fetch、axios-这三都有什么区别？" class="headerlink" title="ajax、fetch、axios 这三都有什么区别？"></a>ajax、fetch、axios 这三都有什么区别？</h2><ul>
<li><p>ajax 是最早出现发送后端请求的技术，属于原生 js 范畴,核心是使用 XMLHttpRequest 对象,使用较多并有先后顺序的话，容易产生回调地狱。</p>
</li>
<li><p>fetch 号称可以代替 ajax 的技术，是基于 es6 中的 Promise 对象设计的，参数和 jQuery 中的 ajax 类似，它并不是对 ajax 进一步封装，它属于原生 js 范畴。没有使用 XMLHttpRequest 对象。</p>
</li>
<li><p>axios 不是原生 js,使用时需要对其进行安装，客户端和服务器端都可以使用，可以在请求和相应阶段进行拦截，基于 promise 对象。</p>
</li>
</ul>
<h2 id="如何在全局使用-axios-的实例呢"><a href="#如何在全局使用-axios-的实例呢" class="headerlink" title="如何在全局使用 axios 的实例呢"></a>如何在全局使用 axios 的实例呢</h2><p>在 main.js 文件下导入 axiso，并挂载到 vue 实例上<br>import axios from ‘axios’;<br>Vue.prototype.\$axios = axios;</p>
<h2 id="axios-同时请求多个接口，如果当-token-过期时，怎么取消后面的请求？"><a href="#axios-同时请求多个接口，如果当-token-过期时，怎么取消后面的请求？" class="headerlink" title="axios 同时请求多个接口，如果当 token 过期时，怎么取消后面的请求？"></a>axios 同时请求多个接口，如果当 token 过期时，怎么取消后面的请求？</h2><p>axios 的话可以使用 cancelToken 来实现。如果是原生的 XMLhttprequest 的话，需要使用 abort()方法实现。</p>
<p><a href="https://juejin.im/post/5d664634f265da03d42fb6dc" target="_blank" rel="noopener">详情 👉</a></p>
<h2 id="vue-为什么要求组件模板只能有一个根元素"><a href="#vue-为什么要求组件模板只能有一个根元素" class="headerlink" title="vue 为什么要求组件模板只能有一个根元素"></a>vue 为什么要求组件模板只能有一个根元素</h2><p>答：我们只有指定了唯一的 el 根元素，才能交给 Vue 实例在内部通过 createElement(创建元素节点)方法生成一个对应的虚拟 DOM 结构映射真实的 DOM 元素进行操作渲染成真正的 HTML</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/28/1708a05c3331acfd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="引入一张图看一下虚拟 DOM 的渲染过程 "></p>
<p>换句话来说，可以把 el 对应的元素理解成 Vue 接管部分中的一个顶级标签，就像基本的 HTML 结构中，顶级标签是 <html></html>，只能有一个这样的标签存在。对应到 Vue 中也是这样，如果你给它两个顶级标签，那么对应的 DOM 结构就无法生成了，这也就解释了之前的疑惑：为什么不能指定多个入口让 Vue 实例一个个的试。</p>
<h2 id="虚拟-dom"><a href="#虚拟-dom" class="headerlink" title="虚拟 dom"></a>虚拟 dom</h2><p>虚拟 DOM 是对 DOM 的抽象，本质上是 JavaScript 对象</p>
<p>虚拟 DOM 最初的目的，就是更好的跨平台，比如 Node.js 就没有 DOM,如果想实现 SSR(服务端渲染),那么一个方式就是借助虚拟 DOM,因为虚拟 DOMDOM 本身是 JavaScript 对象.<br>前端频繁操作 DOM 导致的重排重绘是最影响前端性能的 而生成虚拟 DOM 可以与旧的 DOM 通过 diff 算法对比找出更新的节点再更新到视图</p>
<h2 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h2><p>Vue 数据渲染中最核心的的部分就是 diff 算法的应用 (vue 虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较更新时，就用到了该算法)</p>
<ol>
<li><p>vdom 为何用 diff 算法</p>
<blockquote>
<p>DOM 操作是昂贵的，因此尽量减少 DOM 操作<br>找出本次 DOM 必须更新的节点来更新，其他的不更新<br>这个’找出’的过程，就需要 diff 算法</p>
</blockquote>
</li>
<li><p>diff 算法有两个比较显著的特点：</p>
<blockquote>
<p>比较只会在同层级进行, 不会跨层级比较。<br>在 diff 比较的过程中，循环从两边向中间收拢</p>
</blockquote>
</li>
</ol>
<p>这也是为什么循环列表中要用 key 标记元素的唯一性 diff 比较的过程中方便比对<br><a href="https://segmentfault.com/a/1190000021896771" target="_blank" rel="noopener">详细解说</a></p>
<h2 id="vue-文件中-style-是必须的吗？那-script-是必须的吗"><a href="#vue-文件中-style-是必须的吗？那-script-是必须的吗" class="headerlink" title=".vue 文件中 style 是必须的吗？那 script 是必须的吗"></a>.vue 文件中 style 是必须的吗？那 script 是必须的吗</h2><p>都不是必须的，如果是普通组件那么只能是一个静态 html，如果是函数式组件， 那么可以直接使用 props 等函数式组件属性。</p>
<h2 id="vue-渲染模板时怎么保留模板中的-HTML-注释呢？"><a href="#vue-渲染模板时怎么保留模板中的-HTML-注释呢？" class="headerlink" title="vue 渲染模板时怎么保留模板中的 HTML 注释呢？"></a>vue 渲染模板时怎么保留模板中的 HTML 注释呢？</h2><p>设置 comments 属性，官网默认为舍弃注释</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">comments</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="vue-项目本地开发完成后部署到服务器后报-404-或许是什么原因呢？"><a href="#vue-项目本地开发完成后部署到服务器后报-404-或许是什么原因呢？" class="headerlink" title="vue 项目本地开发完成后部署到服务器后报 404 或许是什么原因呢？"></a>vue 项目本地开发完成后部署到服务器后报 404 或许是什么原因呢？</h2><ol>
<li>检查 nginx 配置，是否正确设置了资源映射条件；</li>
<li>检查 vue.config.js 中是否配置了 publicPath，若有则检查是否和项目资源文件在服务器摆放位置一致。</li>
<li>使用了 history 模式，而后端又没有进行相关资源配置。</li>
</ol>
<h2 id="预渲染和-SSR-服务端渲染-有什么区别"><a href="#预渲染和-SSR-服务端渲染-有什么区别" class="headerlink" title="预渲染和 SSR(服务端渲染)有什么区别"></a>预渲染和 SSR(服务端渲染)有什么区别</h2><p>服务端渲染和预渲染的使用场景还是有较明显的区别的。<br>预渲染的使用场景更多是我们所说的静态页面的形式。<br>服务端渲染适用于大型的、页面数据处理较多且较为复杂的、与服务端有数据交互的功能型网站，一个明显的使用场景就是电商网站。</p>
<h2 id="你有用过预渲染技术吗？怎么做的？"><a href="#你有用过预渲染技术吗？怎么做的？" class="headerlink" title="你有用过预渲染技术吗？怎么做的？"></a>你有用过预渲染技术吗？怎么做的？</h2><p>预渲染的核心是使用 prerender-spa-plugin<br>new PrerenderSPAPlugin({<br>staticDir: path.join(__dirname, ‘dist’),<br>routes: [ ‘/‘, ‘/home’, ‘/infomation’, ‘/ticket’, ‘/scenery’, ‘/about’ ],<br>renderer: new Renderer({<br>headless: false,<br>renderAfterDocumentEvent: ‘render-event’<br>})<br>}),<br>项目所有的路由，最终生成后有几个页面，都是以这个配置为依据，而不是你在 vue-router 中配置的路由。</p>
<h2 id="说说你对-vue-的错误处理的了解？"><a href="#说说你对-vue-的错误处理的了解？" class="headerlink" title="说说你对 vue 的错误处理的了解？"></a>说说你对 vue 的错误处理的了解？</h2><p>分为 errorCaptured 与 errorHandler。<br>errorCaptured 是组件内部钩子，可捕捉本组件与子孙组件抛出的错误，接收 error、vm、info 三个参数，return false 后可以阻止错误继续向上抛出。<br>errorHandler 为全局钩子，使用 Vue.config.errorHandler 配置，接收参数与 errorCaptured 一致，2.6 后可捕捉 v-on 与 promise 链的错误，可用于统一错误处理与错误兜底。<br><a href="https://blog.fundebug.com/2019/06/17/handling-errors-in-vuejs/" target="_blank" rel="noopener">https://blog.fundebug.com/2019/06/17/handling-errors-in-vuejs/</a></p>
<h2 id="vue-版本以及御其他框架差异"><a href="#vue-版本以及御其他框架差异" class="headerlink" title="vue 版本以及御其他框架差异"></a>vue 版本以及御其他框架差异</h2><h3 id="你知道-vue2-0-兼容-IE-哪个版本以上吗？"><a href="#你知道-vue2-0-兼容-IE-哪个版本以上吗？" class="headerlink" title="你知道 vue2.0 兼容 IE 哪个版本以上吗？"></a>你知道 vue2.0 兼容 IE 哪个版本以上吗？</h3><p>不兼容 ie8 及以下，是因为 vue 的响应式原理是基于 es5 的 Object.defineProperty 的,而这个方法不支持 ie8 及以下。<br>部分兼容 ie9 ，完全兼容 10 以上</p>
<h3 id="你是从-vue-哪个版本开始用的？你知道-1-x-和-2-x-有什么区别吗？"><a href="#你是从-vue-哪个版本开始用的？你知道-1-x-和-2-x-有什么区别吗？" class="headerlink" title="你是从 vue 哪个版本开始用的？你知道 1.x 和 2.x 有什么区别吗？"></a>你是从 vue 哪个版本开始用的？你知道 1.x 和 2.x 有什么区别吗？</h3><p>2016 年发布的 vue2.0 版本，区别：<br>1、 2.0 生命生命周期变化感觉变得更加语义化一点（有规律可寻，更好记了），而且增加了 beforeUpdate、updated、activated、deactivated，删除了 attached、detached。<br>2、2.0 将 1.0 所有自带的过滤器都删除了，也就是说，在 2.0 中，要使用过滤器，则需要我们自己编写<br>3、vue1.0 的数据绑定完全依赖于数据侦测，使用 Object.defineProperty 方法使数据去通知相应 watch，改变 dom 结构。vue2.0 引入了虚拟 dom，只通知到组件，提升了颗粒度。</p>
<h3 id="vue2-和-vue3-的区别"><a href="#vue2-和-vue3-的区别" class="headerlink" title="vue2 和 vue3 的区别"></a>vue2 和 vue3 的区别</h3><ol>
<li>重构响应式系统，使用 Proxy 替换 Object.defineProperty</li>
<li>新增 Composition API，更好的逻辑复用和代码组织</li>
<li>重构 Virtual DOM</li>
</ol>
<p><a href="https://www.it610.com/article/1292706945920212992.htm" target="_blank" rel="noopener">跳转答案详解</a></p>
<h3 id="vue3-0-特性"><a href="#vue3-0-特性" class="headerlink" title="vue3.0 特性"></a>vue3.0 特性</h3><p>支持 TypeScript<br>兼容 IE11<br>双向数据绑定原理：<br>Vue2.x：其双向数据绑定原理是通过 es5 的 Object.defineProperty，中的 set 方法来实现数据劫持的，但是有一个弊端就是无法兼听到数组内部的数据变化(当然我们可以通过 arr = arr.concat([]))，来实现内部数据变化的检测。相比 Vue3 有一定的性能问题。<br>Vue3.x：是用 ES6 的语法 Proxy（Proxy 怎么用大家可自行百度，网上教程大把，我就不在这赘述了）对象来实现的，这个玩意儿也可以实现数据的劫持，相比 Object.defineProperty 的优势是：可以检测到数组内部数据的变化<br>（IE 系列都不兼容 Proxy，所以可能还是用 Object.defineProperty）</p>
<h3 id="vue-与-React-的区别"><a href="#vue-与-React-的区别" class="headerlink" title="vue 与 React 的区别?"></a>vue 与 React 的区别?</h3><p>两者本质的区别：模板和组件化的区别<br>Vue 本质是 MVVM 框架，由 MVC 发展而来；<br>React 是前端组件化框架，由后端组件化发展而来；<br>Vue 使用模板<br>React 使用 JSX<br>React 本身就是组件化<br>Vue 是在 MVVM 上扩展的<br>共同点：<br>都支持组件化，都是数据驱动视图</p>
<h3 id="21-说说-vue-的优缺点"><a href="#21-说说-vue-的优缺点" class="headerlink" title="21.说说 vue 的优缺点"></a>21.说说 vue 的优缺点</h3><p>优点：</p>
<ol>
<li>数据驱动</li>
<li>模块化</li>
<li>轻量级</li>
<li>SPA</li>
<li>版本 3.0 的界面化管理工具比较好使</li>
<li>vue 易入门</li>
<li>中文社区强大，入门简单，提升也有很多的参考资料。</li>
</ol>
<p>缺点： 8. 吃内存（每个组件都会实例化一个 Vue 实例，实例的属性和方法很多） 9. 定义在 data 里面的对象，实例化时，都会递归的遍历转成响应式数据，然而有的响应式数据我们并不会用到，造成性能上的浪费 10. 像 keep-alive transition transition-group 这些内置组件，不管用不用其实都已经挂到 Vue.options.components 上，如果不用，造成对象变大，从而占用内存 11. 父子组件更新，没有明确的来源 12. 不支持 IE8 及以下浏览器</p>
<h2 id="为什么我们写组件的时候可以写在-vue-里呢？可以是别的文件名后缀吗？"><a href="#为什么我们写组件的时候可以写在-vue-里呢？可以是别的文件名后缀吗？" class="headerlink" title="为什么我们写组件的时候可以写在.vue 里呢？可以是别的文件名后缀吗？"></a>为什么我们写组件的时候可以写在.vue 里呢？可以是别的文件名后缀吗？</h2><p>以什么后缀跟 VUE 没有任何关系，vue 只是个特殊的 text 文件而已，就算你用 .abc 都行。<br>这一切都该归功于 webpack，在 webpack 的 loaders 配置中，能让你给指定文件一个，或多个加载器。你也可以把这些加载器理解为预编译工具。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.vue$/</span>, <span class="comment">// 这里指定 .vue 文件通过 vue-loader 解析，你可以指定任何类型的文件。</span></span><br><span class="line">      loader: <span class="string">"vue-loader"</span>,</span><br><span class="line">      options: vueLoaderConfig,</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="你有看过-vue-推荐的风格指南吗？列举几条"><a href="#你有看过-vue-推荐的风格指南吗？列举几条" class="headerlink" title="你有看过 vue 推荐的风格指南吗？列举几条"></a>你有看过 vue 推荐的风格指南吗？列举几条</h2><ol>
<li>使用 v-for 时记得加 key，可以快速定位到需要更新的 DOM 节点，提高效率。</li>
<li>永远不要把 v-if 和 v-for 同时用在同一个元素上。提高渲染效率</li>
<li>为组件样式设置 scoped 作用域</li>
<li>优先通过 Vuex 管理全局状态，而不是通过 this.\$root 或一个全局事件总线</li>
</ol>
<p><a href="https://cn.vuejs.org/v2/style-guide/index.html" target="_blank" rel="noopener">官方风格指南:👉</a></p>
<h2 id="实现一个双向绑定的微型框架"><a href="#实现一个双向绑定的微型框架" class="headerlink" title="实现一个双向绑定的微型框架"></a>实现一个双向绑定的微型框架</h2><p>方案： 利用 ES6 中的 Proxy(代理)和 Reflect 实现简单的双向数据绑定<br>vue3 也把 obj.defineProperty() 换成了 Proxy+Reflect。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>proxy<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>使用Proxy 和 Reflect 实现双向数据绑定<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"input"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您输入的内容是： <span class="tag">&lt;<span class="name">i</span> <span class="attr">id</span>=<span class="string">"txt"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;&gt;</span></span><br><span class="line">      //获取dom元素</span><br><span class="line">      let oInput = document.getElementById("input");</span><br><span class="line">      let oTxt = document.getElementById("txt");</span><br><span class="line"></span><br><span class="line">      //初始化代理对象</span><br><span class="line">      let obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">      //给obj增加代理对象</span><br><span class="line">      let newProxy = new Proxy(obj, &#123;</span><br><span class="line">        get: (target, key, recevier) =&gt; &#123;</span><br><span class="line">          //console.log("get:"+ key)</span><br><span class="line">          return Reflect.get(target, key, recevier);</span><br><span class="line">        &#125;,</span><br><span class="line">        set: (target, key, value, recevier) =&gt; &#123;</span><br><span class="line">          //监听newProxy是否有新的变化</span><br><span class="line">          if (key == "text") &#123;</span><br><span class="line">            oTxt.innerHTML = value;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          //将变化反射回原有对象</span><br><span class="line">          return Reflect.set(target, key, value, recevier);</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      //监听input输入事件</span><br><span class="line">      oInput.addEventListener("keyup", (e) =&gt; &#123;</span><br><span class="line">        //修改代理对象的值</span><br><span class="line">        newProxy.text = e.target.value;</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>监听 input 的时候修改 newProxy 的值，检测到 newProxy 重新设置了值得时候，因为 newProxy 代理了 obj 这个对象， 所以可以调用 Reflcet 反射到原 obj.<br>所以修改了 Input 的值后，然后控制台输入 obj,会打印出 input 的值。</p>
<h1 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h1><p>#小程序 优化总结<br><a href="https://blog.csdn.net/weixin_29603489/article/details/112036759" target="_blank" rel="noopener">https://blog.csdn.net/weixin_29603489/article/details/112036759</a></p>
<h2 id="小程序自定义头部怎样设置"><a href="#小程序自定义头部怎样设置" class="headerlink" title="小程序自定义头部怎样设置"></a>小程序自定义头部怎样设置</h2><ol>
<li><p>在 app.json 里面把 “navigationStyle” 设置为 “custom”</p>
</li>
<li><p>计算相关值<br>因为在不同的手机型号头部那条栏目高度可能不一致，所以为了我们适配更多型号，我们需要计算 3 个值：</p>
</li>
</ol>
<p>1.整个导航栏高度 = statausBarHeight + height + (top-statausBarHeight )*2； 2.胶囊按钮与顶部的距离 = top； 3.胶囊按钮与右侧的距离 = windowWidth - right。</p>
<ol start="3">
<li>因为这个头部导航是公共的，所以我们最好把它设置成一个组件，命名为 navbar<br>在 index.json 中引用该组件 在 index.wxml 中使用该组件</li>
</ol>
<p>如下：<br><a href="https://www.cnblogs.com/sese/p/9761713.html" target="_blank" rel="noopener">https://www.cnblogs.com/sese/p/9761713.html</a></p>
<h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><p>wxml wxss js json</p>
<h2 id="小程序与-vue-双向绑定哪里不一样"><a href="#小程序与-vue-双向绑定哪里不一样" class="headerlink" title="小程序与 vue 双向绑定哪里不一样"></a>小程序与 vue 双向绑定哪里不一样</h2><p>vue 通过 this.data 同步数据<br>小程序必须调用 this.setData({})</p>
<h2 id="小程序传递数据的方法"><a href="#小程序传递数据的方法" class="headerlink" title="小程序传递数据的方法"></a>小程序传递数据的方法</h2><ol>
<li><p>全局变量 在 app.js 文件中定义全局变量 globalData 获取通过 getApp()拿到存的全局变量</p>
</li>
<li><p>通过 wx.navigateTo 将数据放在 url 里面 在 onload 的时候初始化</p>
</li>
</ol>
<h2 id="小程序的生命周期函数"><a href="#小程序的生命周期函数" class="headerlink" title="小程序的生命周期函数"></a>小程序的生命周期函数</h2><p>onLoad 页面加载时触发。一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数<br>onShow() 页面显示/切入前台时触发<br>onReady() 页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互<br>onHide() 页面隐藏/切入后台时触发。 如 navigateTo 或底部 tab 切换到其他页面，小程序切入后台等<br>onUnload() 页面卸载时触发。如 redirectTo 或 navigateBack 到其他页面时</p>
<h2 id="小程序跳转页面的方式"><a href="#小程序跳转页面的方式" class="headerlink" title="小程序跳转页面的方式"></a>小程序跳转页面的方式</h2><h2 id="小程序分包"><a href="#小程序分包" class="headerlink" title="小程序分包"></a>小程序分包</h2><p>整个小程序所有分包大小不超过 4M，单个分包/主包大小不能超过 2M<br>分包数量目前没有限制，也就是说你可以放 N 个分包，甚至每个页面一个分包<br>入口页面/TAB 页面必须在主包里</p>
<h2 id="小程序用户标识"><a href="#小程序用户标识" class="headerlink" title="小程序用户标识"></a>小程序用户标识</h2><p>微信官方提供了两种标识：</p>
<ol>
<li>OpenId 是一个用户对于一个小程序／公众号的标识，开发者可以通过这个标识识别出用户。</li>
<li>UnionId 是一个用户对于同主体微信小程序／公众号／APP 的标识，开发者需要在微信开放平台下绑定相同账号的主体。开发者可通过UnionId，实现多个小程序、公众号、甚至 APP 之间的数据互通。</li>
</ol>
<p>同一个用户的这两个 ID 对于同一个小程序来说是永久不变的，就算用户删了小程序，下次用户进入小程序，开发者依旧可以通过后台的记录标识出来</p>
<h2 id="小程序登陆流程"><a href="#小程序登陆流程" class="headerlink" title="小程序登陆流程"></a>小程序登陆流程</h2><p><a href="https://blog.csdn.net/Ed7zgeE9X/article/details/116724843" target="_blank" rel="noopener">https://blog.csdn.net/Ed7zgeE9X/article/details/116724843</a><br><a href="https://www.cnblogs.com/hjk1124/p/12881926.html" target="_blank" rel="noopener">https://www.cnblogs.com/hjk1124/p/12881926.html</a></p>
<p>「静默登录」和「用户登录」的区别<br>静默登录」是获取微信登录态的过程，通过获取微信提供的用户身份标识，快速建立小程序内的用户体系。<br>用户登录」是用户授权个人开放数据成为会员的过程，是指从游客态转换成会员态的，拥有购买等操作权限。</p>
<p>静默登陆 总结为以下三步：</p>
<ol>
<li><p>小程序端调用 wx.login() 获取 临时登录凭证code(目前有效时长目前为5分钟) ，并回传到开发者服务器。</p>
</li>
<li><p>服务器端调用 auth.code2Session 接口，换取用户唯一标识 OpenID 和 session_key。 此时服务器会返回一个token作为登陆状的标识</p>
</li>
<li><p>将登陆态的标识token进行存储，以便下次使用</p>
</li>
<li><p>请求需要登陆态标识的接口时，携带token</p>
</li>
</ol>
<ul>
<li>储存token值:</li>
</ul>
<ol>
<li>使用getGlobolData存储，以供本次小程序运行使用，</li>
<li>使用wx.Setstorage存储token,以便下次小程序运行使用</li>
</ol>
<p>tips: 很多开发者会把 wx.login 和 wx.getUserInfo 捆绑调用当成登录使用，其实 wx.login 已经可以完成登录，wx.getUserInfo 只是获取额外的用户信息。<br>wx.getUserInfo 只是为了提供更优质的服务而存在，比如获取用户的手机号注册会员，或者展示头像昵称，判断性别，开发者可通过 unionId 和其他公众号上已有的用户画像结合来提供历史数据。因此开发者不必在用户刚刚进入小程序的时候就强制要求授权。</p>
<h2 id="登陆失效"><a href="#登陆失效" class="headerlink" title="登陆失效"></a>登陆失效</h2><p><a href="https://blog.csdn.net/hjh15827475896/article/details/110098433?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;utm_relevant_index=2" target="_blank" rel="noopener">https://blog.csdn.net/hjh15827475896/article/details/110098433?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;utm_relevant_index=2</a></p>
<h2 id="UnionID获取途径"><a href="#UnionID获取途径" class="headerlink" title="UnionID获取途径"></a>UnionID获取途径</h2><p><a href="https://www.jianshu.com/p/46efa68d9033" target="_blank" rel="noopener">https://www.jianshu.com/p/46efa68d9033</a></p>
<ol>
<li><p>调用接口wx.getUserInfo，从解密数据中获取UnionID。注意本接口需要用户授权，请开发者妥善处理用户拒绝授权后的情况。</p>
</li>
<li><p>如果开发者帐号下存在同主体的公众号，并且该用户已经关注了该公众号。开发者可以直接通过wx.login获取到该用户UnionID，无须用户再次授权。</p>
</li>
<li><p>如果开发者帐号下存在同主体的公众号或移动应用，并且该用户已经授权登录过该公众号或移动应用。开发者也可以直接通过wx.login获取到该用户UnionID，无须用户再次授权</p>
</li>
</ol>
<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><blockquote>
<p><a href="https://www.quxingdong.com/1309.html" target="_blank" rel="noopener">https://www.quxingdong.com/1309.html</a></p>
</blockquote>
<h2 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h2><p>参考<a href="https://www.jianshu.com/p/e24ed38d89fd" target="_blank" rel="noopener">https://www.jianshu.com/p/e24ed38d89fd</a><br>webpack 是一个打包模块的机制 他就是识别你的入口文件 模块依赖 然后将这些模块转化成静态文件<br>webpack 做的就是分析代码。转换代码，编译代码，输出代码。<br>webpack 本身是一个 node 的模块，所以 webpack.config.js 是以 commonjs 形式书写的(node 中的模块化是 commonjs 规范的)</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>1 入口 entry 2. 输出 output 3. loader 处理非 js 文件 因为 webpack 只能理解 js 文件<br>4.plugins 执行更多的任务 从打包优化和压缩到重新定义环境中的变量<br>5.mode 选择 develoment(开发) 或 production(生产) 来设置 mode 参数 启用相应模式下的 webpack 内置优化</p>
<ul>
<li>development 模式下 启用 NamedChunksPlugin 和 NamedModulesPlugin 打包后，一些没有依赖的方法 变量 文件会保留，production 则会移除。</li>
<li>development 模式下 启用众多优化插件(如 UglifyJsPlugin 移除没有用的 css js) 打包后，代码会进行压缩，比 development 的文件小。</li>
</ul>
<h2 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h2><p><a href="https://www.cnblogs.com/Yellow-ice/p/10639029.html" target="_blank" rel="noopener">https://www.cnblogs.com/Yellow-ice/p/10639029.html</a></p>
<p>模块化开发是一种管理方式，是一种生产方式，一种解决问题的方案，一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块<br>但是模块开发需要遵循一定的规范，否则就都乱套了，因此，才有了后来大家熟悉的 AMD 规范，CMD 规范</p>
<ol>
<li>AMD<br>　　 AMD 即 Asynchronous Module Definition，中文名是“异步模块定义”的意思，它采用异步方式加载模块，模块的加载不影响它后面语句的运行，所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行</li>
</ol>
<p>一般来说，AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出，因为平时在开发中比较常用的是 require.js 进行模块的定义和加载，一般是使用 define 来定义模块，使用 require 来加载模块</p>
<ol start="2">
<li>CMD<br>　　 CMD 即 Common Module Definition 通用模块定义，CMD 规范是国内发展出来的，同时，CMD 是在 SeaaJS 推广的过程中形成的，CMD 和 AMD 要解决的都是同个问题，在使用上也都很像，只不过两者在模块定义方式和模块加载时机上有所不同</li>
</ol>
<h2 id="webpack-的构建流程是什么"><a href="#webpack-的构建流程是什么" class="headerlink" title="webpack 的构建流程是什么?"></a>webpack 的构建流程是什么?</h2><p>初始化参数<br>开始编译：<br>确定入口：<br>编译模块：<br>完成模块编译：<br>输出资源：<br>输出完成：</p>
<h2 id="怎么配置单页应用？怎么配置多页应用？"><a href="#怎么配置单页应用？怎么配置多页应用？" class="headerlink" title="怎么配置单页应用？怎么配置多页应用？"></a>怎么配置单页应用？怎么配置多页应用？</h2><p>单页应用可以理解为 webpack 的标准模式，直接在 entry 中指定单页应用的入口即可，这里不再赘述<br>多页应用的话，可以使用 webpack 的 AutoWebPlugin 来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范</p>
<h2 id="有哪些常见的-Loader？他们是解决什么问题的？"><a href="#有哪些常见的-Loader？他们是解决什么问题的？" class="headerlink" title="有哪些常见的 Loader？他们是解决什么问题的？"></a>有哪些常见的 Loader？他们是解决什么问题的？</h2><p>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件<br>url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去<br>source-map-loader：加载额外的 Source Map 文件，以方便断点调试<br>image-loader：加载并且压缩图片文件<br>babel-loader：把 ES6 转换成 ES5<br>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性<br>style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。<br>eslint-loader：通过 ESLint 检查 JavaScript 代码</p>
<h2 id="打包优化"><a href="#打包优化" class="headerlink" title="打包优化"></a>打包优化</h2><p>按需加载 路由以及三方组件按需引入<br>提取公共代码 webpack3 使用 CommonsChunkPlugin webpack4 使用 splitChunks<br>CDN 优化<br>优化 loader 配置 优化正则匹配 开启缓存 减少被处理的文件。<br>生产环境关闭 sourceMap (开启得话打包出来的 js 文件中的代码可以映射到代码文件的具体位置,这种映射关系会帮助我们直接找到在源代码中的错误。)<br>代码压缩 ParallelUglifyPlugin 开启多个子进程同时压缩</p>
<h2 id="webpack-的-4-0-打包优化-更加高效"><a href="#webpack-的-4-0-打包优化-更加高效" class="headerlink" title="webpack 的 4.0 打包优化 (更加高效)"></a>webpack 的 4.0 打包优化 (更加高效)</h2><ol>
<li><p>优化 loader 配置<br>1.1 缩小文件匹配范围(include/exclude) 缩小了 loader 加载搜索范围 高概率命中文件<br>1.2 缓存 loader 的执行结果(cacheDirectory) 减少 webpack 构建时 Babel 重新编译过程</p>
</li>
<li><p>HappyPack 多线程打包<br>HappyPack 是让 webpack 对 loader 的执行过程，从单一进程形式扩展为多进程模式，也就是将任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。从而加速代码构建 与 DLL 动态链接库结合来使用更佳。</p>
</li>
</ol>
<p>地址 <a href="https://www.php.cn/js-tutorial-391843.html" target="_blank" rel="noopener">https://www.php.cn/js-tutorial-391843.html</a></p>
<h2 id="怎么解决-vue-打包后静态资源图片失效的问题？"><a href="#怎么解决-vue-打包后静态资源图片失效的问题？" class="headerlink" title="怎么解决 vue 打包后静态资源图片失效的问题？"></a>怎么解决 vue 打包后静态资源图片失效的问题？</h2><p>找到 config/index.js 配置文件，找 build 打包对象里的 assetsPublicPath 属性<br>默认值为/，更改为./就好了<br>最新的 vue-cli 需要在根目录下建一个 vue.config.js 在里面配置 publicPath 即可</p>
<h2 id="打包产生的页面缓存怎么办"><a href="#打包产生的页面缓存怎么办" class="headerlink" title="打包产生的页面缓存怎么办"></a>打包产生的页面缓存怎么办</h2><p>webpack 配置 filename 可规定 index.html 页面需要引入的 js 文件名称，index 页面内其他的按需加载的文件可生成名称为[模块名].[hash].js。(hash 在每次打包后会改变)。<br>&lt; script src=”/js/index_v2.js”&gt; &lt;/ script&gt;</p>
<h2 id="怎么修改-vue-打包后生成文件路径"><a href="#怎么修改-vue-打包后生成文件路径" class="headerlink" title="怎么修改 vue 打包后生成文件路径"></a>怎么修改 vue 打包后生成文件路径</h2><ol>
<li>webpack：output.path</li>
<li>vue-cli3: vue.config.js 中设置 outputDir</li>
</ol>
<h2 id="打包优化-1"><a href="#打包优化-1" class="headerlink" title="打包优化"></a>打包优化</h2><ol>
<li>按需加载 路由以及三方组件按需引入</li>
<li>提取公共代码 webpack3 使用 CommonsChunkPlugin webpack4 使用 splitChunks</li>
<li>CDN 优化</li>
<li>优化 loader 配置 优化正则匹配 开启缓存 减少被处理的文件。</li>
<li>生产环境关闭 sourceMap (开启得话打包出来的 js 文件中的代码可以映射到代码文件的具体位置,这种映射关系会帮助我们直接找到在源代码中的错误。)</li>
<li>代码压缩 ParallelUglifyPlugin 开启多个子进程同时压缩</li>
</ol>
<h2 id="vue-loader-在-webpack-编译流程中的哪个阶段"><a href="#vue-loader-在-webpack-编译流程中的哪个阶段" class="headerlink" title="vue-loader 在 webpack 编译流程中的哪个阶段"></a>vue-loader 在 webpack 编译流程中的哪个阶段</h2><p>编译模板的阶段<br>从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理</p>
<h2 id="有哪些常见的-Plugin-插件-他们是解决什么问题的？"><a href="#有哪些常见的-Plugin-插件-他们是解决什么问题的？" class="headerlink" title="有哪些常见的 Plugin(插件)? 他们是解决什么问题的？"></a>有哪些常见的 Plugin(插件)? 他们是解决什么问题的？</h2><p>html-webpack-plugin //生成 html 文件<em><br>copy-webpack-plugin //复制到剪切板</em><br>clean-webpack-plugin //这个插件是在打包的时候使用的 因为打包的 output 中使用了 hash 码，使文件名是唯一的，不删除的话 dist 文件夹里面就会一堆文件<br>define-plugin：//定义环境变量<br>commons-chunk-plugin：//提取公共代码<br>uglifyjs-webpack-plugin：//通过 UglifyES 压缩 ES6 代码<br>extract-text-webpack-plugin //提取样式到单独的 css 文件<br>CommonsChunkPlugin //提取公共的 JS 库</p>
<h2 id="webpack-本地开发怎么解决跨域"><a href="#webpack-本地开发怎么解决跨域" class="headerlink" title="webpack 本地开发怎么解决跨域"></a>webpack 本地开发怎么解决跨域</h2><p>使用 webpack-dev-server 插件<br>步骤：下载插件 在 webpack.config 文件中引入插件 使用 devServer 配置端口和代理重写路径</p>
<h2 id="dirname-和-的区别"><a href="#dirname-和-的区别" class="headerlink" title="__dirname 和 ./ 的区别"></a>__dirname 和 ./ 的区别</h2><p>_dirname 总是指向被执行 js 文件所在的绝对路径，所以当你在 /d1/d2/myscript.js 文件中写了 **dirname， 它的值就是 /d1/d2 。</p>
<p>相反，./ 会返回你执行 node 命令的路径，例如你的工作路径。</p>
<p>有一个特殊情况是在 require() 中使用 ./ 时，这时的路径就会是含有 require() 的脚本文件的相对路径。</p>
<h2 id="Hash（散列函数"><a href="#Hash（散列函数" class="headerlink" title="Hash（散列函数"></a>Hash（散列函数</h2><p>哈希 是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。<br>HASH 是根据文件的内容的数据通过逻辑运算得到的数值, 不同的文件(即使是相同的文件名)得到的 HASH 值是不同的, 所以 HASH 值就成了每一个文件在 EMULE 里的身份证.<br>不同 HASH 值的文件在 EMULE 里被认为是不同的文件,相同的 HASH 值的文件的内容肯定是完全相同(即使文件名不同).<br>HASH 值还有文件校验的功能,相当于文件的校验码.<br>所以还可以用来检查文件下载是否正确(所以 EMULE 下载完毕时,都会在 HASH 文件一遍, 检查文件是否出错)</p>
<h1 id="Typescript"><a href="#Typescript" class="headerlink" title="Typescript"></a>Typescript</h1><p>简介： Typescript 是强类型的 Javascript 超集，支持 ES6 语法，支持面向对象编程的概念，如类、接口、继承、泛型等。<br>Typescript 并不直接在浏览器上运行，需要编译器编译成纯 Javascript 来运行。</p>
<h2 id="他解决了什么呢"><a href="#他解决了什么呢" class="headerlink" title="他解决了什么呢"></a>他解决了什么呢</h2><ol>
<li>解决前端的规范问题 提前暴露问题 比如防止了团队合作中有人改错数据导致 bug<br>2.</li>
</ol>
<p>链接 👉 <a href="https://www.jianshu.com/p/c8aaba6e8ce0" target="_blank" rel="noopener">https://www.jianshu.com/p/c8aaba6e8ce0</a></p>
<h2 id="Typescript-有哪些基础类型？"><a href="#Typescript-有哪些基础类型？" class="headerlink" title="Typescript 有哪些基础类型？"></a>Typescript 有哪些基础类型？</h2><p>1：number 2：string 3：boolean 4：Symbol 5：Array 6：Tuple(元组) 7：enum(枚举) 8：object</p>
<p>9：never 表示那些永不存在的值类型。如总是抛出异常或者根本不会有返回值的函数的返回值类型。</p>
<p>10：void 类型的变量只能赋值为 undefined 和 null。函数没有返回值时用 void。</p>
<p>11：null 和 undefined 它们是所有类型的子类型。当你指定 structNullChecks 时，它们只能赋值给 void 或者它们自己本身。</p>
<p>12：any 表示任何类型的值</p>
<h2 id="NUXT"><a href="#NUXT" class="headerlink" title="NUXT"></a>NUXT</h2><p>对于 nuxt 来说，有两个特点：</p>
<p>摒弃了 vue 中的路由表，改为文件结构自动生成的路由，比如 pages/users/index.vue，即生成 /users 对应的路由，当然也可以使用 pages/users.vue 渲染该路由，比较灵活。<br>将 Vue 中的 Layout 单独抽为 视图 概念，在 nuxt 项目根目录的 layouts 文件夹内编写。</p>
<h1 id="业务问题"><a href="#业务问题" class="headerlink" title="业务问题"></a>业务问题</h1><h2 id="权限设计"><a href="#权限设计" class="headerlink" title="权限设计"></a>权限设计</h2><h2 id="你现在做的项目最复杂功能有哪些"><a href="#你现在做的项目最复杂功能有哪些" class="headerlink" title="你现在做的项目最复杂功能有哪些"></a>你现在做的项目最复杂功能有哪些</h2><h2 id="大文件上传-如一个-G-的文件或者-500M-的文件"><a href="#大文件上传-如一个-G-的文件或者-500M-的文件" class="headerlink" title="大文件上传 如一个 G 的文件或者 500M 的文件"></a>大文件上传 如一个 G 的文件或者 500M 的文件</h2><p><a href="https://www.6hu.cc/archives/11164.html" target="_blank" rel="noopener">https://www.6hu.cc/archives/11164.html</a><br>大文件上传<br>将大文件转换成二进制流的格式<br>使用流能够切开的特色，将二进制流切开成多份<br>拼装和切开块持平数量的央求块，并行或串行的方法宣告央求<br>断点续传<br>为每一个文件切开块添加不同的标识<br>当上传成功的之后，记载上传成功的标识<br>当咱们暂停或许发送失利后，能够从头发送没有上传成功的切开文件</p>
<p>HTML5 的 FILE api，有一个 slice 方法，可以将 BLOB 对象进行分割。前端通过 FileList 对象获取到相应的文件，按照指定的分割方式将大文件分段，然后一段一段地传给后端，后端再按顺序一段段将文件进行拼接。<br>断点续传原理<br>目前比较常用的断点续传的方法有两种，一种是通过 websocket 接口进行文件上传，另一种是通过 ajax，两种方法各有千秋，虽然 websocket 听起来比较高端些，但是除了用了不同的协议外其他的算法基本上都是很相似的，并且服务端要开启 ws 接口，这里用相对方便的 ajax 来说明断点上传的思路。<br>说来说去，断点续传最核心的内容就是把文件“切片”然后再一片一片的传给服务器，但</p>
<h2 id="WEB-前端实现在线预览、编辑-Office-文档"><a href="#WEB-前端实现在线预览、编辑-Office-文档" class="headerlink" title="WEB 前端实现在线预览、编辑 Office 文档"></a>WEB 前端实现在线预览、编辑 Office 文档</h2><p><a href="https://blog.csdn.net/nuclear2011/article/details/117369109" target="_blank" rel="noopener">https://blog.csdn.net/nuclear2011/article/details/117369109</a></p>
<p>使用插件：Spire.Cloud 在线 Office 文档编辑器（官网：<a href="https://cloud.e-iceblue.cn/）" target="_blank" rel="noopener">https://cloud.e-iceblue.cn/）</a></p>
<p>重点：该方案仅需浏览器支持 HTML5，提供中英文双语界面，不需要安装 Office 或控件，也不需要做环境配置就可以直接调用插件，非常简单。</p>
<h2 id="更新项目版本后如何不强制刷新更新页面"><a href="#更新项目版本后如何不强制刷新更新页面" class="headerlink" title="更新项目版本后如何不强制刷新更新页面"></a>更新项目版本后如何不强制刷新更新页面</h2><p><a href="https://www.jianshu.com/p/a5a32acbf205" target="_blank" rel="noopener">https://www.jianshu.com/p/a5a32acbf205</a></p>
<p>一、meta 标签处理<br>vue-cli 里的默认配置，css 和 js 的名字都加了哈希值，所以新版本 css、js 和就旧版本的名字是不同的，不会有缓存问题。关键在于 index.html 文件它会被浏览器缓存。浏览器访问的还是旧的静态资源。解决办法如下，在 meta 标签禁止浏览器缓存 html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"cache-control"</span> <span class="attr">content</span>=<span class="string">"no-cache,no-store, must-revalidate"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"pragma"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Expires"</span> <span class="attr">content</span>=<span class="string">"0"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>二、版本号 + 定时器<br>每次发版都应该有个版本号，很多开发者忽略了这个问题。这里我就用大白话说下我的思路。发版的时候我们把更新的版本号存放到静态文件中。然后定时用 ajax 请求获取这个静态文件的版本号。最后跟浏览器内存中的版本号进行对比，如果不一致则说明有更新。js 执行刷新页面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时获取版本号</span></span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  checkUpdate();</span><br><span class="line">&#125;, <span class="number">6000</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkUpdate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  axios</span><br><span class="line">    .get(<span class="string">`/getVersion?timestamp=<span class="subst">$&#123;<span class="built_in">Date</span>.parse(<span class="keyword">new</span> <span class="built_in">Date</span>())&#125;</span>`</span>)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 判断版本号是否与本地一致</span></span><br><span class="line">      <span class="keyword">if</span> (response.version != localStorage.getItem(<span class="string">"version"</span>)) &#123;</span><br><span class="line">        localStorage.setItem(<span class="string">"version"</span>, response.version);</span><br><span class="line">        location.reload();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//版本号一致不做处理</span></span><br><span class="line">        <span class="built_in">console</span>(<span class="string">"版本号一致不做处理"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="开发中遇到的-bug-难点-怎么解决的"><a href="#开发中遇到的-bug-难点-怎么解决的" class="headerlink" title="开发中遇到的 bug,难点 怎么解决的"></a>开发中遇到的 bug,难点 怎么解决的</h2><ol>
<li>小程序 setdata 性能差<br>解决: 为了提升数据更新的性能，开发者在执行 setData 调用时，最好遵循以下原则：不要过于频繁调用 setData，应考虑将多次 setData 合并成一次 setData 调用；<br>数据通信的性能与数据量正相关，因而如果有一些数据字段不在界面中展示且数据结构比较复杂或包含长字符串，则不应使用 setData 来设置这些数据；</li>
</ol>
<p>// 不要频繁调用 setData this.setData({ a: 1 }) this.setData({ b: 2 })<br>// 绝大多数时候可优化为<br>this.setData({ a: 1, b: 2 })</p>
<p>// 不要设置不在界面渲染时使用的数据，并将界面无关的数据放在 data 外<br>this.setData({<br>myData: {<br>a: ‘这个字符串在 WXML 中用到了’,<br>b: ‘这个字符串未在 WXML 中用到，而且它很长…………………………’<br>}<br>})</p>
<p>// 可以优化为<br>this.setData({<br>‘myData.a’: ‘这个字符串在 WXML 中用到了’<br>})</p>
<p>this._myData = {<br>b: ‘这个字符串未在 WXML 中用到，而且它很长…………………………’<br>}</p>
<ol start="2">
<li>Vue 电商 SKU 组合算法问题</li>
</ol>
<p><a href="https://www.cnblogs.com/ykCoder/p/10942055.html" target="_blank" rel="noopener">https://www.cnblogs.com/ykCoder/p/10942055.html</a></p>
<h2 id="前端大量数据检索-优化"><a href="#前端大量数据检索-优化" class="headerlink" title="前端大量数据检索 优化"></a>前端大量数据检索 优化</h2><p><a href="https://blog.csdn.net/weixin_42048805/article/details/113058577" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42048805/article/details/113058577</a><br>通过建立字典树（Trie）来优化搜索。无论用户想访问任何属性的值，只要从树的根节点出发，依据属性字母出现的顺序访问树的叶子节点，即可得到该属性的值。</p>
<h2 id="如何高性能的渲染十万条数据-虚拟列表"><a href="#如何高性能的渲染十万条数据-虚拟列表" class="headerlink" title="如何高性能的渲染十万条数据(虚拟列表)"></a>如何高性能的渲染十万条数据(虚拟列表)</h2><p>有时会遇到需要一些不能使用分页方式来加载列表数据的业务情况，对于此，我们称这种列表叫做长列表。<br>比如，在一些外汇交易系统中，前端会实时的展示用户的持仓情况(收益、亏损、手数等)，此时对于用户的持仓列表一般是不能分页的。</p>
<p><a href="https://hefeng6500.github.io/blog/performance/virtual-scroll" target="_blank" rel="noopener">https://hefeng6500.github.io/blog/performance/virtual-scroll</a></p>
<p>只对可见区域进行渲染，对非可见区域中的数据不渲染或部分渲染的技术，从而达到极高的渲染性能。<br>假设有 1 万条记录需要同时渲染，我们屏幕的可见区域的高度为500px,而列表项的高度为50px，则此时我们在屏幕中最多只能看到 10 个列表项，那么在首次渲染的时候，我们只需加载 10 条即可。</p>
<p>步骤:<br>在首屏加载的时候，只加载可视区域内需要的列表项，当滚动发生时，动态通过计算获得可视区域内的列表项，并将非可视区域内存在的列表项删除。<br>计算当前可视区域起始数据索引(startIndex)<br>计算当前可视区域结束数据索引(endIndex)<br>计算当前可视区域的数据，并渲染到页面中<br>计算startIndex对应的数据在整个列表中的偏移位置startOffset并设置到列表上</p>
<h2 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h2><h1 id="手写算法题"><a href="#手写算法题" class="headerlink" title="手写算法题"></a>手写算法题</h1><ol>
<li>已知如下数组，编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组<br>var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];</li>
</ol>
<p>答：使用 Set 方法去重，flat(Infinity)扁平化 sort() 排序<br>Array.from(new Set(arr.flat(Infinity))).sort((a,b)=&gt;{ return a-b})<br>//输出 [1,2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]</p>
<ol start="2">
<li>js 实现点击不同的按钮后各自返回被点击的次数-关于闭包</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"按钮A"</span> onclick=<span class="string">"countA()"</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"按钮B"</span> onclick=<span class="string">"countB()"</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"按钮C"</span> onclick=<span class="string">"countC()"</span>&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">     <span class="comment">//方案1 大于两个时候比较繁琐</span></span><br><span class="line">         <span class="keyword">var</span> counter=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">var</span> counter2=<span class="number">0</span>;</span><br><span class="line">         <span class="function"><span class="keyword">function</span> <span class="title">count1</span>(<span class="params"></span>)</span>&#123; <span class="comment">//1、全局变量适合做返回所有按钮的总点击数，否则用全局变量的话每一个按钮要多一个函数，用闭包就很方便</span></span><br><span class="line">             counter+=<span class="number">1</span>;</span><br><span class="line">             alert(<span class="string">'您共点击了我'</span>+counter+<span class="string">'次'</span>)</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="keyword">function</span> <span class="title">count2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             counter2+=<span class="number">1</span>;</span><br><span class="line">             alert(<span class="string">'您共点击了我'</span>+counter2+<span class="string">'次'</span>)</span><br><span class="line">         &#125;</span><br><span class="line">     <span class="comment">//方案2</span></span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">         <span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">             counter += <span class="number">1</span>; <span class="comment">//2、闭包实现原理：这个匿名函数用了外面函数的变量，外面函数的变量被常驻内存，有几个匿名函数，匿名函数中用的的这个变量就有多少个在内存，</span></span><br><span class="line">             alert(<span class="string">'您共点击了我'</span>+counter+<span class="string">'次'</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> increment</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">var</span> countA=count();</span><br><span class="line">    <span class="keyword">var</span> countB=count()</span><br><span class="line">    <span class="keyword">var</span> countC=count()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  function count() &#123;</span></span><br><span class="line">     <span class="comment">//     var counter = 0;</span></span><br><span class="line">     <span class="comment">//     (function () &#123;</span></span><br><span class="line">     <span class="comment">//         return(function()&#123;</span></span><br><span class="line">     <span class="comment">//             counter += 1;</span></span><br><span class="line">     <span class="comment">//             alert('您共点击了我'+counter+'次');</span></span><br><span class="line">     <span class="comment">//         &#125;</span></span><br><span class="line">     <span class="comment">//         )()</span></span><br><span class="line">     <span class="comment">//     &#125;)()</span></span><br><span class="line">     <span class="comment">// &#125;</span></span><br><span class="line">     &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>关于作用域</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = (b = <span class="number">3</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// a is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">首先分析  var a = b = 3 可以拆分为 </span></span><br><span class="line"><span class="comment">b = 3         b是全局变量，在立即执行函数里赋值为3</span></span><br><span class="line"><span class="comment">var a = b     a是立即执行函数里声明的变量，函数执行完a就被释放，</span></span><br><span class="line"><span class="comment">              并没有生成全局变量a，所以在全局输出a会报错：a is not defined</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>return</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    bar: <span class="string">"hello"</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    bar: <span class="string">"hello"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo1()); <span class="comment">//&#123;bar: "hello"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(foo2()); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>先看他们的区别就是 return 后面的“{}”一个是在同一行一个是换了一行，那么我们看见这个就能想到<br>return 有个特点就是：其后面同一行内跟的值就返回，要是换了一行的话，return 后面会自动补一个分号，那么下一行的内容就不会再执行<br>（1）因为 return 标志着函数的结束，其后面的内容不执行。<br>（2）并且 return 没有明确返回值的话，就会默认返回一个 undefined。<br>（3）用函数加括号就等于函数内 return 的值。</p>
<ol start="5">
<li>css 实现对元素自动排序</li>
</ol>
<p>在 CSS2.1 中的自动编号由两个属性控制，它们分别为：“counter-increment”和“counter-reset”。由这些属性定义的计数器（counter）与“content”属性的 counter()和 counters()函数一起使用。</p>
<p>. 例：显示了使用“第 1 章”，“1.1”，“1.2”等对章节进行编号的方法。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">　　</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>大标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">　　</span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>小标题1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">　　</span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>小标题2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="selector-tag">body</span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">counter-reset</span>:chapter;<span class="comment">/*创建章节计数器范围*/</span></span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="selector-tag">h1</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">content</span>:<span class="string">"第"</span><span class="built_in">counter</span>(chapter)<span class="string">"章、"</span>;</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">counter-increment</span>:chapter;<span class="comment">/*在章节中添加1*/</span></span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="selector-tag">h1</span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">counter-reset</span>:section;<span class="comment">/*将部分设置为0*/</span></span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="selector-tag">h2</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">content</span>:<span class="built_in">counter</span>(chapter)<span class="string">"."</span><span class="built_in">counter</span>(section)<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">counter-increment</span>:section;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。<br>有效字符串需满足：左括号必须用相同类型的右括号闭合，左括号必须以正确的顺序闭合。<br>输入：s = “([)]” 输出：false<br>输入：s = “{[]}” 输出：true</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public boolean isValid(<span class="built_in">String</span> s) &#123;</span><br><span class="line">      <span class="comment">//假如长度是1或者不为偶数</span></span><br><span class="line">      <span class="keyword">if</span>(s.length()&lt;<span class="number">2</span>||s.length()%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(s.isEmpty())&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      int count = <span class="number">0</span>;</span><br><span class="line">      int length = s.length();</span><br><span class="line">      <span class="comment">//循环替换，最大次数为s.length()/2</span></span><br><span class="line">      <span class="keyword">while</span>(count&lt;length/<span class="number">2</span>)&#123;</span><br><span class="line">          s = s.replace(<span class="string">"&#123;&#125;"</span>,<span class="string">""</span>).replace(<span class="string">"[]"</span>,<span class="string">""</span>).replace(<span class="string">"()"</span>,<span class="string">""</span>);</span><br><span class="line">          count++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//假如循环替换完，还有值，那么肯定就不是对称结构</span></span><br><span class="line">      <span class="keyword">if</span>(s.length()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="当-for-嵌套这定时器"><a href="#当-for-嵌套这定时器" class="headerlink" title="当 for 嵌套这定时器"></a>当 for 嵌套这定时器</h2><p>由于变量 i 直接暴露在全局作用域内，<br>当调用 console.log 函数开始输出时，这是循环已经结束，所以会输出 10 个 10。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况下如何才能按循环循序输出打印呢</p>
<p>使用闭包相当于利用一个匿名函数的壳模拟出一个块级作用域</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="amp-amp-和"><a href="#amp-amp-和" class="headerlink" title="&amp;&amp; 和 ||"></a>&amp;&amp; 和 ||</h2><ol>
<li>&amp;&amp;</li>
</ol>
<p>1.1 两边条件都为 true 时，结果才为 true；<br>1.2 如果有一个为 false，结果就为 false；<br>1.3 当第一个条件为 false 时，就不再判断后面的条件</p>
<p>注意：当数值参与逻辑与运算时，结果为 true，那么会返回的会是第二个为真的值；如果结果为 false，返回的会是第一个为假的值。</p>
<ol start="2">
<li>||</li>
</ol>
<p>2.1 只要有一个条件为 true 时，结果就为 true；<br>2.2 当两个条件都为 false 时，结果才为 false；<br>2.3 当一个条件为 true 时，后面的条件不再判断</p>
<p>注意：当数值参与逻辑或运算时，结果为 true，会返回第一个为真的值；如果结果为 false，会返回第二个为假的值；</p>
<p>console.log( 0 || 1 );// 1<br>console.log( 1 || 2 );// 1<br>console.log( 0 &amp;&amp; 1 );// 0<br>console.log( 1 &amp;&amp; 2 );// 2</p>
<h2 id="对象键名称只能是字符串"><a href="#对象键名称只能是字符串" class="headerlink" title="对象键名称只能是字符串"></a>对象键名称只能是字符串</h2><p>var a={},<br>b={key:’b’},<br>c={key:’c’};</p>
<p>a[b]=123;<br>a[c]=456;</p>
<p>console.log(a[b]);//为什么是 456？</p>
<p>因为键名称只能是字符串，b/c 单做键会调用 toString 得到的都是[object Object]，a[b],a[c]都等价于 a[“[object Object]”]，那不就是更新[object Object]这个键的值了</p>
<h2 id="高阶函数-fun"><a href="#高阶函数-fun" class="headerlink" title="高阶函数 fun()()"></a>高阶函数 fun()()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">sec</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num + sec;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">      num = num + <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">//5</span></span><br><span class="line">sum(<span class="number">2</span>)(<span class="number">3</span>); <span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<p>arguments 是一个对应于传递给函数的参数的类数组对象。<br>类数组：是数组的形式，有 length，但不具有数组的一切方法</p>
<p>##</p>
<p>以下哪条语句会产生运行错误（ ）</p>
<p>A、var obj = ( ); 错</p>
<p>B、var obj = [ ];</p>
<p>C、var obj = { };</p>
<p>D、var obj =/ /; 这个中间每空格注释写法而已</p>
<h2 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h2><p>null === undefined //false<br>null == undefined //true<br>NaN == NaN //false</p>
<p>JavaScript 的规定，NaN 表示的是非数字， 但是这个非数字也是不同的，因此，NaN 不等于 NaN，并且两个 NaN 永远不可能相等。</p>
<h2 id="实现一个-sleep-函数"><a href="#实现一个-sleep-函数" class="headerlink" title="实现一个 sleep 函数"></a>实现一个 sleep 函数</h2><p>比如 sleep(1000)代表等待 1000ms</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：ES5 方式实现</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">callback, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback == <span class="string">"function"</span>) &#123;</span><br><span class="line">    setTimeout(callback, time);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">sleep(output, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：使用 promise 方式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sleep = <span class="function">(<span class="params">time</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">sleep(<span class="number">2000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三：利用 async</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> temp = <span class="keyword">await</span> sleep(<span class="number">2000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"YJJ"</span>); <span class="comment">//2s后执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br></pre></td></tr></table></figure>
<h2 id="如何让-a-1-amp-amp-a-2-amp-amp-a-3-判断成立"><a href="#如何让-a-1-amp-amp-a-2-amp-amp-a-3-判断成立" class="headerlink" title="如何让(a===1&amp;&amp;a===2&amp;&amp;a===3)判断成立"></a>如何让(a===1&amp;&amp;a===2&amp;&amp;a===3)判断成立</h2><ol>
<li>先监听 a 这个变量，当每次访问 a 的时候返回自拟定的值</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种方法 还用tostring方法</span></span><br><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;;</span><br><span class="line">a.valueOf = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span>.value += <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方法</span></span><br><span class="line"><span class="keyword">var</span> value = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">"a"</span>, &#123;</span><br><span class="line">  get() &#123;</span><br><span class="line">    <span class="comment">//使用defineProperty的get属性</span></span><br><span class="line">    <span class="keyword">return</span> (value += <span class="number">1</span>); <span class="comment">//每访问一次a 就a++</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">1</span> &amp;&amp; a === <span class="number">2</span> &amp;&amp; a === <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"success"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/js/" rel="tag"># js</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2012/03/01/TypeScript/" rel="next" title="TypeScript">
                <i class="fa fa-chevron-left"></i> TypeScript
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2012/07/02/工作宝典-css/" rel="prev" title="工作宝典-style">
                工作宝典-style <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zODUwNy8xNTAzNQ"></div>
    </div>

  



        </div>
         
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">candice</p>
              <p class="site-description motion-element" itemprop="description">平凡的你的不平凡</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">50</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">21</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#nodejs"><span class="nav-number">1.</span> <span class="nav-text">nodejs</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#中间件"><span class="nav-number">1.1.</span> <span class="nav-text">中间件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#优化"><span class="nav-number">2.</span> <span class="nav-text">优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#打开浏览器，输入-URL，到页面展示出来的过程及优化："><span class="nav-number">2.1.</span> <span class="nav-text">打开浏览器，输入 URL，到页面展示出来的过程及优化：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#uni-app"><span class="nav-number">3.</span> <span class="nav-text">uni.app</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#html"><span class="nav-number">4.</span> <span class="nav-text">html</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#前端常用设计模式"><span class="nav-number">4.1.</span> <span class="nav-text">前端常用设计模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是设计模式，设计模式的作用。"><span class="nav-number">4.2.</span> <span class="nav-text">什么是设计模式，设计模式的作用。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#写出你用过的设计模式"><span class="nav-number">4.3.</span> <span class="nav-text">写出你用过的设计模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-双向绑定模式"><span class="nav-number">4.4.</span> <span class="nav-text">vue 双向绑定模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SVG-和-CANVAS-的区别"><span class="nav-number">4.5.</span> <span class="nav-text">SVG 和 CANVAS 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哪些浏览器有自主内核"><span class="nav-number">4.6.</span> <span class="nav-text">哪些浏览器有自主内核?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#前端页面有哪三层构成，分别是什么-作用是什么"><span class="nav-number">4.7.</span> <span class="nav-text">前端页面有哪三层构成，分别是什么?作用是什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#html5-css3-新特性"><span class="nav-number">4.8.</span> <span class="nav-text">html5/css3 新特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTML5-提供了对-Web-Sockets-的支持。"><span class="nav-number">4.9.</span> <span class="nav-text">HTML5 提供了对 Web Sockets 的支持。</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#特点"><span class="nav-number">4.9.1.</span> <span class="nav-text">特点:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连接保持-心跳"><span class="nav-number">4.9.2.</span> <span class="nav-text">连接保持 + 心跳</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#状态-readyState属性返回实例对象的当前状态-有4种；"><span class="nav-number">4.10.</span> <span class="nav-text">状态 readyState属性返回实例对象的当前状态,有4种；</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#新增了两个存储方式-老的-cookie-4kb-时间限制-明文存储"><span class="nav-number">4.11.</span> <span class="nav-text">新增了两个存储方式 [老的-cookie(4kb 时间限制 明文存储)]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#盒模型"><span class="nav-number">4.12.</span> <span class="nav-text">盒模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BCF-Block-Format-Content"><span class="nav-number">5.</span> <span class="nav-text">BCF( Block Format Content)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#css-部分"><span class="nav-number">6.</span> <span class="nav-text">css 部分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#最小字体"><span class="nav-number">6.1.</span> <span class="nav-text">最小字体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使元素水平垂直居中方案"><span class="nav-number">6.2.</span> <span class="nav-text">使元素水平垂直居中方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#flex-常用参数"><span class="nav-number">6.3.</span> <span class="nav-text">flex 常用参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#移动端-1px-解决方案"><span class="nav-number">6.4.</span> <span class="nav-text">移动端 1px 解决方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#less-和-sass-或者-scss-有什么区别吗？"><span class="nav-number">6.5.</span> <span class="nav-text">less 和 sass 或者 scss 有什么区别吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#css-选择器"><span class="nav-number">6.6.</span> <span class="nav-text">css 选择器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#高级选择器"><span class="nav-number">6.6.1.</span> <span class="nav-text">高级选择器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序"><span class="nav-number">6.6.2.</span> <span class="nav-text">排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JS-部分"><span class="nav-number">7.</span> <span class="nav-text">JS 部分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#拷贝对象"><span class="nav-number">7.1.</span> <span class="nav-text">拷贝对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#深拷贝"><span class="nav-number">7.1.1.</span> <span class="nav-text">深拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浅拷贝-Object-assign-ES6-的展开运算符…"><span class="nav-number">7.1.2.</span> <span class="nav-text">浅拷贝 Object.assign() ES6 的展开运算符…</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#js-常用操作"><span class="nav-number">7.2.</span> <span class="nav-text">js 常用操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原生-js-查找-操作元素方法"><span class="nav-number">7.3.</span> <span class="nav-text">原生 js 查找/操作元素方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#js-数据类型"><span class="nav-number">7.4.</span> <span class="nav-text">js 数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本数据类型特点"><span class="nav-number">7.5.</span> <span class="nav-text">基本数据类型特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#typeof-共返回-6-种数据格式："><span class="nav-number">7.6.</span> <span class="nav-text">typeof 共返回 6 种数据格式：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null-和-undefined-的区别"><span class="nav-number">7.7.</span> <span class="nav-text">null 和 undefined 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何判断是否为数组"><span class="nav-number">7.8.</span> <span class="nav-text">如何判断是否为数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用的数组方法"><span class="nav-number">7.9.</span> <span class="nav-text">常用的数组方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for-in-和-for-of的区别详解以及为for-in的输出顺序"><span class="nav-number">7.10.</span> <span class="nav-text">for in 和 for of的区别详解以及为for in的输出顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES6-Proxy属性"><span class="nav-number">7.11.</span> <span class="nav-text">ES6 Proxy属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#返回各种数字"><span class="nav-number">7.12.</span> <span class="nav-text">返回各种数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存泄漏"><span class="nav-number">7.13.</span> <span class="nav-text">内存泄漏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾回收机制"><span class="nav-number">7.14.</span> <span class="nav-text">垃圾回收机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#es6-新增"><span class="nav-number">7.15.</span> <span class="nav-text">es6 新增</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#var-与-let、const-的区别"><span class="nav-number">7.16.</span> <span class="nav-text">var 与 let、const 的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#const-的特性和-let-完全一样，const-不同的只是"><span class="nav-number">7.16.1.</span> <span class="nav-text">const 的特性和 let 完全一样，const 不同的只是</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解构赋值及其原理"><span class="nav-number">7.17.</span> <span class="nav-text">解构赋值及其原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对-promise-的理解和-解决回调地狱"><span class="nav-number">7.18.</span> <span class="nav-text">对 promise 的理解和 解决回调地狱</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise-静态方法-all-race-的差别"><span class="nav-number">7.19.</span> <span class="nav-text">Promise 静态方法 all/race 的差别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#手写一个-promise"><span class="nav-number">7.20.</span> <span class="nav-text">手写一个 promise</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#async-和-await"><span class="nav-number">7.21.</span> <span class="nav-text">async 和 await</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#export-与-export-default-区别"><span class="nav-number">7.22.</span> <span class="nav-text">export 与 export default 区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#递归"><span class="nav-number">7.23.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包是什么，有什么特性，对页面有什么影响"><span class="nav-number">7.24.</span> <span class="nav-text">闭包是什么，有什么特性，对页面有什么影响?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型"><span class="nav-number">7.25.</span> <span class="nav-text">原型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型链"><span class="nav-number">7.26.</span> <span class="nav-text">原型链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#作用域"><span class="nav-number">7.27.</span> <span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#作用域链"><span class="nav-number">7.28.</span> <span class="nav-text">作用域链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#js-是怎么实现继承的"><span class="nav-number">7.29.</span> <span class="nav-text">js 是怎么实现继承的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件绑定和普通事件有什么区别"><span class="nav-number">7.30.</span> <span class="nav-text">事件绑定和普通事件有什么区别?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对事件循环的理解"><span class="nav-number">7.31.</span> <span class="nav-text">对事件循环的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件委托-事件代理-是什么"><span class="nav-number">7.32.</span> <span class="nav-text">事件委托(事件代理)是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何阻止事件冒泡？"><span class="nav-number">7.33.</span> <span class="nav-text">如何阻止事件冒泡？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组去重"><span class="nav-number">7.34.</span> <span class="nav-text">数组去重</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#箭头函数和普通函数的区别"><span class="nav-number">7.35.</span> <span class="nav-text">箭头函数和普通函数的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this-的指向"><span class="nav-number">7.36.</span> <span class="nav-text">this 的指向</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#call-和-apply-和-bind-的区别"><span class="nav-number">7.37.</span> <span class="nav-text">call 和 apply 和 bind 的区别?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#防抖节流"><span class="nav-number">7.38.</span> <span class="nav-text">防抖节流</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Git-部分"><span class="nav-number">8.</span> <span class="nav-text">Git 部分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#提交代码流程"><span class="nav-number">8.1.</span> <span class="nav-text">提交代码流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不提交修改的代码时切换分支的方法"><span class="nav-number">8.2.</span> <span class="nav-text">不提交修改的代码时切换分支的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将某个分支的某个文件合并到当前分支"><span class="nav-number">8.3.</span> <span class="nav-text">将某个分支的某个文件合并到当前分支</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#请求这一块的"><span class="nav-number">9.</span> <span class="nav-text">请求这一块的</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-协议"><span class="nav-number">9.1.</span> <span class="nav-text">HTTP 协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-请求头属性"><span class="nav-number">9.2.</span> <span class="nav-text">HTTP 请求头属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浏览器缓存-强制缓存和协商缓存"><span class="nav-number">9.3.</span> <span class="nav-text">浏览器缓存-强制缓存和协商缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#前端常见的攻击以及防御"><span class="nav-number">9.4.</span> <span class="nav-text">前端常见的攻击以及防御</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Iframe-有什么好处，有什么坏处？"><span class="nav-number">9.5.</span> <span class="nav-text">Iframe 有什么好处，有什么坏处？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#javascript-的同源策略"><span class="nav-number">9.6.</span> <span class="nav-text">javascript 的同源策略?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浏览器为什么要有同源策略"><span class="nav-number">9.7.</span> <span class="nav-text">浏览器为什么要有同源策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ajax-请求的时候-get-和-post-方式的区别"><span class="nav-number">9.8.</span> <span class="nav-text">ajax 请求的时候 get 和 post 方式的区别?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#既然如此那么-get-还有什么存在的意义"><span class="nav-number">9.9.</span> <span class="nav-text">既然如此那么 get 还有什么存在的意义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#跨域解决方案-造成跨域是因为（域名不同、端口不同，IP-不同）"><span class="nav-number">9.10.</span> <span class="nav-text">跨域解决方案? 造成跨域是因为（域名不同、端口不同，IP 不同）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多级域名跨域吗"><span class="nav-number">9.11.</span> <span class="nav-text">多级域名跨域吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-IP-协议"><span class="nav-number">9.12.</span> <span class="nav-text">TCP/IP 协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http-的三次握手和四次挥手"><span class="nav-number">9.13.</span> <span class="nav-text">http 的三次握手和四次挥手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#状态码"><span class="nav-number">9.14.</span> <span class="nav-text">状态码:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#打开浏览器，输入-URL，到页面展示出来的过程："><span class="nav-number">9.15.</span> <span class="nav-text">打开浏览器，输入 URL，到页面展示出来的过程：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#vue"><span class="nav-number">10.</span> <span class="nav-text">vue</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对于-MVC-MVVM-的理解？"><span class="nav-number">10.1.</span> <span class="nav-text">对于 MVC MVVM 的理解？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#双向数据绑定原理"><span class="nav-number">10.2.</span> <span class="nav-text">双向数据绑定原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-defineProperty-是怎么监听数组变化的"><span class="nav-number">10.3.</span> <span class="nav-text">Object.defineProperty 是怎么监听数组变化的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组下标更改数组的值不生效"><span class="nav-number">10.4.</span> <span class="nav-text">数组下标更改数组的值不生效</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Proxy-的优势如下"><span class="nav-number">10.5.</span> <span class="nav-text">Proxy 的优势如下</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#proxy-都有哪些参数"><span class="nav-number">10.6.</span> <span class="nav-text">proxy 都有哪些参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-defineProperty-将属性变为不可修改"><span class="nav-number">10.7.</span> <span class="nav-text">Object.defineProperty() 将属性变为不可修改</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单向数据流和双向数据绑定"><span class="nav-number">10.8.</span> <span class="nav-text">单向数据流和双向数据绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组件生命周期"><span class="nav-number">10.9.</span> <span class="nav-text">组件生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#父子组件的生命周期顺序"><span class="nav-number">10.10.</span> <span class="nav-text">父子组件的生命周期顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#子组件更新过程"><span class="nav-number">10.11.</span> <span class="nav-text">子组件更新过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#父组件更新过程"><span class="nav-number">10.12.</span> <span class="nav-text">父组件更新过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#销毁过程"><span class="nav-number">10.13.</span> <span class="nav-text">销毁过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第一次页面加载会触发哪几个钩子？"><span class="nav-number">10.14.</span> <span class="nav-text">第一次页面加载会触发哪几个钩子？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DOM-渲染在-哪个周期中就已经完成？"><span class="nav-number">10.15.</span> <span class="nav-text">DOM 渲染在 哪个周期中就已经完成？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在哪个生命周期内调用异步请求"><span class="nav-number">10.16.</span> <span class="nav-text">在哪个生命周期内调用异步请求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#created-与-activated-有什么区别"><span class="nav-number">10.17.</span> <span class="nav-text">created 与 activated 有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#keep-alive-两个属性-gt-include、exclude-属性"><span class="nav-number">10.18.</span> <span class="nav-text">keep-alive 两个属性-&gt; include、exclude 属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-js-的两个核心是什么？"><span class="nav-number">10.19.</span> <span class="nav-text">vue.js 的两个核心是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#传参"><span class="nav-number">10.20.</span> <span class="nav-text">传参</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-model-的原理？"><span class="nav-number">10.21.</span> <span class="nav-text">v-model 的原理？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对-vue-的表单修饰符-lazy-的理解"><span class="nav-number">10.22.</span> <span class="nav-text">对 vue 的表单修饰符.lazy 的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-给组件绑定自定义事件无效怎么解决？"><span class="nav-number">10.23.</span> <span class="nav-text">vue 给组件绑定自定义事件无效怎么解决？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-的-sync-修饰符用法"><span class="nav-number">10.24.</span> <span class="nav-text">vue 的 sync 修饰符用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sync-和-v-model-的区别"><span class="nav-number">10.25.</span> <span class="nav-text">sync 和 v-model 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何在子组件中访问父组件的实例？"><span class="nav-number">10.26.</span> <span class="nav-text">如何在子组件中访问父组件的实例？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么父组件更新而子组件不更新"><span class="nav-number">10.27.</span> <span class="nav-text">为什么父组件更新而子组件不更新</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#视图不更新"><span class="nav-number">10.28.</span> <span class="nav-text">视图不更新</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nextTick-的内部实现原理"><span class="nav-number">10.29.</span> <span class="nav-text">nextTick 的内部实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-set-做了什么"><span class="nav-number">10.30.</span> <span class="nav-text">vue.set 做了什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#跳转页面三种方式"><span class="nav-number">10.31.</span> <span class="nav-text">跳转页面三种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#push-会保存在历史记录-replace-没有历史记录"><span class="nav-number">10.31.1.</span> <span class="nav-text">push 会保存在历史记录 replace 没有历史记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注：-query-和-params-都可以带参-但是！！"><span class="nav-number">10.31.2.</span> <span class="nav-text">注： query 和 params 都可以带参 但是！！</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#router-和-route-的区别"><span class="nav-number">10.32.</span> <span class="nav-text">$router 和 $route 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎么定义-vue-router-的动态路由-怎么获取传过来的值"><span class="nav-number">10.33.</span> <span class="nav-text">怎么定义 vue-router 的动态路由? 怎么获取传过来的值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-怎么去掉-url-中的"><span class="nav-number">10.34.</span> <span class="nav-text">vue 怎么去掉 url 中的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎么给-vue-定义全局的方法？"><span class="nav-number">10.35.</span> <span class="nav-text">怎么给 vue 定义全局的方法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-如果想扩展某个现有的组件时"><span class="nav-number">10.36.</span> <span class="nav-text">vue 如果想扩展某个现有的组件时</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-中怎么重置-data"><span class="nav-number">10.37.</span> <span class="nav-text">vue 中怎么重置 data</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-组件的-data-为什么必须是函数"><span class="nav-number">10.38.</span> <span class="nav-text">vue 组件的 data 为什么必须是函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-变量名如果以-、-开头的属性会发生什么问题"><span class="nav-number">10.39.</span> <span class="nav-text">vue 变量名如果以_、\$开头的属性会发生什么问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在使用计算属性的时，函数名和-data-数据源中的数据可以同名吗？"><span class="nav-number">10.40.</span> <span class="nav-text">在使用计算属性的时，函数名和 data 数据源中的数据可以同名吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#watch-和-computed-还有-methods-有什么区别？"><span class="nav-number">10.41.</span> <span class="nav-text">watch 和 computed 还有 methods 有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#watch-和-created-哪个先执行"><span class="nav-number">10.42.</span> <span class="nav-text">watch 和 created 哪个先执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#watch-如何创建时就立即执行"><span class="nav-number">10.43.</span> <span class="nav-text">watch 如何创建时就立即执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-中-mixins-和-extends-有什么区别？"><span class="nav-number">10.44.</span> <span class="nav-text">vue 中 mixins 和 extends 有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#extends-和-Vue-extend-Vue-component"><span class="nav-number">10.45.</span> <span class="nav-text">extends 和 Vue.extend,Vue.component</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-如何批量引入组件？"><span class="nav-number">10.46.</span> <span class="nav-text">vue 如何批量引入组件？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-动态组件使用方法"><span class="nav-number">10.47.</span> <span class="nav-text">vue 动态组件使用方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-项目如何引入异步组件？"><span class="nav-number">10.48.</span> <span class="nav-text">vue 项目如何引入异步组件？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎么解决-vue-动态设置-img-的-src-不生效的问题？"><span class="nav-number">10.49.</span> <span class="nav-text">怎么解决 vue 动态设置 img 的 src 不生效的问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-路由的钩子函数"><span class="nav-number">10.50.</span> <span class="nav-text">vue 路由的钩子函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#全局钩子"><span class="nav-number">10.50.1.</span> <span class="nav-text">全局钩子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#某个路由独享的钩子-beforeEnter"><span class="nav-number">10.50.2.</span> <span class="nav-text">某个路由独享的钩子 beforeEnter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组件内的守卫"><span class="nav-number">10.50.3.</span> <span class="nav-text">组件内的守卫</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-实现判断页面是否编辑及编辑页面未保存离开弹窗提示"><span class="nav-number">10.51.</span> <span class="nav-text">vue 实现判断页面是否编辑及编辑页面未保存离开弹窗提示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vuex"><span class="nav-number">10.52.</span> <span class="nav-text">vuex</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#五个核心"><span class="nav-number">10.52.1.</span> <span class="nav-text">五个核心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vuex-和单纯的全局对象有以下两点不同："><span class="nav-number">10.52.2.</span> <span class="nav-text">Vuex 和单纯的全局对象有以下两点不同：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#取值"><span class="nav-number">10.52.3.</span> <span class="nav-text">取值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么不在-data-中取-vuex-值？"><span class="nav-number">10.52.4.</span> <span class="nav-text">为什么不在 data 中取 vuex 值？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#辅助函数-mapState-mapGetters-mapMutations-mapActions"><span class="nav-number">10.52.5.</span> <span class="nav-text">辅助函数 mapState mapGetters mapMutations mapActions</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-observable-你有了解过吗"><span class="nav-number">10.53.</span> <span class="nav-text">Vue.observable 你有了解过吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-cli-如何新增自定义指令？"><span class="nav-number">10.54.</span> <span class="nav-text">vue-cli 如何新增自定义指令？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vue-几种常用的指令"><span class="nav-number">10.54.1.</span> <span class="nav-text">vue 几种常用的指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#监听多个事件"><span class="nav-number">10.55.</span> <span class="nav-text">监听多个事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-if-和-v-show-哪个优先级更高？"><span class="nav-number">10.56.</span> <span class="nav-text">v-if 和 v-show 哪个优先级更高？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-show-指令算是重排吗？"><span class="nav-number">10.57.</span> <span class="nav-text">v-show 指令算是重排吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-if-和-v-for-的优先级是什么？"><span class="nav-number">10.58.</span> <span class="nav-text">v-if 和 v-for 的优先级是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-for-如何倒序输出"><span class="nav-number">10.59.</span> <span class="nav-text">v-for 如何倒序输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-如何自定义一个过滤器？"><span class="nav-number">10.60.</span> <span class="nav-text">vue 如何自定义一个过滤器？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-怎么实现强制刷新组件？"><span class="nav-number">10.61.</span> <span class="nav-text">vue 怎么实现强制刷新组件？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#跟-keep-alive-有关的生命周期是哪些？描述下这些生命周期"><span class="nav-number">10.62.</span> <span class="nav-text">跟 keep-alive 有关的生命周期是哪些？描述下这些生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何在-keep-alive-缓存界面实时获取后台数据"><span class="nav-number">10.63.</span> <span class="nav-text">如何在 keep-alive 缓存界面实时获取后台数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#你知道-vue-中-key-的原理吗？说说你对它的理解"><span class="nav-number">10.64.</span> <span class="nav-text">你知道 vue 中 key 的原理吗？说说你对它的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-业务代码阐述"><span class="nav-number">10.65.</span> <span class="nav-text">vue 业务代码阐述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-等单页面应用及其优缺点"><span class="nav-number">10.66.</span> <span class="nav-text">vue 等单页面应用及其优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-vue-后怎么针对搜索引擎做-SEO-优化？"><span class="nav-number">10.67.</span> <span class="nav-text">使用 vue 后怎么针对搜索引擎做 SEO 优化？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解决-vue-首次白屏"><span class="nav-number">10.68.</span> <span class="nav-text">解决 vue 首次白屏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#优化性能"><span class="nav-number">10.69.</span> <span class="nav-text">优化性能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#懒加载怎么做"><span class="nav-number">10.69.1.</span> <span class="nav-text">懒加载怎么做</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ajax、fetch、axios-这三都有什么区别？"><span class="nav-number">10.70.</span> <span class="nav-text">ajax、fetch、axios 这三都有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何在全局使用-axios-的实例呢"><span class="nav-number">10.71.</span> <span class="nav-text">如何在全局使用 axios 的实例呢</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#axios-同时请求多个接口，如果当-token-过期时，怎么取消后面的请求？"><span class="nav-number">10.72.</span> <span class="nav-text">axios 同时请求多个接口，如果当 token 过期时，怎么取消后面的请求？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-为什么要求组件模板只能有一个根元素"><span class="nav-number">10.73.</span> <span class="nav-text">vue 为什么要求组件模板只能有一个根元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚拟-dom"><span class="nav-number">10.74.</span> <span class="nav-text">虚拟 dom</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#diff-算法"><span class="nav-number">10.75.</span> <span class="nav-text">diff 算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-文件中-style-是必须的吗？那-script-是必须的吗"><span class="nav-number">10.76.</span> <span class="nav-text">.vue 文件中 style 是必须的吗？那 script 是必须的吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-渲染模板时怎么保留模板中的-HTML-注释呢？"><span class="nav-number">10.77.</span> <span class="nav-text">vue 渲染模板时怎么保留模板中的 HTML 注释呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-项目本地开发完成后部署到服务器后报-404-或许是什么原因呢？"><span class="nav-number">10.78.</span> <span class="nav-text">vue 项目本地开发完成后部署到服务器后报 404 或许是什么原因呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#预渲染和-SSR-服务端渲染-有什么区别"><span class="nav-number">10.79.</span> <span class="nav-text">预渲染和 SSR(服务端渲染)有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#你有用过预渲染技术吗？怎么做的？"><span class="nav-number">10.80.</span> <span class="nav-text">你有用过预渲染技术吗？怎么做的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#说说你对-vue-的错误处理的了解？"><span class="nav-number">10.81.</span> <span class="nav-text">说说你对 vue 的错误处理的了解？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-版本以及御其他框架差异"><span class="nav-number">10.82.</span> <span class="nav-text">vue 版本以及御其他框架差异</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#你知道-vue2-0-兼容-IE-哪个版本以上吗？"><span class="nav-number">10.82.1.</span> <span class="nav-text">你知道 vue2.0 兼容 IE 哪个版本以上吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#你是从-vue-哪个版本开始用的？你知道-1-x-和-2-x-有什么区别吗？"><span class="nav-number">10.82.2.</span> <span class="nav-text">你是从 vue 哪个版本开始用的？你知道 1.x 和 2.x 有什么区别吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vue2-和-vue3-的区别"><span class="nav-number">10.82.3.</span> <span class="nav-text">vue2 和 vue3 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vue3-0-特性"><span class="nav-number">10.82.4.</span> <span class="nav-text">vue3.0 特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vue-与-React-的区别"><span class="nav-number">10.82.5.</span> <span class="nav-text">vue 与 React 的区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-说说-vue-的优缺点"><span class="nav-number">10.82.6.</span> <span class="nav-text">21.说说 vue 的优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么我们写组件的时候可以写在-vue-里呢？可以是别的文件名后缀吗？"><span class="nav-number">10.83.</span> <span class="nav-text">为什么我们写组件的时候可以写在.vue 里呢？可以是别的文件名后缀吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#你有看过-vue-推荐的风格指南吗？列举几条"><span class="nav-number">10.84.</span> <span class="nav-text">你有看过 vue 推荐的风格指南吗？列举几条</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现一个双向绑定的微型框架"><span class="nav-number">10.85.</span> <span class="nav-text">实现一个双向绑定的微型框架</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#小程序"><span class="nav-number">11.</span> <span class="nav-text">小程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#小程序自定义头部怎样设置"><span class="nav-number">11.1.</span> <span class="nav-text">小程序自定义头部怎样设置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件类型"><span class="nav-number">11.2.</span> <span class="nav-text">文件类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小程序与-vue-双向绑定哪里不一样"><span class="nav-number">11.3.</span> <span class="nav-text">小程序与 vue 双向绑定哪里不一样</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小程序传递数据的方法"><span class="nav-number">11.4.</span> <span class="nav-text">小程序传递数据的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小程序的生命周期函数"><span class="nav-number">11.5.</span> <span class="nav-text">小程序的生命周期函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小程序跳转页面的方式"><span class="nav-number">11.6.</span> <span class="nav-text">小程序跳转页面的方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小程序分包"><span class="nav-number">11.7.</span> <span class="nav-text">小程序分包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小程序用户标识"><span class="nav-number">11.8.</span> <span class="nav-text">小程序用户标识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小程序登陆流程"><span class="nav-number">11.9.</span> <span class="nav-text">小程序登陆流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#登陆失效"><span class="nav-number">11.10.</span> <span class="nav-text">登陆失效</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UnionID获取途径"><span class="nav-number">11.11.</span> <span class="nav-text">UnionID获取途径</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#webpack"><span class="nav-number">12.</span> <span class="nav-text">webpack</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#原理简介"><span class="nav-number">12.1.</span> <span class="nav-text">原理简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#核心概念"><span class="nav-number">12.2.</span> <span class="nav-text">核心概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是模块化"><span class="nav-number">12.3.</span> <span class="nav-text">什么是模块化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#webpack-的构建流程是什么"><span class="nav-number">12.4.</span> <span class="nav-text">webpack 的构建流程是什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎么配置单页应用？怎么配置多页应用？"><span class="nav-number">12.5.</span> <span class="nav-text">怎么配置单页应用？怎么配置多页应用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有哪些常见的-Loader？他们是解决什么问题的？"><span class="nav-number">12.6.</span> <span class="nav-text">有哪些常见的 Loader？他们是解决什么问题的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#打包优化"><span class="nav-number">12.7.</span> <span class="nav-text">打包优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#webpack-的-4-0-打包优化-更加高效"><span class="nav-number">12.8.</span> <span class="nav-text">webpack 的 4.0 打包优化 (更加高效)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎么解决-vue-打包后静态资源图片失效的问题？"><span class="nav-number">12.9.</span> <span class="nav-text">怎么解决 vue 打包后静态资源图片失效的问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#打包产生的页面缓存怎么办"><span class="nav-number">12.10.</span> <span class="nav-text">打包产生的页面缓存怎么办</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎么修改-vue-打包后生成文件路径"><span class="nav-number">12.11.</span> <span class="nav-text">怎么修改 vue 打包后生成文件路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#打包优化-1"><span class="nav-number">12.12.</span> <span class="nav-text">打包优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-loader-在-webpack-编译流程中的哪个阶段"><span class="nav-number">12.13.</span> <span class="nav-text">vue-loader 在 webpack 编译流程中的哪个阶段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有哪些常见的-Plugin-插件-他们是解决什么问题的？"><span class="nav-number">12.14.</span> <span class="nav-text">有哪些常见的 Plugin(插件)? 他们是解决什么问题的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#webpack-本地开发怎么解决跨域"><span class="nav-number">12.15.</span> <span class="nav-text">webpack 本地开发怎么解决跨域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dirname-和-的区别"><span class="nav-number">12.16.</span> <span class="nav-text">__dirname 和 ./ 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hash（散列函数"><span class="nav-number">12.17.</span> <span class="nav-text">Hash（散列函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Typescript"><span class="nav-number">13.</span> <span class="nav-text">Typescript</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#他解决了什么呢"><span class="nav-number">13.1.</span> <span class="nav-text">他解决了什么呢</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Typescript-有哪些基础类型？"><span class="nav-number">13.2.</span> <span class="nav-text">Typescript 有哪些基础类型？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NUXT"><span class="nav-number">13.3.</span> <span class="nav-text">NUXT</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#业务问题"><span class="nav-number">14.</span> <span class="nav-text">业务问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#权限设计"><span class="nav-number">14.1.</span> <span class="nav-text">权限设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#你现在做的项目最复杂功能有哪些"><span class="nav-number">14.2.</span> <span class="nav-text">你现在做的项目最复杂功能有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#大文件上传-如一个-G-的文件或者-500M-的文件"><span class="nav-number">14.3.</span> <span class="nav-text">大文件上传 如一个 G 的文件或者 500M 的文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WEB-前端实现在线预览、编辑-Office-文档"><span class="nav-number">14.4.</span> <span class="nav-text">WEB 前端实现在线预览、编辑 Office 文档</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更新项目版本后如何不强制刷新更新页面"><span class="nav-number">14.5.</span> <span class="nav-text">更新项目版本后如何不强制刷新更新页面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#开发中遇到的-bug-难点-怎么解决的"><span class="nav-number">14.6.</span> <span class="nav-text">开发中遇到的 bug,难点 怎么解决的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#前端大量数据检索-优化"><span class="nav-number">14.7.</span> <span class="nav-text">前端大量数据检索 优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何高性能的渲染十万条数据-虚拟列表"><span class="nav-number">14.8.</span> <span class="nav-text">如何高性能的渲染十万条数据(虚拟列表)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单点登录"><span class="nav-number">14.9.</span> <span class="nav-text">单点登录</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#手写算法题"><span class="nav-number">15.</span> <span class="nav-text">手写算法题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#当-for-嵌套这定时器"><span class="nav-number">15.1.</span> <span class="nav-text">当 for 嵌套这定时器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#amp-amp-和"><span class="nav-number">15.2.</span> <span class="nav-text">&amp;&amp; 和 ||</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象键名称只能是字符串"><span class="nav-number">15.3.</span> <span class="nav-text">对象键名称只能是字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高阶函数-fun"><span class="nav-number">15.4.</span> <span class="nav-text">高阶函数 fun()()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NaN"><span class="nav-number">15.5.</span> <span class="nav-text">NaN</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现一个-sleep-函数"><span class="nav-number">15.6.</span> <span class="nav-text">实现一个 sleep 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何让-a-1-amp-amp-a-2-amp-amp-a-3-判断成立"><span class="nav-number">15.7.</span> <span class="nav-text">如何让(a===1&amp;&amp;a===2&amp;&amp;a===3)判断成立</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>

 
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">candice</span>

   
</div>



<!-- 
  <div class="powered-by">footer.powered v3.7.1</div>

-->

<span class="post-meta-divider">The best preparation for tomorrow is doing your best today.</span>
<span>Hosted by
  <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a>
</span>


<!-- 
<div class="theme-info">主题 &mdash; 
  <a class="theme-link" target="_blank"  href="https://theme-next.org">NexT.Mist
  </a> v6.3.0
</div>
  -->
 







 
      </div>
    </footer>

    
    <div class="back-to-top"> 
      <i class="fa fa-arrow-up"></i>
      
    </div>
       
  </div> 

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

 


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>

   
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>

 


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>

 



  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  









 

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>




 
 
 
 
  
 
 
 
 
 

  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/love.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":100,"height":180},"mobile":{"show":true},"react":{"opacityDefault":1,"opacityOnHover":0.2}});</script></body>

</html>
