<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常用数据操作总结]]></title>
    <url>%2F2021%2F03%2F17%2F%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[检测是否在数据中存在some() 和 every() 的区别在于 every 是数组所有元素都需要通过测试才返回 true，而 some 只需要有一个通过测试就返回 true 对于放在空数组上的任何条件，此方法返回 false。 123456789101112131415/** * arr.some(callback,thisArg) * @param &#123;Function&#125; callback =&gt; 用来测试每个元素的函数 * @param &#123;Object&#125; thisArg =&gt; 可选参数，执行回调函数 mapFn 时 this 对象。 (可选) * * callback 被调用时会传入三个参数：当前元素值，元素的索引，原数组。 * * 返回值 * @param &#123;Boolean&#125; 为true时，有其中一个或多个元素是否都通过了指定函数的测试，否则就是没有通过 */const arr = [1, 2, 4, 2, 4, 56];console.log(arr.some((item) =&gt; item &lt; 10)); // truearr.some(() =&gt; &#123; return 1;&#125;); // true 检查数组的所有值是否相等12345678910const allEqual = arr =&gt; arr.every( v =&gt; v === arr[0] )allEqual( [1,1,1,1] ) // true// 或者：[1,1,1,1].every( (val, i, arr) =&gt; val === arr[0] ) // trueArray.prototype.every（来自MDN）：该every()方法测试数组中的所有元素是否通过提供的函数实现的测试。// 或者：!![1,1,1,1].reduce(function(a, b)&#123; return (a === b) ? a : NaN; &#125;); //true 判断数组中是否包含某个值123456789101112131415161718192021var arr = [1, 2, 3, 4];// 1.array.indexOf// 此方法判断数组中是否存在某个值，如果存在，则返回数组元素的下标，否则返回-1。var index = arr.indexOf(3); // index=2// 2.array.includes(searcElement[,fromIndex])// 此方法判断数组中是否存在某个值，如果存在返回true，否则返回falsevar index = arr.includes(3); // index=true// 3.array.find(callback[,thisArg])// 返回数组中满足条件的第一个元素的值，如果没有，返回undefinedvar result = arr.find((item) =&gt; &#123; return item &gt; 3;&#125;); //4// 4.array.findeIndex(callback[,thisArg])// 返回数组中满足条件的第一个元素的下标，如果没有找到，返回-1var result = arr.findIndex((item) =&gt; &#123; return item &gt; 3;&#125;); //3 去重数组去重-Set() new Map()通过 filter 过滤 1234function unique(arr) &#123; const res = new Map(); return arr.filter((a) =&gt; !res.has(a) &amp;&amp; res.set(a, 1));&#125; new Set()数据类型 可以存储任何数据类型,并且是唯一的(不重复的值)再通过 Array.from()转化成数组类型 1234function dedupe(array) &#123; return Array.from(new Set(array));&#125;dedupe([1, 1, 2, 3]); // [1, 2, 3] 数组对象去重-redecu()12345678910111213141516171819202122232425262728let hash = &#123;&#125;;let config = [ &#123; name: 2, state: true, output: "Y", &#125;, &#123; name: 3, state: true, output: "A", &#125;, &#123; name: 3, state: true, output: "S", &#125;, &#123; name: 7, state: true, output: "B", &#125;,];const newArr = config.reduceRight((item, next) =&gt; &#123; hash[next.name] ? "" : (hash[next.name] = true &amp;&amp; item.push(next)); return item;&#125;, []);console.log(JSON.stringify(newArr)); 对象循环操作123Object.keys(object).forEach((x) =&gt; &#123; //object[x] 做操作&#125;); 一个判断的写法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950list?.map((item) =&gt; &#123; item.edit = false return item &#125;) ?? []// 或者这种情况this.searchList = searchListData?.list ?? []```# 数组对象内 id 重复的合并其下属性```javascript/** * 使用场景针对性较强 注意变通 * resourceCode重复的合并其下insuredLands */let arr = [ &#123; resourceCode: "RESb4dd24f2bb9a490a82f28213f063ccb3", insuredLands: "150000,210000", &#125;, &#123; resourceCode: "RESb4dd24f2bb9a490a82f28213f063ccb3", insuredLands: "210000,330000", &#125;, &#123; resourceCode: "RESdecbbef35c0c4d3b8af0522a192feaab", insuredLands: "330000,360000", &#125;,];arr.reduce((res, item) =&gt; &#123; const resourceCode = item.resourceCode; const isHas = res.get(resourceCode); res.set( resourceCode, isHas ? &#123; resourceCode, insuredLands: [ ...new Set([ ...isHas.insuredLands.split(","), ...item.insuredLands.split(","), ]), ].join(","), &#125; : item ); return res;&#125;, new Map()); 数组累加-redecu()123456let log = console.log.bind(console);let arr = [1, 2, 3, 4, 5, 6];arr = arr.reduce((previousValue, currentValue) =&gt; &#123; return previousValue + currentValue; //返回的是最后一次调用回调函数的值，15+6；&#125;);log(arr); // 21 通过比较函数对数组对象的排序1234567const people = [ &#123; name: "gating", age: 18 &#125;, &#123; name: "family", age: 16 &#125;, &#123; name: "blue", age: 21 &#125;,];people.sort((a, b) =&gt; a.age - b.age);// [&#123;name:'family',age:16&#125;,&#123;name:'gating',age:18&#125;,&#123;name:'blue',age:21&#125;] 生成一个限制长度的二维数组-slice()123456789101112131415161718192021/** * 返回一个根据subArrayNum的二维数组 * @param &#123;Array&#125; arr =&gt; 一维数组 * @param &#123;Number&#125; subArrayNum =&gt; 每组元素的个数 */const chunk = (arr, subArrayNum) =&gt; &#123; const result = []; for (let i = 0; i &lt; arr.length; i += subArrayNum) &#123; result.push(arr.slice(i, i + subArrayNum)); &#125; return result;&#125;;console.log(chunk([1, 2, 3, 4], 2)); // [[1,2], [3,4]]/** * 创建一个数组切片， 从array数组的起始元素开始提取n个元素。 * @param &#123;Array&#125; arr =&gt; 要检索的数组 * @param &#123;Number&#125; n =&gt; 要提取的元素个数 */const take = (arr, n) =&gt; arr.slice(0, n ? n : 1);console.log(take([1, 2, 3, 4], 2)); // [1, 2] 扁平化多维数组扁平化多维数组-redecu()1234567891011121314151617181920/** * 多维数组变成一维数组 * @param &#123;Array&#125; arr =&gt; 数组 * @param &#123;Boolean&#125; shallow =&gt; 数组将只减少一维的嵌套 */const flatten = (arr, shallow) =&gt; &#123; if (shallow) &#123; var arr = arr.reduce((arr, val) =&gt; arr.concat(val), []); //只能降二维数组 &#125; else &#123; var arr = arr.reduce( (arr, val) =&gt; arr.concat(Array.isArray(val) ? flatten(val) : val), [] ); //可降多维数组 &#125; return arr;&#125;;const arr = [1, [2, [3, 4]], 5];console.log(flatten(arr, true)); // [1, 2, [3,4], 5]console.log(flatten(arr)); // [1, 2, 3, 4, 5] 扁平化多维数组-flat(Infinity)12345678910111213141516171819/** * flat() 方法会移除数组中的空项 * 传Infinity参数 可降多维数组 */var arr1 = [1, 2, [3, 4]];arr1.flat();// [1, 2, 3, 4]var arr2 = [1, 2, [3, 4, [5, 6]]];arr2.flat();// [1, 2, 3, 4, [5, 6]]var arr3 = [1, 2, [3, 4, [5, 6]]];arr3.flat(2);// [1, 2, 3, 4, 5, 6]//使用 Infinity 作为深度，展开任意深度的嵌套数组arr3.flat(Infinity);// [1, 2, 3, 4, 5, 6] 根据指定字段大小排序数组排序就 arr.sort()如果有个班级的 json 数据 名字年龄邮箱等 现在需要根据年龄排序 age 我们就要做一些处理了 1234567891011121314151617181920//排序方法var compare = function (prop) &#123; return function (obj1, obj2) &#123; var val1 = obj1[prop]; var val2 = obj2[prop]; if (!isNaN(Number(val1)) &amp;&amp; !isNaN(Number(val2))) &#123; val1 = Number(val1); val2 = Number(val2); &#125; if (val1 &lt; val2) &#123; return -1; &#125; else if (val1 &gt; val2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;&#125;调用 data.sort(compare("age")) sort 排序1234567function sortObj(arr, key) &#123; return arr.sort(function (m, n) &#123; var key1 = m[key]; var key2 = n[key]; return key2 - key1; &#125;);&#125; 取数组交集1234let arr4 = [1, 2, 3, "3", NaN];let arr5 = [3, 4, 5, "3", NaN];const intersection = arr4.filter((item) =&gt; arr5.includes(item));console.log(intersection); 取数组差集1234const difference = [...arr4, ...arr5].filter( (item) =&gt; !arr4.includes(item) || !arr5.includes(item));console.log(difference); 获取数组最大值123function getMax(arr) &#123; return Math.max.apply(null, arr);&#125; 获取数组最小值123function getMax(arr) &#123; return Math.max.apply(null, arr);&#125; 统计重复次数和值123456789101112131415161718192021222324function countNum(arr) &#123; var max = 0; var value = []; var obj = arr.reduce(function (obj, key) &#123; key in obj ? obj[key]++ : (obj[key] = 1); return obj; &#125;, &#123;&#125;); for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; max = Math.max(max, obj[key]); &#125; &#125; for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; if (obj[key] == max) &#123; value.push(key); &#125; &#125; &#125; return &#123; max, value, &#125;;&#125; 统计重复次数和值(map 实现版,避免了 obj 键为字符串的尴尬)1234567891011121314151617181920function countNum(arr) &#123; var map = arr.reduce(function (m, x) &#123; return m.set(x, (m.get(x) || 0) + 1); &#125;, new Map()); var res = []; var value = []; for (let [k, v] of map) &#123; res.push(v); &#125; for (let [k, v] of map) &#123; if (map.get(k) == getMax(res)) &#123; value.push(k); &#125; &#125; return &#123; max: getMax(res), value: value, &#125;;&#125; 返回乱序的数组12345function shuffle(arr) &#123; return arr.sort(function () &#123; return Math.random() - 0.5; &#125;);&#125; 循环数组forEach 方法中的 function 回调支持 3 个参数，第 1 个是遍历的数组内容；第 2 个是对应的数组索引，第 3 个是数组本身。12345678[].forEach(function(value, index, array) &#123; // ...&#125;);对比jQuery中的$.each方法：$.each([], function(index, value, array) &#123; // ...&#125;); map 方法的作用不难理解，“映射”嘛，也就是原数组被“映射”成对应新数组。下面这个例子是数值项求平方：123456789var data = [1, 2, 3, 4];var arrayOfSquares = data.map(function (item) &#123; return item * item;&#125;);alert(arrayOfSquares); // 1, 4, 9, 16需要有return值，如果没有，数组所有项都会被映射成undefined filter 为“过滤”、“筛选”之意。指数组 filter 后，返回过滤后的新数组。用法跟 map 极为相似：1234567var data = [0, 1, 2, 3];var arrayFilter = data.filter(function(item) &#123; return item;&#125;);console.log(arrayFilter); // [1, 2, 3]filter的callback函数需要返回布尔值true或false. 如果为true则表示通过！如果为false就被过滤掉。]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组的方法的总结和使用]]></title>
    <url>%2F2021%2F03%2F16%2F2018-12-25-%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言JavaScript 中的数组是一个很特别的存在，他不像Java ，专门搞了 List 这样的一整套的东西，JS终端数组完全可以当作栈或队列来使用，数组的四大操作：pop、push、shift、unshift。 我今天写这篇博客，主要是写一篇总结，以备以后查看。 对于数组方法，我们应该关心的只有两个问题，返回值是什么,会不会修改原数组，典型的例子就是 splice() 和 slice() 这两个方法。 接下来，带着这两个问题，我会相对详细的总结一下我们数组原型（数组实例）里面所拥有的方法和属性，另外，常用的方法，我会加上一个常用的例子（应用场景） ps: 文中有些和数组方法不是太相关的知识，仅供了解，这里就不展开了（实际上也是我太垃圾了0 0，不懂） 具体我会在文末放上相关链接 下面将不再重复这些方法的 callbak 的参数 （find、findIndex、some、filter、every、map，forEach）的callback 被调用时会传入三个参数：当前元素值，元素的索引，原数组。这些方法都不会改变元素组，但是，如果你操作第三个参数，那就不一样了。 数组的属性lengthlength 是Array的实例属性。返回或设置一个数组中的元素个数。该值是一个无符号 32-bit 整数，并且总是大于数组最高项的下标。 12let arr = [1,2,3]console.log(arr.length) // 3 length 属性的值是一个 0 到 232-1 的整数。 1234567let arr1 = new Array(4294967296) // 2的32次方 = 4294967296 // Uncaught RangeError: Invalid array length无效的数组长度console.log(arr1)let arr2 = new Array(-100) // 负号// Uncaught RangeError: Invalid array length无效的数组长度console.log(arr1) 你还可以通过 length 来截断数组 123let arr = [1,2,3,4]arr.length = 2console.log(arr) // [1,2] Array.length 属性的属性特性 属性 值 writable true enumerable false configurable false Writable ：如果设置为false，该属性值将不能被修改。 Configurable ：如果设置为false，删除或更改任何属性都将会失败。 Enumerable ：如果设置为 true ，属性可以通过迭代器for或for…in进行迭代。 看到这里，估计有人想问，既然 length 属性是可以修改的，那么我们可不可以重定义数组对象的 length 属性呢？答案是可以的，但是会受到一般的重定义限制。并且并不是所有浏览器都允许 Array.length 的重定义。这里就不展开了，如有兴趣请看文末的链接 数组的静态方法Array.isArray()在这个方法没出来之前，很多早期类库是通过下列代码来判断的（鸭子判断），文末送上玉伯大佬的链接，希望大家都去了解一下 1234function isArray(object) &#123; return object != null &amp;&amp; typeof object === "object" &amp;&amp; 'splice' in object &amp;&amp; 'join' in object&#125; 直到后来有神人出山，写出了一段神码，此代码一出，天下震惊，引各路类库竞折腰。这代码，不不仅仅解决了数组的问题，而是解决了 isXxx 一类问题。 123function isArray(obj) &#123; return Object.prototype.toString.call(obj) === "[object Array]"&#125; 对现代浏览器来说，上面的写法，依旧让各大浏览器引擎的实现者觉得很难受，于是直接有了Array.isArray方法 12345678910/** * Array.isArray(obj) * @param &#123;Object&#125; obj =&gt; 需要检测的值 * ---------------------------------------------- * 返回值 * @param &#123;Boolean&#125; 如果对象是 Array， 则为true;否则为false。 */ Array.isArray([]) // true // 鲜为人知的事实：其实 Array.prototype 也是一个数组。Array.isArray(Array.prototype) // true Array.from()Array.from() 方法从一个类似数组或可迭代对象中创建一个新的数组实例 12345678910111213141516/** * Array.from(arrayLike,mapFn,thisArg) * @param &#123;Integer&#125; arrayLike =&gt; 想要转换成数组的伪数组对象或可迭代对象。 * @param &#123;Function&#125; mapFn =&gt; 如果指定了该参数，新数组中的每个元素会执行该回调函数。 (可选) * @param &#123;Object&#125; thisArg =&gt; 可选参数，执行回调函数 mapFn 时 this 对象。 (可选) * ---------------------------------------------- * 返回值 * @Array 一个新的数组实例 */console.log(Array.from('foo')) // ["f", "o", "o"]console.log(Array.from([1, 2, 3], x =&gt; x + x)) // [2,4,6]Array.from([1],function(x)&#123; console.log(this) // &#123;a: 1&#125; return x&#125;,&#123;a:1&#125;) 实际上，通过 Array.from 我们就可以做一些很常见的事了，比如我们的数组去重合并 123456const combine = (...arg)=&gt;&#123; let arr = [].concat.apply([], arg); return Array.from(new Set(arr));&#125;let m = [1, 2, 2], n = [2,3,3,4]; console.log(combine(m,n)) // [1, 2, 3, 4]; Array.of()Array.of() 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。 Array.of() 和 Array 构造函数之间的区别在于处理整数参数：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个长度为7的空数组（注意：这是指一个有7个空位的数组，而不是由7个undefined组成的数组）。 123456789101112/** * Array.of(elementN) * @param &#123;*&#125; elementN =&gt; 任意个参数，将按顺序成为返回数组中的元素。 * ---------------------------------------------- * 返回值 * @param &#123;Array&#125; 新的 Array 实例。 */Array.of(7); // [7] Array.of(1, 2, 3); // [1, 2, 3]Array(7); // [ , , , , , , ]Array(1, 2, 3); // [1, 2, 3] 拷贝填充相关concatconcat() 方法用于合并两个或多个数组。此方法不会更改原数组，而是返回一个新数组。 有个降维的例子会在 reduce() ，这里就不过讲解了，避免重复 12345678910111213/** * old_array.concat(valueN]) * @param &#123;*&#125; valueN =&gt; 将数组和/或值连接成新数组。详情请参阅下文描述。 * * 返回值 * @param &#123;Array&#125; 新的 Array 实例 * */let arr1 = [1,2,3]let arr2 = [4,5,6]console.log(arr1.concat(arr2)) // [1,2,3,4,5,6]console.log(arr1) // [1,2,3]console.log(arr2) // [4,5,6] 实际应用中，我们可以用 concat 和 reduce 搭配，实现扁平化数组(降维) 1234567891011121314151617/** * 多维数组变成一维数组 * @param &#123;Array&#125; arr =&gt; 数组 * @param &#123;Boolean&#125; shallow =&gt; 数组将只减少一维的嵌套 */const flatten = (arr, shallow) =&gt; &#123; if (shallow) &#123; var arr = arr.reduce((arr, val) =&gt; arr.concat(val), []) &#125; else &#123; var arr = arr.reduce((arr, val) =&gt; arr.concat(Array.isArray(val) ? flatten(val) : val), []) &#125; return arr&#125;const arr = [1,[2,[3,4]],5]console.log(flatten(arr,true)) // [1, 2, [3,4], 5]console.log(flatten(arr)) // [1, 2, 3, 4, 5] copyWithincopyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，而不修改其大小。此方法会更改现有数组 ps：参数target,start和end 必须为整数。如果start为负，则其指定的索引位置等同于length+start，length为数组的长度。end也是如此。(copyWithin,fill等方法的start、end参数同理) 12345678910111213141516171819/** * arr.copyWithin(target,start,end) * @param &#123;Number&#125; target =&gt; 0 为基底的索引，复制序列到该位置。如果是负数，target 将从末尾开始计算。如果 target 大于等于 arr.length，将会不发生拷贝。如果 target 在 start 之后，复制的序列将被修改以符合 arr.length。 * @param &#123;Number&#125; start =&gt; 0 为基底的索引，开始复制元素的起始位置。如果是负数，start 将从末尾开始计算如果 start 被忽略，copyWithin 将会从0开始复制 (可选) * @param &#123;Number&#125; end =&gt; 0 为基底的索引，开始复制元素的结束位置。copyWithin 将会拷贝到该位置，但不包括 end 这个位置的元素。如果是负数， end 将从末尾开始计算。如果 end 被忽略，copyWithin 将会复制到 arr.length (可选) * * 返回值 * @param &#123;Array&#125; 改变了的数组 * */let arr = [1,2,3,4,5]console.log(arr.copyWithin(0, 3, 4)) // [4, 2, 3, 4, 5]console.log(arr) // [4, 2, 3, 4, 5]// -2表示复制到 ([1, 2, 3, 4, 5].length - 2) 的位置去，这里指3console.log([1, 2, 3, 4, 5].copyWithin(-2)) // [1, 2, 3, 1, 2]console.log([1, 2, 3, 4, 5].copyWithin(0, 3)) // [4, 5, 3, 4, 5]console.log([1, 2, 3, 4, 5].copyWithin(-2, -3, -1)) // [1, 2, 3, 3, 4] fillfill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。此方法会更改现有数组 1234567891011121314151617/** * arr.fill(value,start,end) * @param &#123;*&#125; value =&gt; 用来填充数组元素的值。 * @param &#123;Number&#125; start =&gt; 起始索引，默认值为0。(可选) * @param &#123;Number&#125; end =&gt; 起始索引，默认值为this.length。(可选) * * 返回值 * @param &#123;Array&#125; 修改后的数组 * */let arr = [1,2,3,4]console.log(arr.fill(0, 2, 4)) // [1, 2, 0, 0]console.log([1, 2, 3].fill(4)) // [4,4,4]console.log([1, 2, 3].fill(4,1)) // [1,4,4]// 这里的-1实际上就是 (-1+3) 也就是 2console.log([1, 2, 3].fill(4,-1)) // [1,2,4]console.log([1, 2, 3].fill(4,-2,-1)) // [1,4,3] 搜索查找相关findfind() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。 12345678910111213/** * arr.find(callback,thisArg) * @param &#123;Function&#125; callback =&gt; 用来测试每个元素的函数 * @param &#123;Object&#125; thisArg =&gt; 可选参数，执行回调函数 mapFn 时 this 对象。 (可选) * * callback 被调用时会传入三个参数：当前元素值，元素的索引，原数组。 * * 返回值 * @param &#123;*&#125; 当某个元素通过 callback 的测试时，返回数组中最先通过的值，否则返回 undefined*/const arr = [1,2,3,4]console.log(arr.find(item=&gt;item&gt;2)) // 3console.log(arr.find(item=&gt;item&gt;6)) // undefined 实际应用场景中，我们可以用对象的属性查找数组里的对象 123456789101112const people = [&#123; name:'gating', age:18&#125;,&#123; name:'blue', age:15&#125;,&#123; name:'family', age:18&#125;]const findName = (arr) =&gt; arr.name === 'gating';console.log(people.find(findName)) // &#123;name: "gating", age: 18&#125; findIndexfindIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。 12345678910111213/** * arr.findIndex(callback,thisArg) * @param &#123;Function&#125; callback =&gt; 用来测试每个元素的函数 * @param &#123;Object&#125; thisArg =&gt; 可选参数，执行回调函数 mapFn 时 this 对象。 (可选) * * callback 被调用时会传入三个参数：当前元素值，元素的索引，原数组。 * * 返回值 * @param &#123;Number&#125; 当某个元素通过 callback 的测试时，返回数组中最先通过的值的索引值，否则返回 -1*/const arr = [1,2,3,4]console.log(arr.findIndex(item=&gt;item&gt;2)) // 2console.log(arr.findIndex(item=&gt;item&gt;6)) // -1 实际应用场景同 find() ,这里就不重复了 indexOfindexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 indexOf 和 lastIndexOf 都是使用 === 来进行判断 12345678910111213/** * arr.indexOf(searchElement,fromIndex) * @param &#123;*&#125; searchElement =&gt; 要查找的元素 * @param &#123;Number&#125; fromIndex =&gt; 开始查找的位置。如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1。如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即-1表示从最后一个元素开始查找，-2表示从倒数第二个元素开始查找 ，以此类推。 注意：如果参数中提供的索引值是一个负值，并不改变其查找顺序，查找顺序仍然是从前向后查询数组。如果抵消后的索引值仍小于0，则整个数组都将会被查询。其默认值为0. (可选) * * 返回值 * @param &#123;Number&#125; 首个被找到的元素在数组中的索引位置; 若没有找到则返回 -1*/const arr = ['a','b','c','a']console.log(arr.indexOf('a')) // 0console.log(arr.indexOf('a',-1)) // 3console.log(arr.indexOf('d')) // -1 实际应用场景中，我们不可能之只找出一个同名元素的索引值，我们可能需要找出同名的元素的所有位置，于是乎 123456789101112// 存放索引的数组const indices = [];const arr = ['a','b','c','a']// 要查找的元素const searchElement = 'a'// 当前的索引let idx = arr.indexOf(searchElement);while (idx != -1) &#123; indices.push(idx); idx = arr.indexOf(searchElement, idx + 1);&#125;console.log(indices) // [0, 3] lastIndexOflastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。 12345678910111213/** * arr.lastIndexOf(searchElement,fromIndex = arr.length - 1) * @param &#123;*&#125; searchElement =&gt; 要查找的元素 * @param &#123;Number&#125; fromIndex =&gt; 从此位置开始逆向查找。默认为数组的长度减 1，即整个数组都被查找。如果该值大于或等于数组的长度，则整个数组会被查找。如果为负值，将其视为从数组末尾向前的偏移。即使该值为负，数组仍然会被从后向前查找。如果该值为负时，其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。 (可选) * * 返回值 * @param &#123;Number&#125; 数组中最后一个元素的索引，如未找到返回-1*/const arr = ['a','b','c','a']console.log(arr.lastIndexOf('a')) // 0console.log(arr.lastIndexOf('a',-1)) // 3console.log(arr.lastIndexOf('d')) // -1 实例：查找所有元素 1234567891011const indices = []const array = ['a', 'b', 'a', 'c', 'a', 'd']const element = 'a'let idx = array.lastIndexOf(element)while (idx != -1) &#123; indices.push(idx); idx = (idx &gt; 0 ? array.lastIndexOf(element, idx - 1) : -1);&#125;console.log(indices) // [4, 2, 0]; 注意，我们要单独处理idx==0时的情况，因为如果是第一个元素，忽略了fromIndex参数则第一个元素总会被查找。这不同于indexOf方法 includesincludes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。 如果fromIndex 大于等于数组长度 ，则返回 false 。该数组不会被搜索 如果 fromIndex 为负值，计算出的索引将作为开始搜索searchElement的位置。如果计算出的索引小于 0，则整个数组都会被搜索。 1234567891011/** * arr.includes(searchElement,fromIndex = 0) * @param &#123;*&#125; searchElement =&gt; 要查找的元素 * @param &#123;Number&#125; fromIndex =&gt; 从该索引处开始查找 searchElement。如果为负值，则按升序从 array.length - fromIndex 的索引开始搜索。默认为 0。 (可选) * * 返回值 * @param &#123;Boolean&#125; 一个 Boolean 值*/const arr = [1,2,3,NaN]console.log(arr.includes(1, -100)) // trueconsole.log(arr.includes(1, 5)) // false 实际的应用场景，通过可以解决我们找出两个数组的 数组交集 和 数组差集 123456789// 数组交集const intersection = (arr1, arr2) =&gt; arr1.filter(v =&gt; arr2.includes(v))// 数组差集const difference = (arr1, arr2) =&gt; [...arr1, ...arr2].filter(v =&gt; !arr1.includes(v) || !arr2.includes(v))const arr1 = [1,2,3]const arr2 = [2,3,4]console.log(intersection(arr1,arr2)) // [2, 3]console.log(difference(arr1,arr2)) // [1, 4] 操作相关sliceslice() 方法返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝。此方法不会更改原数组。 12345678910111213141516/** * Array.slice(begin,end) * @param &#123;Number&#125; begin =&gt; 从该索引处开始提取原数组中的元素（从0开始）。（可选） * @param &#123;Number&#125; end =&gt; 在该索引处结束提取原数组元素（从0开始）。slice会提取原数组中索引从 begin 到 end 的所有元素（包含begin，但不包含end）。（可选） * ---------------------------------------------- * 返回值 * @param &#123;Array&#125; 一个含有提取元素的新数组 */const arr = [1,2,3,4,5]console.log(arr.slice()) // [1,2,3,4,5]console.log(arr.slice(2)) // [3,4,5]console.log(arr.slice(2, 4)) // [3,4]// -1表示复制到 ([1, 2, 3, 4, 5].length - 1) 的位置去，这里指4console.log(arr.slice(-1)) // [5]console.log(arr.slice(-2,-1)) // [4] 实际应用中，slice 就可以做很多事情啦，比如说，我们的数组切割或者生成二维数组 123456789101112131415161718192021/** * 返回一个根据subArrayNum的二维数组 * @param &#123;Array&#125; arr =&gt; 一维数组 * @param &#123;Number&#125; subArrayNum =&gt; 每组元素的个数 */const chunk = (arr, subArrayNum) =&gt; &#123; const result = []; for (let i = 0; i &lt; arr.length; i += subArrayNum) &#123; result.push(arr.slice(i, i + subArrayNum)); &#125; return result;&#125;console.log(chunk([1,2,3,4],2)) // [[1,2], [3,4]]/** * 创建一个数组切片， 从array数组的起始元素开始提取n个元素。 * @param &#123;Array&#125; arr =&gt; 要检索的数组 * @param &#123;Number&#125; n =&gt; 要提取的元素个数 */const take = (arr, n) =&gt; arr.slice(0, n ? n : 1)console.log(take([1,2,3,4],2)) // [1, 2] splicesplice()方法通过删除现有元素和/或添加新元素来修改数组,并以数组返回原数组中被修改的内容。此方法会更改现有数组。 123456789101112131415161718192021222324252627282930/** * Array.splice(start,deleteCount,itemN) * @param &#123;Number&#125; start =&gt; 指定修改的开始位置（从0计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始的第几位（从-1计数）；如果负数的绝对值大于数组的长度，则表示开始位置为第0位。 * @param &#123;Int&#125; deleteCount =&gt; 整数，表示要移除的数组元素的个数。如果deleteCount被省略，则其相当于(arr.length - start)。（可选） * @param &#123;*&#125; itemN =&gt; 要添加进数组的元素,从start 位置开始。如果不指定，则 splice() 将只删除数组元素。（可选） * ---------------------------------------------- * 返回值 * @param &#123;Array&#125; 由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。 */const arr = [1,3]const res = arr.splice(1, 0, 2)console.log(arr) // [1,2,3]console.log(res) // []const result = arr.splice(2, 1)console.log(arr) // [1,2]console.log(result) // [3]// -1表示复制到 ([1,2].length - 1) 的位置去，这里指1arr.splice(-1, 1)console.log(arr) // [1]// 只有一个参数时 fruits.splice(2) 相当于 fruits.splice(2,fruits.length-1)const fruits = ['apple','banana','orange','pear']const res1 = fruits.splice(2)console.log(fruits) // ["apple", "banana"]console.log(res1) // ["orange", "pear"] 因为 js 中只有 splice 这个方法删除数组元素，并且会修改数组长度，所以他的实际应用场景还挺多的0 0，但是我没有太好的例子可以距离 pushpush() 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。 此方法会更改现有数组。 1234567891011/** * Array.push(elementN) * @param &#123;*&#125; elementN =&gt; 被添加到数组末尾的元素。 * ---------------------------------------------- * 返回值 * @param &#123;Number&#125; 当调用该方法时，新的 length 属性值将被返回。 */const arr = [1,2,3]console.log(arr.push(4)) // 4console.log(arr) // [1,2,3,4] push、pop、shift、unshift 方法有意具有通用性。该方法和 call() 或 apply() 一起使用时，可应用在类似数组的对象上。这个比较有意义，所以单独在这里送上MDN的链接，当然例子也是MDN的O(∩_∩)O 像数组一样使用对象这个例子 push、pop、shift、unshift 四个方法写法很类似，这里就重复写了 1234567891011121314151617181920212223242526272829// 合并两个数组var vegetables = ['parsnip', 'potato']var moreVegs = ['celery', 'beetroot']// 将第二个数组融合进第一个数组// 相当于 vegetables.push('celery', 'beetroot')Array.prototype.push.apply(vegetables, moreVegs)console.log(vegetables) // ['parsnip', 'potato', 'celery', 'beetroot']// 像数组一样使用对象var obj = &#123; length: 0, addElem: function addElem (elem) &#123; // obj.length is automatically incremented // every time an element is added. [].push.call(this, elem); &#125;, popElem: function addElem () &#123; // obj.length is automatically incremented // every time an element is added. return [].pop.call(this); &#125;&#125;obj.addElem(&#123;&#125;)obj.addElem(&#123;a:1&#125;)console.log(obj.length) // 2console.log(obj.popElem()) // &#123;a: 1&#125;console.log(obj.length) // 1 poppop()方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。此方法会更改现有数组。 如果你在一个空数组上调用 pop()，它返回 undefined。 123456789/** * Array.pop() * ---------------------------------------------- * 返回值 * @param &#123;*&#125; 从数组中删除的元素(当数组为空时返回undefined)。 */const arr = [1,2,3]console.log(arr.pop()) // 3console.log(arr) // [1,2] shiftshift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。此方法会更改现有数组。 123456789/** * Array.shift() * ---------------------------------------------- * 返回值 * @param &#123;*&#125; 从数组中删除的元素(当数组为空时返回undefined)。 */const arr = [1,2,3]console.log(arr.shift()) // 1console.log(arr) // [2,3] unshiftunshift() 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度。此方法会更改现有数组。 12345678910/** * Array.unshift(elementN) * @param &#123;*&#125; elementN =&gt; 要添加到数组开头的元素。 * ---------------------------------------------- * 返回值 * @param &#123;Number&#125; 当一个对象调用该方法时，返回其 length 属性值。 */const arr = [3,4,5]console.log(arr.unshift(1,2)) // 5console.log(arr) // [1,2,3,4,5] 但实际上，我们不建议用 unshift 方法往前面添加元素，为什么呢？从原理就可以知道，unshift()的效率是较低的。原因是，它每添加一个元素，都要把现有元素往下移一个位置。 下面我们简单测试一下，unshift 和 push 的性能区别 1234567891011121314151617console.time('unshift所用时间')const unshift = []for (let i = 0; i &lt; 10000; i++) &#123; unshift.unshift(i)&#125;console.timeEnd('unshift所用时间')console.time('push所用时间')const push = []for (let i = 0; i &lt; 10000; i++) &#123; push.push(i)&#125;console.timeEnd('push所用时间')console.time('reverse所用时间')push.reverse(); console.timeEnd('reverse所用时间') 大家可是复制一下这段代码，在我们数据量不是特别大的时候，他们的效率差别几十倍，因此，平时还是要慎用unshift()，特别是对大数组。此方法会更改现有数组。 但是我们可以通过 reverse 和 push 的方法实现我们 unshift ，比如 123456789const arr = [3,4,5]console.log(arr.unshift(1,2)) // 5console.log(arr) // [1,2,3,4,5]const arr2 = [3,4,5]// 从前一个代码知道reverse的性能也很快arr2.reverse().push(2,1)arr2.reverse()console.log(arr2) // [1,2,3,4,5] sortsort() 方法用原地算法对数组的元素进行排序，并返回数组。排序算法现在是稳定的。默认排序顺序是根据字符串Unicode码点。此方法会更改现有数组。 12345678910/** * Array.sort(compareFunction) * @param &#123;*&#125; compareFunction =&gt; 用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。(可选) * ---------------------------------------------- * 返回值 * @param &#123;Array&#125; 排序后的数组。请注意，数组已原地排序，并且不进行复制。 */const months = ['March', 'Jan', 'Feb', 'Dec'];months.sort() console.log(months) // ["Dec", "Feb", "Jan", "March"] 如果没有指明 compareFunction ，那么元素会按照转换为的字符串的诸个字符的Unicode位点进行排序。例如 “Banana” 会被排列到 “cherry” 之前。当数字按由小到大排序时，9 出现在 80 之前，但因为（没有指明 compareFunction），比较的数字会先被转换为字符串，所以在Unicode顺序上 “80” 要比 “9” 要靠前。 所以我们怎么解决这个问题了，当然要使用我们的比较函数啦，而且通过我们的比较函数，可以实现很多我们需要的效果 1234567891011121314const arr = ["1",2,"11",3,"21"]console.log(arr.sort()) // ["1", "11", 2, "21", 3]// 通过比较函数解决该问题console.log(arr.sort((a,b)=&gt;a-b)) // ["1", 2, 3, "11", "21"]// 再比如，我们可以通过比较函数实现对数组对象的排序const people = [&#123;name:'gating',age:18&#125;,&#123;name:'family',age:16&#125;,&#123;name:'blue',age:21&#125;]people.sort((a,b)=&gt;a.age - b.age) // [&#123;name:'family',age:16&#125;,&#123;name:'gating',age:18&#125;,&#123;name:'blue',age:21&#125;]// 当然，通过 sort + Math.random 可以很巧妙的实现数组洗牌（数组乱序）的算法（当然，这个也是不推荐的，不过他可以用在小项目中，当作一个小技巧）const numbers = [1,2,3]numbers.sort(()=&gt;Math.random()-0.5) // 多尝试几次，看看每次出来的结果是不是不一样的 关于数组乱序，正确的解法应该是 Fisher–Yates Shuffle，复杂度 O(n)。其实它的思想非常的简单，遍历数组元素，将其与之前的任意元素交换。因为遍历有从前向后和从后往前两种方式，所以该算法大致也有两个版本的实现。 这里送上两个方法，具体的请参考文末的数组乱序文章 123456789101112131415161718192021222324252627// 从后往前的版本const shuffle = (array) =&gt; &#123; var _array = array.concat(); for (var i = _array.length; i--;) &#123; var j = Math.floor(Math.random() * (i + 1)); var temp = _array[i]; _array[i] = _array[j]; _array[j] = temp; &#125; return _array;&#125;// 从前往后的版本const shuffle = (a) =&gt; &#123; var length = a.length; var shuffled = Array(length); for (var index = 0, rand; index &lt; length; index++) &#123; rand = ~~(Math.random() * (index + 1)); if (rand !== index) shuffled[index] = shuffled[rand]; shuffled[rand] = a[index]; &#125; return shuffled;&#125; reversereverse() 方法将数组中元素的位置颠倒。第一个数组元素成为最后一个数组元素，最后一个数组元素成为第一个。此方法会更改现有数组。 123456789/** * Array.reverse(compareFunction) * ---------------------------------------------- * 返回值 * @param &#123;Array&#125; 颠倒后的数组 */const months = ['March', 'Jan', 'Feb', 'Dec'];months.reverse() console.log(months) // ["Dec", "Feb", "Jan", "March"] joinjoin() 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。此方法不会更改原数组。 12345678910/** * Array.reverse(separator) * @param &#123;String&#125; 如果需要(separator)，将分隔符转换为字符串。如果省略()，数组元素用逗号分隔。默认为 ","。 * ---------------------------------------------- * 返回值 * @param &#123;String&#125; 一个所有数组元素连接的字符串。如果 arr.length 为0，则返回空字符串 */const arr = [1,2,3]console.log(arr.join()) // 1,2,3console.log(arr.join('-')) // 1-2-3 迭代(循环遍历)相关everyevery() 方法测试数组的所有元素是否都通过了指定函数的测试。此方法不会更改原数组。 123456789101112/** * arr.every(callback,thisArg) * @param &#123;Function&#125; callback =&gt; 用来测试每个元素的函数 * @param &#123;Object&#125; thisArg =&gt; 可选参数，执行回调函数 mapFn 时 this 对象。 (可选) * * callback 被调用时会传入三个参数：当前元素值，元素的索引，原数组。 * * 返回值 * @param &#123;Boolean&#125; 为true时，所有元素是否都通过了指定函数的测试，否则就是没有通过*/const arr = [1,2,4,2,4,56]console.log(arr.every(item=&gt;item&lt;10)) // false somesome() 方法测试数组中的某些元素是否通过由提供的函数实现的测试。此方法不会更改原数组。 some() 和 every() 的区别在于every是数组所有元素都需要通过测试才返回true，而some只需要有一个通过测试就返回true 对于放在空数组上的任何条件，此方法返回false。 123456789101112/** * arr.some(callback,thisArg) * @param &#123;Function&#125; callback =&gt; 用来测试每个元素的函数 * @param &#123;Object&#125; thisArg =&gt; 可选参数，执行回调函数 mapFn 时 this 对象。 (可选) * * callback 被调用时会传入三个参数：当前元素值，元素的索引，原数组。 * * 返回值 * @param &#123;Boolean&#125; 为true时，有其中一个或多个元素是否都通过了指定函数的测试，否则就是没有通过*/const arr = [1,2,4,2,4,56]console.log(arr.some(item=&gt;item&lt;10)) // true 实际的应用场景，可以实现类似于 includes 的功能 （这里或许你会问，为啥实现类似 includes 的功能，直接用不就好了吗？ 因为 includes 的兼容性太差了，IE是不兼容的，但是 some 在IE9下却可以使用，所以，你懂的 12345678var fruits = ['apple', 'banana', 'mango', 'guava'];function checkAvailability(arr, val) &#123; return arr.some(arrVal =&gt; val === arrVal);&#125;checkAvailability(fruits, 'kela'); // falsecheckAvailability(fruits, 'banana'); // true forEachforEach() 方法对数组的每个元素执行一次提供的函数。 for 和 forEach 的区别，forEach中已删除或者未初始化的项将被跳过（例如在稀疏数组上），而 for 不会 注意： 没有办法中止或者跳出 forEach 循环，除了抛出一个异常。 123456789101112131415161718192021222324/** * arr.forEach(callback,thisArg) * @param &#123;Function&#125; callback =&gt; 用来测试每个元素的函数 * @param &#123;Object&#125; thisArg =&gt; 可选参数，执行回调函数 mapFn 时 this 对象。 (可选) * * callback 被调用时会传入三个参数：当前元素值，元素的索引，原数组。 * * 返回值 * @param &#123;undefined&#125; undefined*/const arr1 = [1,2,3]arr1.forEach(item=&gt;&#123; console.log(item) // 1 2 3&#125;)// for 和 forEach 的区别const arr2 = [1,2,,4]for (let index = 0; index &lt; arr2.length; index++) &#123; console.log(arr2[index]) // 1 2 undefined 4&#125;arr2.forEach(item=&gt;&#123; console.log(item) // 1 2 4&#125;) 实际的应用场景，我们可以通过 forEach 实现对对象的复制，当然，这只是对象复制的其中一种方式 12345678910111213const copy = obj =&gt; &#123; const copy = Object.create(Object.getPrototypeOf(obj)) const propNames = Object.getOwnPropertyNames(obj) propNames.forEach(function(name) &#123; const desc = Object.getOwnPropertyDescriptor(obj, name); Object.defineProperty(copy, name, desc); &#125;) return copy;&#125;const obj1 = &#123;name:'gating'&#125;const obj2 = copy(obj1)console.log(obj2) // &#123;name:'gating'&#125; mapmap() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。此方法不会更改原数组。 12345678910111213/** * arr.map(callback,thisArg) * @param &#123;Function&#125; callback =&gt; 用来测试每个元素的函数 * @param &#123;Object&#125; thisArg =&gt; 可选参数，执行回调函数 mapFn 时 this 对象。 (可选) * * callback 被调用时会传入三个参数：当前元素值，元素的索引，原数组。 * * 返回值 * @param &#123;Array&#125; 一个新数组，每个元素都是回调函数的结果。*/const arr = [1,2,3]console.log(arr.map(item=&gt;item*2)) // [2,4,6] map 的应用场景很多，比如我想给数组增加一个id的属性，再比如可以重新格式化我们的数组 123456const arr = [&#123;name:'gating'&#125;,&#123;name:'family'&#125;]const res = arr.map((item,index)=&gt;&#123; item.id = index return item&#125;)console.log(res) // [&#123;name:'gating',id:0&#125;,&#123;name:'family',id:1&#125;] 由一条面试题引发的思考通常情况下，map 方法中的 callback 函数只需要接受一个参数，就是正在被遍历的数组元素本身。但这并不意味着 map 只给 callback 传了一个参数。 123456789101112131415161718192021222324252627// 下面的语句返回什么呢:["1", "2", "3"].map(parseInt);// 你可能觉的会是[1, 2, 3]// 但实际的结果是 [1, NaN, NaN]// 通常使用parseInt时,只需要传递一个参数.// 但实际上,parseInt可以有两个参数.第二个参数是进制数.// 可以通过语句"alert(parseInt.length)===2"来验证.// map方法在调用callback函数时,会给它传递三个参数:当前正在遍历的元素, // 元素索引, 原数组本身.// 第三个参数parseInt会忽视, 但第二个参数不会,也就是说,// parseInt把传过来的索引值当成进制数来使用.从而返回了NaN.function returnInt(element) &#123; return parseInt(element, 10);&#125;['1', '2', '3'].map(returnInt); // [1, 2, 3]// 意料之中的结果// 也可以使用简单的箭头函数，结果同上['1', '2', '3'].map( str =&gt; parseInt(str) );// 一个更简单的方式:['1', '2', '3'].map(Number); // [1, 2, 3]// 与`parseInt` 不同，下面的结果会返回浮点数或指数:['1.1', '2.2e2', '3e300'].map(Number); // [1.1, 220, 3e+300] filterfilter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。此方法不会更改原数组。 12345678910111213/** * arr.filter(callback,thisArg) * @param &#123;Function&#125; callback =&gt; 用来测试每个元素的函数 * @param &#123;Object&#125; thisArg =&gt; 可选参数，执行回调函数 mapFn 时 this 对象。 (可选) * * callback 被调用时会传入三个参数：当前元素值，元素的索引，原数组。 * * 返回值 * @param &#123;Array&#125; 过滤后的数组*/const arr = [&#123;sex:'male',name:'gating'&#125;,&#123;sex:'female',name:'blue'&#125;,&#123;sex:'male',name:'family'&#125;]// 过滤掉性别为 male 的人console.log(arr.filter(item=&gt;item.sex==='female')) 实际的应用场景，通过可以 filter 过滤掉我们不需要的值 123456789const delListRep = (arr, key) =&gt; &#123; var keys = [] for (let i = 0; i &lt; arr.length; i++) &#123; keys.push(arr[i][key]) &#125; return arr.filter((ele, i, arr) =&gt; keys.indexOf(ele[key]) == i)&#125;const arr = [&#123;sex:'male',name:'gating'&#125;,&#123;sex:'female',name:'blue'&#125;,&#123;sex:'male',name:'gating'&#125;]console.log(delListRep(arr,'sex')) // [&#123;sex:'male',name:'gating'&#125;,&#123;sex:'female',name:'blue'&#125;] reducereduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。不会更改原数组。 如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。 1234567891011121314151617181920212223242526272829303132/** * arr.filter(callback,initialValue) * @param &#123;Function&#125; callback =&gt; 执行数组中每个值的函数 * @param &#123;*&#125; initialValue =&gt; 作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。 (可选) * * callback 被调用时会传入三个参数：accumulator，currentValue，currentIndex，array * * accumulator =&gt; 累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（见于下方）。 * currentValue =&gt; 数组中正在处理的元素。 * currentIndex =&gt; 数组中正在处理的当前元素的索引。 如果提供了initialValue，则起始索引号为0，否则为1。 (可选) * array =&gt; 调用reduce()的数组。 (可选) * * 返回值 * @param &#123;*&#125; 函数累计处理的结果*/const arr = [1, 2, 3, 4];const reducer = arr.reduce((accumulator, currentValue) =&gt; accumulator + currentValue)console.log(reducer) // 10console.log(arr) // [1, 2, 3, 4]const res = arr.reduce((accumulator, currentValue) =&gt; accumulator + currentValue,5)console.log(res) // 15// initialValue 有值 和 没有值的区别// 因为 reduce 里，如果没有提供初始值，那么 accumulator 会默认使用数组的第一个元素，因为取了数组的第一个元素了，那么下标当然没有必要再从0开始了arr.reduce((accumulator, currentValue, index) =&gt; &#123; console.log(index) // 0 1 2 3&#125;)arr.reduce((accumulator, currentValue, index) =&gt; &#123; console.log(index) // 1 2 3&#125;,5) 看到了 reduce 的用法，实际上也可以想到，reduce 的参数这么丰富，是不是可以做很多我们想要的事，我想说，是的，在实际应用中，reduce 能做到的事，比我们想象中的还要多 比如，数组扁平化、数组去重、统计数组中每个元素出现的次数、根据属性对Object分类等等等等这种很cool的事，接下来，我们就一一用 reduce 实现吧 reduce 很重要，请务必掌握这个方法 ps：字符串的 replace 也很重要哦！！！也要掌握 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 根据所提供的字符分组 * @param &#123;Array&#125; arr =&gt; 数组 * @param &#123;String&#125; key =&gt; 需要分组的字段 */function groupBy(arr, key) &#123; return arr.reduce(function (newObj, obj) &#123; if (!newObj[obj[key]]) &#123; newObj[obj[key]] = []; newObj[obj[key]].push(obj); &#125; else &#123; newObj[obj[key]].push(obj); &#125; return newObj; &#125;, &#123;&#125;);&#125;const people = [ &#123; name: 'gating', age: 18 &#125;, &#123; name: 'family', age: 16 &#125;, &#123; name: 'blue', age: 20 &#125;];const groupedPeople = groupBy(people, 'age') // &#123;16: Array(1), 18: Array(1), 20: Array(1)&#125;// 统计数组中每个元素出现的次数 Object同理// 这里用 Map 是为了避免 数字1 和 字符串1 同名键值导致的bugconst names = ['gating', 'family', 'gating', 'blue', 'family']const countNum1 = (arr) =&gt; arr.reduce((m, x)=&gt; m.set(x, (m.get(x) || 0) + 1), new Map())const allName = countNum1(names) // &#123;"gating" =&gt; 2, "family" =&gt; 2, "blue" =&gt; 1&#125;// 数组去重let arr = [1,2,1,2,3,5,4,5,3,4,4,4,4];let result = arr.sort().reduce((init, current)=&gt;&#123; if(init.length===0 || init[init.length-1]!==current)&#123; init.push(current); &#125; return init;&#125;, []);console.log(result); //[1,2,3,4,5] 其实 reduce 还可以做很多更牛逼的事，看到这里，你是不是也想用 reduce 做更多强大的事呢？那就赶紧把 reduce 学会 reduceRightreduceRight() 方法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。不会更改原数组。 1234567891011121314151617181920/** * arr.filter(callback,initialValue) * @param &#123;Function&#125; callback =&gt; 执行数组中每个值的函数 * @param &#123;*&#125; initialValue =&gt; 作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。 (可选) * * callback 被调用时会传入三个参数：accumulator，currentValue，currentIndex，array * * accumulator =&gt; 累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（见于下方）。 * currentValue =&gt; 数组中正在处理的元素。 * currentIndex =&gt; 数组中正在处理的当前元素的索引。 如果提供了initialValue，则起始索引号为0，否则为1。 (可选) * array =&gt; 调用reduce()的数组。 (可选) * * 返回值 * @param &#123;*&#125; 函数累计处理的结果*/const arr = [[0, 1], [2, 3], [4, 5]].reduceRight( (accumulator, currentValue) =&gt; accumulator.concat(currentValue))console.log(arr) // [4, 5, 2, 3, 0, 1] reduce 与 reduceRight 之间的区别 12345const arr = ['1', '2', '3', '4', '5']; const left = arr.reduce((prev, cur)=&gt;prev + cur); const right = arr.reduce((prev, cur)=&gt;prev + cur); console.log(left); // "12345"console.log(right); // "54321" 由于 reduceRight 和 reduce 区别不是很大，这里的例子就参考 reduce 就行了 迭代相关(生成一个迭代器)暂时没有太多的应用场景，不详细讲解 entriesentries() 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。 1234567891011121314151617181920/** * arr.entries() * 返回值 * @param &#123;Iterator&#125; 一个新的 Array 迭代器对象*/const arr1 = [1,2,3]const iterator1 = arr1.entries();// 迭代器通用的两种迭代方式（entries、keys、value同样）// 1. for of 循环for (let number of iterator1) &#123; console.log(number) // [0, 1] ， [1, 2] ， [2, 3] 输出三次&#125;const arr2 = [1,2,3]const iterator2 = arr2.entries();console.log(iterator2.next().value); // [0, 1]console.log(iterator2.next().value); // [1, 2]console.log(iterator2.next().value); // [2, 3]console.log(iterator2.next().value); // undefined，并且 iterator2.next().done 变成true keyskeys() 方法返回一个包含数组中每个索引键的Array Iterator对象。 1234567891011/** * arr.keys() * 返回值 * @param &#123;Iterator&#125; 一个新的 Array 迭代器对象*/const arr = ['a','b','c']const iterator = arr.keys(); for (let key of iterator) &#123; console.log(key); // 0 1 2&#125; valuesvalues() 方法返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值 12345678910/** * arr.values() * 返回值 * @param &#123;Iterator&#125; 一个新的 Array 迭代器对象*/const arr = ['a','b','c']const iterator = arr.values()for (let value of iterator) &#123; console.log(key) // 'a' 'b' 'c'&#125; 不知名的两个方法toStringtoString() 返回一个字符串，表示指定的数组及其元素 1234567/** * arr.toString() * 返回值 * @param &#123;String&#125; 一个表示指定的数组及其元素的字符串。*/const arr = ['a','b','c']console.log(arr.toString()) // 'a','b','c' toLocaleStringtoLocaleString() 返回一个字符串表示数组中的元素。数组中的元素将使用各自的 toLocaleString 方法转成字符串，这些字符串将使用一个特定语言环境的字符串（例如一个逗号 “,”）隔开。 123456789101112131415/** * arr.toLocaleString(locales,options) * @param &#123;String?&#125; locales =&gt; 带有BCP 47语言标记的字符串或字符串数组，关于locales参数的形式与解释，请看Intl页面。(可选) * @param &#123;Object&#125; options =&gt; 一个可配置属性的对象，对于数字 Number.prototype.toLocaleString()，对于日期Date.prototype.toLocaleString() (可选) * 返回值 * @param &#123;String&#125; 表示数组元素的字符串*/var array1 = [1, 'a', new Date('21 Dec 1997 14:12:00 UTC')]var localeString = array1.toLocaleString('en', &#123;timeZone: "UTC"&#125;)console.log(localeString) // 1,a,12/21/1997, 2:12:00 PMvar prices = ['￥7', 500, 8123, 12] prices.toLocaleString('ja-JP', &#123; style: 'currency', currency: 'JPY' &#125;) // "￥7,￥500,￥8,123,￥12" 这个方法我用的真不多，所以这里还是直接放上MDN的地址供大家了解，或许以后就用到了呢？ 文中某些知识点参考链接重定义数组对象的 length 属性 MDN地址,文中很多例子都采用于MDN，推荐 数组类型判断，玉伯大佬博客，推荐 avaScript 数组乱序 数组的完全随机排列 鉴于 reduce 和 reduceRight 太过好用（太过牛逼），这里提供他们两个的MDN地址 reduce reduceRight 总结针对于我们一开始关心的两个问题，我在这里做一个小小的总结 ps: 对于测试性的方法，这里就不做展开了，因为用不上= = 方法名 返回值 是否修改原数组 concat 返回合并后的 Array 实例 否 copyWithin 改变了的数组 是 entries 一个新的 Array 迭代器对象( [key,value]) 否 every 布尔值，表示数组中所有元素是否通过 every 测试 否 fill 修改后的数组 是 filter 一个新的通过测试的元素的集合的数组，如果没有通过测试则返回空数组 否 find 当某个元素通过 callback 的测试时，返回数组中的一个值，否则返回 undefined。 否 findIndex 返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。 否 forEach undefined 否 includes 布尔值， 判断一个数组是否包含一个指定的值 否 indexOf 首个被找到的元素在数组中的索引位置; 若没有找到则返回 -1 否 join 一个所有数组元素连接的字符串。如果 arr.length 为0，则返回空字符串 否 keys 一个新的 Array 迭代器对象( [key]) 否 lastIndexOf 数组中最后一个元素的索引，如未找到返回-1 否 map 一个新数组，每个元素都是回调函数的结果 否 pop 从数组中删除的元素(当数组为空时返回undefined) 是 push 当调用该方法时，新的 length 属性值将被返回。 是 reduce 函数累计处理的结果 否 reduceRight 执行之后的返回值 否 reverse 返回颠倒后的 Array 是 shift 返回被删除元素的值 是 slice 一个含有提取元素的新数组 否 some 布尔值，表示数组中至少有一个元素是否通过 every 测试 否 sort 排序后的数组 是 splice 由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。 是 toLocaleString 表示数组元素的字符串 否 toString 个表示指定的数组及其元素的字符串 否 unshift 返回其 length属性值。 是 values 一个新的 Array 迭代器对象( [value]) 否 常用 includes map filter some every splice]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串的方法的总结和使用]]></title>
    <url>%2F2020%2F10%2F15%2F2019-01-09-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言前些天写了篇数组的总结，其实我们再来看看字符串，和数组有异曲同工之妙，字符串也可以通过 split 来变成数组，然后使用数组的方法。 另外，对于字符串，其实我们关心的只有一个问题，返回值是什么。 接下来，我会带大家一步步的使用 String 里面所拥有的方法和属性 字符串的属性lengthlength属性表示一个字符串的长度。该属性返回字符串中字符编码单元的数量。JavaScript 使用 UTF-16 编码，该编码使用一个 16 比特的编码单元来表示大部分常见的字符，使用两个代码单元表示不常用的字符。因此 length 返回值可能与字符串中实际的字符数量不相同。 空字符串的 length 为 0。 静态属性 String.length 返回 1。 1234567891011121314151617let str = "gating"console.log(str.length) // 6let empty = ""console.log(empty.length) // 0 // JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。// 对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。let double = "𪚥"console.log(double.length) // 2// 从数组的length我们可得知，数组的 length 来截断数组，字符串的可不可以呢？// 很遗憾的说，不行，因为字符串的length只可读，不可写let name = "gating"name.length = 1console.log(name,name.length) // gating,6 字符串的静态方法字符的 Unicode 表示法说到字符串，不得不说 JavaScript 中的字符串的 Unicode 表示形式，JavaScript 允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的Unicode码点。 但是，这种表示法只限于码点在\u0000~\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。 1234567// 比如console.log("\u0061") // aconsole.log("\uD842\uDFB7") // 𠮷console.log("\u20BB7") // "₻7"// 但是 es6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。console.log("\u&#123;20BB7&#125;") 参考链接 ECMAScript 6 入门 建议去了解一下，这里我就不做过多解释了，因为我用的真的不多（主要也是不会） String.fromCharCode()String.fromCharCode() 方法返回使用指定的Unicode值序列创建的字符串。 1234567891011/** * String.fromCharCode(numN) * @param &#123;Number/String&#125; numN =&gt; 一组序列数字，表示 Unicode 值。 * ---------------------------------------------- * 返回值 * @param &#123;String&#125; 该方法返回一个字符串，而不是一个 String 对象。 */console.log(String.fromCharCode(65)) // Aconsole.log(String.fromCharCode(65,66)) // ABconsole.log(String.fromCharCode("----")) // " " 作用于高位编码（higher values）尽管绝大部分常用的 Unicode 值可以用一个 16-bit 数字表示（正如 JavaScript 标准化过程早期），并且对于绝大部分值 fromCharCode() 返回一个字符（即对于绝大部分字符 UCS-2 值是 UTF-16 的子集），但是为了处理所有的 Unicode 值（至 21 bits），只用 fromCharCode() 是不足的。由于高位编码字符是用两个低位编码（lower value）表示形成的一个字符，因此String.fromCodePoint() （ES6 规范的一部分）被用来返回这样一对低位编码，从而可以完全表示这些高位编码字符。 String.fromCodePoint()String.fromCodePoint() 静态方法返回使用指定的代码点序列创建的字符串。 1234567891011121314/** * String.fromCodePoint(numN) * @param &#123;Number/String&#125; numN =&gt; 一串 Unicode 编码。如果传入无效的 Unicode 编码，将会抛出一个RangeError * ---------------------------------------------- * 返回值 * @param &#123;String&#125; 该方法返回一个字符串，而不是一个 String 对象。 */console.log(String.fromCodePoint(65)) // Aconsole.log(String.fromCodePoint(65,66)) // ABconsole.log(String.fromCodePoint("----")) // RangeError// String.fromCharCode() 方法不能单独获取在高代码点位上的字符console.log(String.fromCharCode(0x2F804)) // console.log(String.fromCodePoint(0x2F804)) // 你 具体实际用理可以看看 MDN 这里不做阐述了，因为博主这两个方法用着不多 String.fromCharCode()、String.fromCodePoint() String.raw 和 模板字符串模板字符串了解String.raw时，我们必须先了解一下什么是模板字符串，简单来说模板字符串是增强版的字符串，他用反引号（`）标识。 1234567891011121314// 字符串中嵌入变量// es6 之前，我们如果想要在字符串嵌入变量需要通过+号let name = "gating", time = "today";console.log("Hello "+name+", how are you " + time) // Hello gating, how are you today?// 模板字符串后let name = "gating", time = "today";console.log(`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`) // Hello gating, how are you today?// 另外模板字符串可以表示多行字符串var str = `&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt; &lt;/ul&gt;` String.rawString.raw() 是一个模板字符串的标签函数，它的作用类似于 Python 中的字符串前缀 r 和 C# 中的字符串前缀 @，是用来获取一个模板字符串的原始字面量值的。 12345678910111213141516171819/** * String.raw(callSite, ...substitutions) || String.raw`templateString` * @param &#123;Object&#125; callSite =&gt; 一个模板字符串的“调用点对象”。类似&#123; raw: ['foo', 'bar', 'baz'] &#125;。 * @param &#123;Any&#125; ...substitutions =&gt; 任意个可选的参数，表示任意个内插表达式对应的值。 * @param &#123;String&#125; templateString =&gt; 模板字符串。 * ---------------------------------------------- * 返回值 * @param &#123;String&#125; 给定模板字符串的原始字面量值。 */// "Hi\\u000A!"，这里得到的会是 \、u、0、0、0、A 6个字符// 任何类型的转义形式都会失效console.log(String.raw `Hi\u000A!`) // Hi\u000A!let name = "Bob"console.log(String.raw `Hi\n$&#123;name&#125;!`) // Hi\nBob!// 我认为你通常不需要把它当成普通函数来调用console.log(String.raw(&#123; raw: 'test' &#125;, 0, 1, 2)) // t0e1s2tconsole.log(String.raw(&#123; raw: ['t','e','s','t'] &#125;, 0, 1, 2)) // t0e1s2t 作为函数，String.raw的代码实现基本如下。 12345678910String.raw = function (strings, ...values) &#123; let output = ''; let index; for (index = 0; index &lt; values.length; index++) &#123; output += strings.raw[index] + values[index]; &#125; output += strings.raw[index] return output;&#125; ES6入门 String.raw() 正则相关 正则推荐观看文末的 正则表达式30分钟入门教程 ，写的非常好 splitsplit() 方法使用指定的分隔符字符串将一个String对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。 Tip: 如果空字符串(“”)被用作分隔符，则字符串会在每个字符之间分割。 12345678910111213/** * str.split(separator,limit) * @param &#123;String&#125; separator =&gt; 一个介于0 和字符串长度减1之间的整数。 (0~length-1) 如果没有提供索引，charAt() 将使用 0。如果指定的 index 值超出了该范围，则返回一个空字符串。 * @param &#123;Number&#125; limit =&gt; 一个整数，限定返回的分割片段数量。当提供此参数时，split 方法会在指定分隔符的每次出现时分割该字符串，但在限制条目已放入数组时停止。如果在达到指定限制之前达到字符串的末尾，它可能仍然包含少于限制的条目。新数组中不返回剩下的文本。 * ---------------------------------------------- * 返回值 * @param &#123;Array&#125; 返回源字符串以分隔符出现位置分隔而成的一个 Array */let str = "gating"console.log(str.split('')) // ["g", "a", "t", "i", "n", "g"]console.log(str.split('',1)) // ["g"]console.log(str.split('',8)) // ["g", "a", "t", "i", "n", "g"] 看到这里，是不是感觉可以用通过split转成数组，使用数组的方法啦？没错是的，还记得前些天我写过一篇数组的方法的总结吗？没错，重新看一遍就可以了O(∩_∩)O 不信，你看，我们可以通过 split 获取字符串的交集或差集哦 123456789/** * 返回两个字符串的交集 * @param &#123;String&#125; str =&gt; 字符串1 * @param &#123;String&#125; str =&gt; 字符串2 */function intersection(str1, str2) &#123; return str1.split("").filter(v =&gt; str2.split("").includes(v)).toString().replace(/,/g, "")&#125;console.log(intersection("abc","bcd")) // bc 是不是感觉自己已经对字符串了如指掌了吗？ 好了，本次教程到此结束了 开个玩笑嘛，接下来我会陆陆续续带大家认识下 string 的方法的。 match当一个字符串与一个正则表达式匹配时， match()方法检索匹配项 12345678910111213141516171819202122232425/** * str.match(regexp) * @param &#123;RegExp&#125; regexp =&gt; 个正则表达式对象。如果传入一个非正则表达式对象，则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp 。如果你未提供任何参数，直接使用 match() ，那么你会得到一个包含空字符串的 Array ：[""] 。 * ---------------------------------------------- * 返回值 * @param &#123;String&#125; 如果字符串匹配到了表达式，会返回一个数组，数组的第一项是进行匹配完整的字符串，之后的项是用圆括号捕获的结果。如果没有匹配到，返回null */let str = "gating"const res = str.match(/g/g)console.log(res) // ["g", "g"]console.log(str.match()) // [""]console.log(str.match(/sadasd/)) // nulllet str1 = "NaN means not a number. Infinity contains -Infinity and +Infinity in JavaScript.", str2 = "My grandfather is 65 years old and My grandmother is 63 years old.", str3 = "The contract was declared null and void.";str1.match("number"); // "number" 是字符串。返回["number"]str1.match(NaN); // NaN的类型是number。返回["NaN"]str1.match(Infinity); // Infinity的类型是number。返回["Infinity"]str1.match(+Infinity); // 返回["Infinity"]str1.match(-Infinity); // 返回["-Infinity"]str2.match(65); // 返回["65"]str2.match(+65); // 有正号的number。返回["65"]str3.match(null); // 返回["null"] replacereplace() 方法返回一个由替换值替换一些或所有匹配的模式后的新字符串。模式可以是一个字符串或者一个正则表达式, 替换值可以是一个字符串或者一个每次匹配都要调用的函数。 replace 十分重要，必须掌握 123456789101112131415161718192021222324/** * str.replace(regexp|substr, newSubStr|function) * @param &#123;RegExp&#125; regexp =&gt; 一个RegExp 对象或者其字面量。该正则所匹配的内容会被第二个参数的返回值替换掉。 * @param &#123;String&#125; substr =&gt; 一个要被 newSubStr 替换的字符串。其被视为一整个字符串，而不是一个正则表达式。仅仅是第一个匹配会被替换。 * @param &#123;String&#125; newSubStr =&gt; 用于替换掉第一个参数在原字符串中的匹配部分的字符串。该字符串中可以内插一些特殊的变量名 * @param &#123;Function&#125; function =&gt; 一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果 * ---------------------------------------------- * 返回值 * @param &#123;String&#125; 一个部分或全部匹配由替代模式所取代的新的字符串 */// 特殊的变量名 和 function 在实例中 会更详细说明let str = "gating"// 如果用 substr ，只会替换找到的第一个字符，替换多个字符则需要用正则console.log(str.replace('g','家庭')) // 家庭atingconsole.log(str.replace(/g/,'家庭')) // 家庭atingconsole.log(str.replace(/g/g,'家庭')) // 家庭atin家庭console.log(str.replace(/g/i,'G')) // Gatinglet word = "hello,gating"// 单词首字母大写// 这里的 word 参数时匹配的字符串，下文有说明let res = word.replace(/\b\w+\b/g,(word)=&gt;(word[0].toUpperCase()+word.slice(1)))console.log(res) // Hello,Gating 实际应用场景中，replace 方法非常灵活，可以做很多我们想要的事，比如：😄 类似于我们的模板引擎 replace 就可以实现，不过这里我就不带着大家实现了= = 在写实例时，我希望可以先搞懂几个概念和用法 newSubStr 的特殊变量名 变量名 代表的值 $$ 插入一个 “$”。 $&amp; 插入匹配的子串。 $` 插入当前匹配的子串左边的内容。 $&#39; 插入当前匹配的子串右边的内容。 $*n* 假如第一个参数是 RegExp对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。提示：索引是从1开始 replace 中 function 的参数 变量名 代表的值 match 匹配的子串。（对应于上述的$&amp;。） p1,p2, ... 假如replace()方法的第一个参数是一个RegExp 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。）例如, 如果是用 /(\a+)(\b+)/这个来匹配， p1就是匹配的 \a+, p2 就是匹配的 \b+。 offset 匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1） string 被匹配的原字符串。 你可以指定一个函数作为第二个参数。在这种情况下，当匹配执行后， 该函数就会执行。 函数的返回值作为替换字符串。 (注意: 上面提到的特殊替换参数在这里不能被使用。) 另外要注意的是， 如果第一个参数是正则表达式， 并且其为全局匹配模式， 那么这个方法将被多次调用， 每次匹配都会被调用。 在实际应用中,replace的使用可以满足大部分的操作字符串场景,特别是function的引入,极大的增强了replace的实力,从而使得我们操作字符游刃有余. 在写实例的时，我们需要搞懂几个newSubStr特殊变量名，他在实际应用中也很有作用 123456789101112131415161718192021222324let name = 'gating'// $&amp; 表示匹配到的字串，这里匹配到了 gating ，所以 $&amp; 就等于 gatingconsole.log(name.replace(/\w+/,'$&amp;-$&amp;')) // gating-gatinglet str = "gating say hello for mosen"// $1 表示匹配第一个括号里的内容 也就是 $1 就是 gating console.log(str.replace(/(^\w+)(.*?)(\w+)$/,'$3$2$1')) // mosen say hello for gating\let hello = "hello,gating"// $`当前匹配的子串左边的内容。console.log(hello.replace(/gating/,"&amp;.$`mosen")) // hello,gating.hello,mosen// $'当前匹配的子串右边的内容。(不是例子的例子)console.log(hello.replace(/hello,/,"$' say hi for $`")) // gating say hi for gating// function 的 用法let paragraph = "what is this?"let res = paragraph.replace(" is this",(match,offset,string)=&gt;&#123; // match 匹配的子串 // offset 偏移量 这是是4 也就是 偏移了what4个字符 // string 元字符 console.log(match,offset,string) // is this 4 what is this? return " is that"&#125;)console.log(res) // what is that? 了解了这些，那么我们就可以做写点比较实际的了 1234567891011121314151617181920212223242526272829303132// js 隐藏手机中间5位号码let phone='13700000137'console.log(phone.replace(/(\d&#123;3&#125;)\d+(\d&#123;3&#125;)/, '$1****$2')) // 137****137// 将阿拉伯数字每三位一逗号分隔，如：1000转化为1,000let price = '3521.08'console.log(price.replace(/(?=(?!^)(?:\d&#123;3&#125;)+(?:\.|$))(\d&#123;3&#125;(\.\d+$)?)/g,',$1')) // 3,521.08// html 转义，防止用户注入let html = '&lt;div&gt;"hello &amp; world"&lt;/div&gt;';let res = html.replace(/[&lt;&gt;\"\'\&amp;']/g,function(a)&#123; switch(a)&#123; case '&lt;': return '&amp;lt;'; case '&gt;': return '&amp;gt;'; case '\"': return '&amp;quot;'; case '\'': return '&amp;#39;'; case '\&amp;': return '&amp;amp;'; &#125;&#125;)console.log(res) // &amp;lt;div&amp;gt;&amp;quot;hello &amp;amp; world&amp;quot;&amp;lt;/div&amp;gt;// 简易的字符串模板引擎let template = "My name is &#123;name&#125;"const obj = &#123;name:'gating'&#125;const tmpl = (template,obj)=&gt; template.replace(/([^&#123;&#125;]*)&#123;(.*)&#125;/g,(match,p1,p2) =&gt; (p1+obj[p2]))console.log(tmpl(template,obj)) // My name is gating 字符编码相关charAtcharAt() 方法从一个字符串中返回指定的字符 1234567891011121314/** * str.charAt(index) * @param &#123;Number&#125; index =&gt; 一个介于0 和字符串长度减1之间的整数。 (0~length-1) 如果没有提供索引，charAt() 将使用 0。如果指定的 index 值超出了该范围，则返回一个空字符串。 * ---------------------------------------------- * 返回值 * @param &#123;String&#125; 当前索引的字符串 */let str = "gating"console.log(str.charAt(0)) // gconsole.log(str.charAt(6)) // ""// charAt 和 fromCharCode 用同样的问题，他不能识别高位编码console.log("𠮷".charAt(0)) // � charCodeAtcharCodeAt() 方法返回0到65535之间的整数，表示给定索引处的UTF-16代码单元 (在 Unicode 编码单元表示一个单一的 UTF-16 编码单元的情况下，UTF-16 编码单元匹配 Unicode 编码单元。但在——例如 Unicode 编码单元 &gt; 0x10000 的这种——不能被一个 UTF-16 编码单元单独表示的情况下，只能匹配 Unicode 代理对的第一个编码单元) 。如果你想要整个代码点的值，使用 codePointAt()。 123456789101112131415/** * str.charCodeAt(index) * @param &#123;Number&#125; index =&gt; 一个大于等于 0，小于字符串长度的整数。如果不是一个数值，则默认为 0。 * ---------------------------------------------- * 返回值 * @param &#123;Number&#125; 返回值是一表示给定索引处（String中index索引处）字符的 UTF-16 代码单元值的数字；如果索引超出范围，则返回 NaN。 */console.log("ABC".charCodeAt(0)) // 65console.log("ABC".charCodeAt(1)) // 66console.log("ABC".charCodeAt(3)) // NaN// 针对高位编码，他会拆分成两个双字节的形式再来获取// 也就是 "\uD842\uDFB7".charCodeAt(0)console.log("𠮷".charCodeAt(0)) // 55362console.log("𠮷".charCodeAt(1)) // 57271 codePointAtcodePointAt() 方法返回 一个 Unicode 编码点值的非负整数。 1234567891011/** * str.codePointAt(pos) * @param &#123;Number&#125; pos =&gt; 这个字符串中需要转码的元素的位置。 * ---------------------------------------------- * 返回值 * @param &#123;String&#125; 返回值是在字符串中的给定索引的编码单元体现的数字(10进制数)，如果在索引处没找到元素则返回 undefined 。 */console.log("ABC".charCodeAt(0)) // 65console.log("ABC".charCodeAt(3)) // undefinedconsole.log("𠮷".codePointAt(0)) // 134071console.log("𠮷".codePointAt(1)) // 57271 汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是0x20BB7，UTF-16 编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。对于这种4个字节的字符，JavaScript 不能正确处理，字符串长度会误判为2，而且charAt方法无法读取整个字符，charCodeAt方法只能分别返回前两个字节和后两个字节的值。 codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的20BB7），在第二个字符（即“𠮷”的后两个字节）codePointAt方法的结果与charCodeAt方法相同。 codePointAt方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString(16)方法转换一下。 123456789101112let s = '𠮷a's.codePointAt(0) // 134071s.codePointAt(1) // 57271s.codePointAt(2) // 97// 你可能注意到了，codePointAt方法的参数，仍然是不正确的。// 比如，上面代码中，字符a在字符串s的正确位置序号应该是 1，但是必须向codePointAt方法传入 2。// 解决这个问题的一个办法是使用for...of循环，因为它会正确识别 32 位的 UTF-16 字符。for (let ch of s) &#123; console.log(ch.codePointAt(0).toString(16)) // 20bb7 61&#125;console.log("\u&#123;20bb7&#125;") // 𠮷 normalizenormalize() 方法会按照指定的一种 Unicode 正规形式将当前字符串正规化. 许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\u004F）和ˇ（\u030C）合成Ǒ（\u004F\u030C）。 这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。 12345678910111213/** * str.normalize(form) * @param &#123;String&#125; form =&gt; 四种 Unicode 正规形式 "NFC", "NFD", "NFKC", 以及 "NFKD" 其中的一个, 默认值为 "NFC". * ---------------------------------------------- * 返回值 * @param &#123;String&#125; 正规化后的字符串。如果给 form 传入了非法的参数值, 则会抛出 RangeError 异常. */console.log('\u01D1'==='\u004F\u030C') // falseconsole.log('\u01D1'.normalize() === '\u004F\u030C'.normalize()) // true// NFC参数返回字符的合成形式，NFD参数返回字符的分解形式。'\u004F\u030C'.normalize('NFC').length // 1'\u004F\u030C'.normalize('NFD').length // 2 NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。 NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。 NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。） NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。 不过，normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。 此内容参考了 阮老师的normalize() 合并填充相关concatconcat() 方法将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。 强烈建议使用 赋值操作符（+, +=）代替 concat 方法。因为 concat 性能比较垃圾 123456789/** * str.concat(stringN) * @param &#123;String&#125; stringN =&gt; 和原字符串连接的多个字符串 * ---------------------------------------------- * 返回值 * @param &#123;String&#125; 连接后的字符串 */let str = "hello,"console.log(str.concat("gating")) // hello,gating padEndpadEnd() 方法会用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充。 1234567891011121314/** * str.padEnd(targetLength,padString) * @param &#123;Number&#125; targetLength =&gt; 当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。 * @param &#123;String&#125; padString =&gt; 填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断。此参数的缺省值为 " "（U+0020）。 * ---------------------------------------------- * 返回值 * @param &#123;String&#125; 在原字符串末尾填充指定的填充字符串直到目标长度所形成的新字符串。 */let str = "abc"console.log(str.padEnd(1)) // abcconsole.log(str.padEnd(1,"123")) // abcconsole.log(str.padEnd(4,"123")) // abc1console.log(str.padEnd(7,"123")) // abc1231 padStartpadStart() 方法用另一个字符串填充当前字符串(重复，如果需要的话)，以便产生的字符串达到给定的长度。填充从当前字符串的开始(左侧)应用的。 1234567891011121314/** * str.padStart(targetLength,padString) * @param &#123;Number&#125; targetLength =&gt; 当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。 * @param &#123;String&#125; padString =&gt; 填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断。此参数的缺省值为 " "（U+0020）。 * ---------------------------------------------- * 返回值 * @param &#123;String&#125; 在原字符串开头填充指定的填充字符串直到目标长度所形成的新字符串。 */let str = "abc"console.log(str.padStart(1)) // abcconsole.log(str.padStart(3,'123')) // abcconsole.log(str.padStart(6,'123')) // 123abcconsole.log(str.padStart(7,'123')) // 1231abc padStart()的常见用途是为数值补全指定位数和提示字符串格式。 12345678// 生成 10 位的数值字符串'1'.padStart(10, '0') // "0000000001"'12'.padStart(10, '0') // "0000000012"'123456'.padStart(10, '0') // "0000123456"// 提示字符串格式'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12" repeatrepeat() 构造并返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。 1234567891011121314151617181920212223/** * str.repeat(count) * @param &#123;Number&#125; count =&gt; 介于0和正无穷大之间的整数 : [0, +∞) 。表示在新构造的字符串中重复了多少遍原字符串。重复次数不能为负数。重复次数必须小于 infinity，且长度不会大于最长的字符串。 * ---------------------------------------------- * 返回值 * @param &#123;String&#125; 包含指定字符串的指定数量副本的新字符串。 */let str = "gating"console.log(str.repeat(2)) // gatinggating// 参数count将会被自动转换成整数(向下取整)console.log(str.repeat(3.5)) // gatinggatinggatingconsole.log(str.repeat(3.4)) // gatinggatinggating// 但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。console.log(str.repeat(-0.5)) // ""console.log(str.repeat(0)) // ""// 参数NaN等同于 0。console.log(str.repeat(NaN)) // ""// 如果repeat的参数是字符串，则会先转换成数字console.log(str.repeat("aaa")) // ""// RangeError: repeat count must be positive and less than inifinityconsole.log(str.repeat(-1)) console.log(str.repeat(1/0)) repeat 其实很适合我们调试的时候生成多份测试数据，比如 12345let newData = ["1","2","3"]// 假设我们想生成 ["1","1","2","2","3","3"] 的双份数据，那么我们就可以通过 repeat 来实现let newData = myDate.map(item=&gt;item.repeat(2).split('')).reduce((arr,val)=&gt;arr.concat(val))console.log(newData)) // ["1","1","2","2","3","3"] 搜索查找相关indexOfindexOf() 方法返回调用 String 对象中第一次出现的指定值的索引，开始在 fromIndex进行搜索。如果未找到该值，则返回-1。 123456789101112131415161718/** * str.indexOf(searchValue,fromIndex) * @param &#123;String&#125; searchValue =&gt; 一个字符串表示被查找的值。 * @param &#123;String/Number&#125; fromIndex =&gt; 表示调用该方法的字符串中开始查找的位置。可以是任意整数。默认值为 0。如果 fromIndex &lt; 0 则查找整个字符串（如同传进了 0）。如果 fromIndex &gt;= str.length，则该方法返回 -1。当被查找的字符串是一个空字符串，fromIndex &lt;= 0时返回0，0 &lt; fromIndex &lt;= str.length时返回fromIndex，fromIndex &gt; str.length时返回str.length。 * ---------------------------------------------- * 返回值 * @param &#123;Number&#125; 指定值的第一次出现的索引; 如果没有找到 -1。 */let str = "gating"console.log(str.indexOf("g")) // 0// 这里的 -1 也就 fromIndex &lt; 0 时，str.indexOf("a",-1) 等同于 str.indexOf("a",0)console.log(str.indexOf("a",-1)) // 1// 这里的 8 也就 fromIndex &gt; str.length 时，str.indexOf("a",8) 等同于 str.indexOf("a",6)console.log(str.indexOf("g",8)) // -1// 区分大小写console.log(str.indexOf("G")) // -1 实际应用场景中，我们可以使用使用 indexOf 统计一个字符串中某个字符出现的次数 12345678910111213let str = "gating"function countStr(str,value)&#123; let count = 0 let pos = str.indexOf('g'); while (pos !== -1) &#123; count++; pos = str.indexOf('g', pos + 1); &#125; return count&#125;console.log(countStr(str,'g')) // 2 lastIndexOflastIndexOf() 方法返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。从该字符串的后面向前查找，从 fromIndex 处开始。 123456789101112131415/** * str.indexOf(searchValue,fromIndex) * @param &#123;String&#125; searchValue =&gt; 一个字符串表示被查找的值。 * @param &#123;String/Number&#125; fromIndex =&gt; 从调用该方法字符串的此位置处开始查找。可以是任意整数。默认值为 str.length。如果为负值，则被看作 0。如果 fromIndex &gt; str.length，则 fromIndex 被看作 str.length。 * ---------------------------------------------- * 返回值 * @param &#123;Number&#125; 指定值的第一次出现的索引（从后往前数）; 如果没有找到 -1。 */let str = "gating"console.log(str.lastIndexOf('g')) // 5console.log(str.lastIndexOf('g',2)) // 0 // 这里的 8 也就 fromIndex &gt; str.length 时，str.lastIndexOf("a",8) 等同于 str.lastIndexOf("a",6) 也就是 str.lastIndexOf("a")console.log(str.lastIndexOf('g',8)) // 5 console.log(str.lastIndexOf('g',-1)) // -1console.log(str.lastIndexOf('g',0)) // 0 searchsearch() 方法执行正则表达式和 String对象之间的一个搜索匹配。 1234567891011/** * str.search(regexp) * @param &#123;Regexp&#125; regexp =&gt; 一个正则表达式（regular expression）对象。如果传入一个非正则表达式对象，则会使用 new RegExp(obj) 隐式地将其转换为正则表达式对象。 * ---------------------------------------------- * 返回值 * @param &#123;Number&#125; 如果匹配成功，则 search() 返回正则表达式在字符串中首次匹配项的索引。否则，返回 -1。 */let str = "gating"console.log(str.search("g")) // 0console.log(str.search(/g/)) // 0 includesincludes() 方法用于判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false。 123456789101112/** * str.includes(searchString,position) * @param &#123;String&#125; searchString =&gt; 要在此字符串中搜索的字符串。 * @param &#123;Number&#125; position =&gt; 可选。从当前字符串的哪个索引位置开始搜寻子字符串，默认值为0。 * ---------------------------------------------- * 返回值 * @param &#123;Boolean&#125; 如果当前字符串包含被搜寻的字符串，就返回 true；否则返回 false。 */let str = "gating"console.log(str.includes("a")) // trueconsole.log(str.includes("a",1)) // trueconsole.log(str.includes("a",2)) // false 在 Firefox 18 - 39中，这个方法的名称叫 contains()。 具体原因请查看) startsWithstartsWith()方法用来判断当前字符串是否是以另外一个给定的子字符串“开头”的，根据判断结果返回 true 或 false。 12345678910111213/** * str.startsWith(searchString,position) * @param &#123;String&#125; searchString =&gt;要搜索的子字符串。 * @param &#123;Number&#125; position =&gt; 在 str 中搜索 searchString 的开始位置，默认值为 0，也就是真正的字符串开头处。 * ---------------------------------------------- * 返回值 * @param &#123;Boolean&#125; 如果当前字符串以搜素字符串开头，就返回 true；否则返回 false。 */let str = "gating"console.log(str.startsWith('g')) // trueconsole.log(str.startsWith('g',1)) // falseconsole.log(str.startsWith('g',7)) // false endsWithendsWith()方法用来判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回 true 或 false。 1234567891011121314/** * str.endsWith(searchString,position) * @param &#123;String&#125; searchString =&gt; 要搜索的子字符串。 * @param &#123;Number&#125; position =&gt; 可选。作为str的长度，默认值为 str.length。 * ---------------------------------------------- * 返回值 * @param &#123;Boolean&#125; 如果传入的子字符串在搜索字符串的末尾就返回true；否则将返回 false */let str = "gating"console.log(str.endsWith('g')) // true// 这里 position 为 2 表示 str 的值就是 ga，也就是相当于 ga.endsWith('g')console.log(str.endsWith('g',2)) // falseconsole.log(str.endsWith('g',7)) // true 截取相关sliceslice() 方法提取一个字符串的一部分，并返回一新的字符串。 1234567891011121314151617/** * str.slice(beginSlice,endSlice) * @param &#123;Number&#125; beginSlice =&gt; 从该索引（以 0 为基数）处开始提取原字符串中的字符。如果值为负数，会被当做 sourceLength + beginSlice 看待，这里的sourceLength 是字符串的长度 (例如， 如果beginSlice 是 -3 则看作是: sourceLength - 3) * @param &#123;Number&#125; endSlice =&gt; 可选。可选。在该索引（以 0 为基数）处结束提取字符串。如果省略该参数，slice会一直提取到字符串末尾。如果该参数为负数，则被看作是 sourceLength + endSlice，这里的 sourceLength 就是字符串的长度(例如，如果 endSlice 是 -3，则是, sourceLength - 3)。 * ---------------------------------------------- * 返回值 * @param &#123;Number&#125; 返回一个从原字符串中提取出来的新字符串 */let str = "gating"console.log(str.slice(1)) // ating// 这里的-1实际上就是 (6-1) 也就是 5 即 str.slice(5)console.log(str.slice(-1)) // g// 这里的-1实际上就是 (6-1) 也就是 5 即 str.slice(0,5)console.log(str.slice(0,-1)) // gatinconsole.log(str.slice(-2,-1)) // nconsole.log(str.slice(-1,-2)) // "" 注意：slice() 提取的新字符串包括beginSlice但不包括 endSlice。 substrsubstr() 方法返回一个字符串中从指定位置开始到指定字符数的字符。 12345678910111213141516/** * str.substr(start,length) * @param &#123;Number&#125; searchString =&gt; 开始提取字符的位置。如果为负值，则被看作 strLength + start，其中 strLength 为字符串的长度（例如，如果 start 为 -3，则被看作 strLength + (-3)） * @param &#123;Number&#125; position =&gt; 可选。提取的字符数。默认是strLength * ---------------------------------------------- * 返回值 * @param &#123;String&#125; 返回一个从原字符串中提取出来的新字符串 */let str = "gating"console.log(str.substr(1)) // ating// 这里的-1实际上就是 (6-1) 也就是 5 即 str.slice(5)console.log(str.substr(-1)) // g// 因为长度不能小于0,所以返回""console.log(str.substr(-1,-2)) // "" 注意:在IE8下,substr()方法传递负值会返回原始的字符串,IE9修复了此BUG substringsubstring() 方法返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。 1234567891011121314151617181920/** * str.substring(indexStart,indexEnd) * @param &#123;Number&#125; indexStart =&gt; 需要截取的第一个字符的索引，该字符作为返回的字符串的首字母。 * @param &#123;Number&#125; indexEnd =&gt; 可选。一个 0 到字符串长度之间的整数，以该数字为索引的字符不包含在截取的字符串内。 * ---------------------------------------------- * 返回值 * @param &#123;String&#125; 包含给定字符串的指定部分的新字符串。 */let str = "gating"console.log(str.substring(0,3)) // gat// 如果 indexStart 大于 indexEnd，则会变成 str.substring(0,3)console.log(str.substring(3,0)) // gat// 如果任一参数小于 0 或为 NaN，则被当作 0。console.log(str.substring(-2,3)) // gatconsole.log(str.substring(NaN,3)) // gatconsole.log(str.substring(4,4)) // ""console.log(str.substring(0)) // gatingconsole.log(str.substring(0,10)) // gating substring 提取从 indexStart 到 indexEnd（不包括） 如果 indexStart 等于 indexEnd，substring 返回一个空字符串。 如果省略 indexEnd，substring 提取字符一直到字符串末尾。 如果任一参数小于 0 或为 NaN，则被当作 0。 如果任一参数大于 stringName.length，则被当作 stringName.length。 如果 indexStart 大于 indexEnd，则 substring 的执行效果就像两个参数调换了一样。 转换大小写相关 注意: toLocaleLowerCase、toLocaleUpperCase 按照本地方式把字符串转换为小写。只有几种语言（如土耳其语）具有地方特有的大小写映射。 toLowerCasetoLowerCase() 会将调用该方法的字符串值转为小写形式，并返回。 12345678/** * str.toLowerCase() * ---------------------------------------------- * 返回值 * @param &#123;String&#125; 一个新的字符串，表示串转换为小写的调用字符。 */let str = "GATING"console.log(str.toLowerCase()) // gating toLocaleLowerCasetoLocaleLowerCase() 根据任何特定于语言环境的案例映射，将表示调用字符串的新字符串转换为小写。 12345678/** * str.toLocaleLowerCase() * ---------------------------------------------- * 返回值 * @param &#123;String&#125; 根据任何特定于语言环境的案例映射，将表示调用字符串的新字符串转换为小写。 */let str = "GATING"console.log(str.toLocaleLowerCase()) // gating toUpperCasetoUpperCase() 将调用该方法的字符串值转换为大写形式，并返回。 12345678/** * str.toUpperCase() * ---------------------------------------------- * 返回值 * @param &#123;String&#125; 将调用该方法的字符串值转换为大写形式 */let str = "gating"console.log(str.toUpperCase()) // GATING toLocaleUpperCasetoLocaleUpperCase() 将调用该方法的字符串值转换为大写形式，并返回。 12345678/** * str.toLocaleUpperCase() * ---------------------------------------------- * 返回值 * @param &#123;String&#125; 一个新的字符串，即根据本地化的大小写映射规则将输入的字符串转化成大写形式的结果。 */let str = "gating"console.log(str.toLocaleUpperCase()) // GATING 删除空白字符相关trimtrim() 方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR） 12345678/** * str.trim() * ---------------------------------------------- * 返回值 * @param &#123;String&#125; 返回方法移除原字符串两端端的连续空白符 */let str = " gating "console.log(str.trim()) // "gating" trimRighttrimRight() 方法从一个字符串的右端移除空白字符。 1234567891011/** * str.trimRight() * ---------------------------------------------- * 返回值 * @param &#123;String&#125; 返回方法移除原字符串右端的连续空白符 */let str = "gating "console.log(str.trimRight()) // "gating"// 兼容生产环境const trimRight = (str)=&gt; str.replace(/(\s*$)/g, "") 该特性是非标准的，请尽量不要在生产环境中使用它！ trimLefttrimLeft() 方法从一个字符串的左端移除空白字符。 1234567891011/** * str.trimLeft() * ---------------------------------------------- * 返回值 * @param &#123;String&#125; 返回方法移除原字符串左端的连续空白符 */let str = " gating"console.log(str.trimLeft()) // "gating"// 兼容生产环境const trimLeft = (str)=&gt; str.replace(/(^\s*)/g, "") 该特性是非标准的，请尽量不要在生产环境中使用它！ 两个不知名的方法toStringtoString() 方法返回指定对象的字符串形式。 String 对象覆盖了Object 对象的 toString 方法；并没有继承 Object.toString()。对于 String 对象，toString 方法返回该对象的字符串形式，和 String.prototype.valueOf() 方法返回值一样 123456789/** * str.toString() * ---------------------------------------------- * 返回值 * @param &#123;String&#125; 返回指定对象的字符串形式 */let str = new String("gating");console.log(str.toString()) // gating valueOfvalueOf() 方法返回一个String对象的原始值（primitive value）。 String 对象的 valueOf 方法返回一个String对象的原始值。该值等同于String.prototype.toString()。 该方法通常在 JavaScript 内部被调用，而不是在代码里显示调用。 123456789/** * str.valueOf() * ---------------------------------------------- * 返回值 * @param &#123;String&#125; 返回指定对象的字符串形式 */let str = new String("gating");console.log(str.valueOf()) // gating 排序相关localeComparelocaleCompare() 方法返回一个数字来指示一个参考字符串是否在排序顺序前面或之后或与给定字符串相同。 新的 locales 、 options 参数能让应用程序定制函数的行为即指定用来排序的语言。 locales 和 options 参数是依赖于具体实现的，在旧的实现中这两个参数是完全被忽略的。 1234567891011121314/** * str.localeCompare(compareString,locales,options) * @param &#123;String&#125; compareString =&gt; 用来比较的字符串 * @param &#123;locales&#125; locales =&gt; 可选。用来表示一种或多种语言或区域的一个符合 BCP 47 标准的字符串或一个字符串数组。locales参数的一般形式与解释， 详情请参考 MDN * @param &#123;options&#125; options =&gt; 可选。 支持下列的一些或全部属性的一个对象: 详情请参考 MDN * ---------------------------------------------- * 返回值 * @param &#123;String&#125; 如果引用字符存在于比较字符之前则为负数; 如果引用字符存在于比较字符之后则为正数; 相等的时候返回 0 .不同浏览器之间（以及不同浏览器版本之间）返回的正负数的值各有不同 */let str = "b"console.log(str.localeCompare("b")) // 0console.log(str.localeCompare("a")) // 1console.log(str.localeCompare("c")) // -1 实际上，我们就可以通过 localeCompare 实现中文排序了。 12345678910111213141516171819let arr = ["北京","上海","深圳","广州"]let res1 = arr.sort((a,b)=&gt;a-b)// 传统的排序方法，你会发现顺序是有问题的console.log(res1) // ["北京", "上海", "广州", "深圳"]// 通过 localeCompare 我们就实现了中文的排序了let res2 = arr.sort((a,b)=&gt;a.localeCompare(String(b)))console.log(res2) // ["北京", "广州", "上海", "深圳"]// 但是其实这个还是没有实现我们的需求，假设我们 数组既有数字、英文、中文、特殊符号的话，我们的排序就不能这么简单的排序了let myData = ["北京","上海","深圳","广州",null,undefined,10,2,"apple","bird","banana"]let result = myData.sort(function(a,b)&#123; var r = a - b; if(isNaN(r))&#123; r = String(a).localeCompare(String(b)); &#125;; return r;&#125;)console.log(result) localeCompare方法，十分建议看看MDN，因为我实在太菜了 ┭┮﹏┭┮ 当比较大量字符串时， 比如比较大量数组时， 最好创建一个 [Intl.Collator](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Collator) 对象并使用compare 属性所提供的函数。 // Intl.Collator 是用于语言敏感字符串比较的 collators构造函数。 function letterSort(lang, letters) { 21` letters.sort(new Intl.Collator(lang).compare)/. mnbyutrr ;l'/01 return letters; } // 具体请看上面 MDN 的说明 console.log(letterSort('de', ['a','z','ä'])) // ["a", "ä", "z"] console.log(letterSort('sv', ['a','z','ä'])) // ["a", "z", "ä"] 文中某些知识点参考链接阮老师的es6入门，字符串的扩展 推荐！ localeCompare方法，十分建议看看MDN Intl.Collator Array.sort高级用法 JavaScript 正则表达式匹配汉字 正则表达式30分钟入门教程 推荐]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数据渲染]]></title>
    <url>%2F2020%2F10%2F09%2F%E6%A0%91%E7%8A%B6%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E4%B8%8E%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[操作节点 比如一些上下级由于iview 的树组件没有区分上下级 所以在渲染的时候就要自己保存好节点 把数据展开成一维数组 1234567891011121314151617181920212223242526272829303132allDel(data) &#123; this.selectedList = []; data.map((item, index) =&gt; &#123; item.title = item[this.currentTypeName]; item.expand = true; item.checked = false; if (item.children &amp;&amp; item.children.length) &#123; this.allDel(item.children); &#125; else &#123; item.children = []; &#125; &#125;); return data;&#125;,each(data) &#123; if (Array.isArray(data.children)) &#123; data.children.forEach(this.each); if (data[this.currentType] == this.eachParentCode) &#123; data.checked = false; data.indeterminate = false; this.eachParentCode = data.parentCode; console.log(data.deptName); &#125; if (data[this.currentType] == this.eachCurrentCode) &#123; data.checked = false; console.log(data.deptName); &#125; &#125; return data;&#125;,]]></content>
      <categories>
        <category>js拓展</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[anywhere]]></title>
    <url>%2F2020%2F10%2F09%2Fanywhere%2F</url>
    <content type="text"><![CDATA[同事之间传输还在用微信或者其他通讯软件吗 这可不是一个程序员的做派anywhere 快速建立静态服务 文件无需上传下来 直接右键保存即可 你肯定安装了node 查看一下node -v命令行执行 npm install anywhere -g如果出现的界面带有anywhere的版本号，说明安装成功 然后在你需要的文件夹目录下执行anywhere它会将你的当前目录变成一个静态文件服务器的根目录。 地址发给同事就可以访问啦 结束end]]></content>
      <categories>
        <category>js拓展</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[selenium+node 脚本]]></title>
    <url>%2F2020%2F09%2F08%2Fselenium%2Bnode%2F</url>
    <content type="text"><![CDATA[输入安装命令： npm install chromedriver –save npm install selenium-webdriver –save 等到自动安装完毕即可 环境搭建ChromeDriverhttps://sites.google.com/a/chromium.org/chromedriver/downloadsGraphicsMagickhttp://www.graphicsmagick.org/ linux下GraphicsMagick 的安装https://www.iteye.com/blog/zhenghuali168-1441926https://blog.csdn.net/u013894638/article/details/53669303 多线程搭建https://www.cnblogs.com/dingmy/p/3438084.htmlhttps://www.cnblogs.com/liu-ke/p/4377344.html?_t=t 反爬虫设置https://www.cnblogs.com/wodeboke-y/p/11215408.html selenium部分入门心得-中文http://www.selenium.org.cn/1694.html selenium-webdriver-英文 APIhttps://www.selenium.dev/selenium/docs/api/javascript/module/selenium-webdriver/lib/input_exports_Actions.html#keyDown Node使用Selenium进行前端自动化操作的代码实现https://www.jb51.net/article/171523.htm node部分nodejs之log4js日志记录模块简单配置使用https://www.cnblogs.com/hamsterPP/p/5662680.htmlhttps://blog.csdn.net/u013196396/article/details/86065202 为什么服务端没有打印出logshttps://blog.csdn.net/listd_one/article/details/90483372 安装pm2 使用pm2启动项目pm2 delete indexpm2 start index.jspm2 restart index.js –watchingls -la cd /home/loguser/.pm2/logs/cat index-error.log 进程netstat -ano|findstr “8080”tasklist|findstr “4984”taskkill /f /t /im sqlservr.exe]]></content>
  </entry>
  <entry>
    <title><![CDATA[webpack分包]]></title>
    <url>%2F2020%2F01%2F12%2Fwebpack%E5%88%86%E5%8C%85%2F</url>
    <content type="text"><![CDATA[vue.config.js 是 vue-cli3 之后新增的一个功能，再这个版本里面如果要配置 webpack 相关的属性，就需要自己在项目根目录新建 vue.config.js 这个文件，然后在该文件里面去写入你需要的配置等等。 vue.config.js 的具体配置参数可以参照 vue-cli 文档地址：vue.config.js 配置 在配置的过程中遇到一个属性，configureWebpack 文档-&gt; 123456789101112131415161718192021222324252627282930313233configureWebpack: (config) =&gt; &#123; if (process.env.NODE_ENV === 'production') &#123; //为生产环境修改配置 config.mode = 'production'; config.performance = &#123; hints: 'warning', // 性能提示-&gt;如果资源超过 250kb，webpack 会对此输出一个警告来通知你。 &#125;; // 去掉打印警告以及debugger config.optimization.minimizer[0].options.terserOptions.compress.warnings = true; config.optimization.minimizer[0].options.terserOptions.compress.drop_console = true; config.optimization.minimizer[0].options.terserOptions.compress.drop_debugger = true; //splitChunks.cacheGroups-&gt;缓存组，将所有加载模块放在缓存里面一起分割打包 config.optimization.splitChunks.cacheGroups.vendors = &#123; //自定义打包模块 cacheGroups的vendors和common有什么不一样 name: 'chunk-vendors', test: /[\\\/]node_modules[\\\/]/, //只筛选从node_modules文件夹下引入的模块 priority: 10, //优先级，先打包到哪个组里面，值越大，优先级越高 chunks: 'all', //async对异步引入的代码分割 initial对同步引入代码分割 all对同步异步引入的分割都开启 minSize: 10240, //字节 引入的文件大于10.24kb才进行分割 maxSize: 250000, //尝试将大于250kb的文件拆分成n个250kb的文件 &#125;; config.optimization.splitChunks.cacheGroups.common = &#123; //common模块 name: 'chunk-common', minChunks: 2, priority: -10, chunks: 'all', reuseExistingChunk: true, //为true复用其他chunk内已拥有的模块 当chunks引用了已经存在的被抽离的chunks时不会新创建一个chunk而是复用chunk &#125;; &#125; config.externals = &#123; AMap: 'AMap', // 高德地图用到的 &#125;;&#125;,]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES5/ES6/ES7]]></title>
    <url>%2F2019%2F09%2F16%2FES567%2F</url>
    <content type="text"><![CDATA[定义变量 var let constvar 没有块级作用域的概念let 和 const 不能被重复声明 var 后面声明的会覆盖前面声明的 模板字符串拼接、使用变量、方法,加入判断都非常方便 123var liHTML = ` &lt;span class="$&#123;num &gt;= 15 ? "current" : ""&#125;"&gt;$&#123;name&#125;&lt;/span&gt; `; 箭头函数 缩减代码和改变 this 的指向 缩减代码的几种写法: 123456const double1 = (number) =&gt; number * 2;const double2 = (number, number2) =&gt; number + number2;const double3 = (number, number2) =&gt; &#123; sum = number + number2; return sum;&#125;; 改变 this 指向: 12345678910111213141516171819202122232425262728293031323334// 前面两种是ES5解决this指向丢失的方案 而第三种使用箭头函数会默认帮你找到最近的this指向const team1 = &#123; members: ["Henry", "Elyse"], teamName: "es6", teamSummary: function () &#123; let self = this; // 将this定义起来 return this.members.map(function (member) &#123; return `$&#123;member&#125;隶属于$&#123;self.teamName&#125;小组`; &#125;); &#125;,&#125;;const team2 = &#123; members: ["Henry", "Elyse"], teamName: "es6", teamSummary: function () &#123; return this.members.map( function (member) &#123; return `$&#123;member&#125;隶属于$&#123;this.teamName&#125;小组`; &#125;.bind(this) ); // 使用bind()将this传进去 &#125;,&#125;;const team = &#123; members: ["Henry", "Elyse"], teamName: "es6", teamSummary: function () &#123; return this.members.map((member) =&gt; &#123; return `$&#123;member&#125;隶属于$&#123;this.teamName&#125;小组`; &#125;); &#125;,&#125;;console.log(team.teamSummary()); 数组方法 forEach/map/filter/find/every/some/reduce 数组方法 forEach()1234567891011var numbers = [1, 2, 3, 4, 5];var sum = 0;// ES6 forEachnumbers.forEach(function (color) &#123; //console.log(color);&#125;);// 也可以吧操作抽离出来给forEachfunction adder(number) &#123; sum += number;&#125;numbers.forEach(adder); 数组方法 map()映射指定内容到新数组返回一个新数组，有 return，不会改变原数组 1234567891011121314//将A数组中的值以双倍的形式放到B数组var numbers = [1, 2, 3, 4, 5];var doubled = numbers.map(function (number) &#123; return number * 2;&#125;);//将A数中对象某个属性的值存储到B数组中var cars = [ &#123; model: "Buick", price: "CHEAP" &#125;, &#123; model: "BMW", price: "expensive" &#125;,];var prices = cars.map((car) =&gt; &#123; return car.price;&#125;); 数组方法 filter()过滤内容到新数组返回一个新数组，有 return，不会改变原数组 1234567891011121314151617181920212223242526//获取数组A中指定类型的对象放到B数组中var porducts = [ &#123; name: "cucumber", type: "man", price: 2 &#125;, &#123; name: "banana", type: "woman", price: 15 &#125;, &#123; name: "celery", type: "man", price: 19 &#125;, &#123; name: "orange", type: "woman", price: 30 &#125;,];var mans = porducts.filter((arr) =&gt; &#123; return arr.type == "man" &amp;&amp; product.price &gt; 10;&#125;);//假定有两个数组(A,B),根据A中id值,过滤掉B数组不符合的数据var post = &#123; id: 4, title: "Javascript" &#125;;var porducts = [ &#123; name: "cucumber", type: "man", price: 2, id: 4 &#125;, &#123; name: "banana", type: "woman", price: 15, id: 4 &#125;, &#123; name: "celery", type: "man", price: 19, id: 2 &#125;, &#123; name: "orange", type: "woman", price: 30, id: 4 &#125;,];function commentsForPost(post, porducts) &#123; return porducts.filter((arr) =&gt; &#123; return arr.id == post.id; &#125;);&#125; 数组方法 find()返回通过判断条件的数组的第一个元素的值，之后的值不会再调用执行函数，不会改变数组的原始值。以前我们在循环内做判断满足条件后会写一个 break 让循环不再往下执行提高性能 find()就不需要 break 123456789var users = [ &#123; name: "Jill" &#125;, &#123; name: "Alex", id: 2 &#125;, &#123; name: "Bill" &#125;, &#123; name: "Alex" &#125;,];var user = users.find(function (user) &#123; return user.name === "Alex";&#125;); 数组方法 every()/some()这两个方法相似 但是判断限制一个是&amp;&amp;一个是|| 12345678910111213141516171819202122232425262728293031323334353637383940/** * Every: 一假即假 * Some : 一真即真 */var computers = [ &#123; name: "Apple", ram: 8 &#125;, &#123; name: "IBM", ram: 4 &#125;, &#123; name: "Acer", ram: 32 &#125;,];var every = computers.every((arr) =&gt; &#123; //循环到第一个 就返回false return arr.ram &gt; 16;&#125;);var some = computers.some(function (computer) &#123; //循环到最后一个 返回true return computer.ram &gt; 16;&#125;);// 比如一个注册填写信息页面 判断用户必填项是不是为空function Field(value) &#123; this.value = value;&#125;Field.prototype.validate = function () &#123; return this.value.length &gt; 0;&#125;;var username = new Field("henrywu");var telephone = new Field("18888888888");var password = new Field("my_password");var fields = [username, telephone, password];var formIsValid = fields.every(function (field) &#123; return field.validate();&#125;);if (formIsValid) &#123; // 注册成功&#125; else &#123; // 给用户一个友善的错误提醒&#125; 数组方法 reduce()它的第一个参数初始值在方法后面设置 1234567891011121314151617181920212223242526272829303132//计算数组中所有值的总和var numbers = [10, 20, 30];var sumValue = numbers.reduce((sum2, arr) =&gt; &#123; return sum2 + arr;&#125;, 100);//将数组中对象的某个属性抽离到另外一个数组中var primaryColors = [&#123; color: "red" &#125;, &#123; color: "yellow" &#125;, &#123; color: "blue" &#125;];var colors = primaryColors.reduce(function (previous, arr) &#123; previous.push(arr.color); return previous;&#125;, []);// 判断字符串中括号是否对称function balancedParens(string) &#123; return !string.split("").reduce(function (previous, char) &#123; if (previous &lt; 0) &#123; return previous; &#125; if (char == "(") &#123; return ++previous; &#125; if (char == ")") &#123; return --previous; &#125; return previous; &#125;, 0);&#125;console.log(balancedParens(")((())))"));balancedParens(""); 展开运算符更快,更便捷的操作数组基本操作传入多个形参的情况下可以用…代替…array 实际上就是把 array 展开 1,2,3 1234function addNum(...numbers) &#123; return numbers;&#125;addNum(1, 2, 3, 4, 5, 6); //不限传多少个参数了 合并数组: 12345678var defaultColors = ["red", "greed"];var favoriteColors = ["orange", "yellow"];// defaultColors = defaultColors.concat(favoriteColors); concat合并数组console.log([...defaultColors, ...favoriteColors, "blue"]); //...的方法var obj = &#123; a: 1 &#125;;var obj2 = &#123; ...obj, b: 2 &#125;;console.log(obj2); // 合并对象 解构 更快,更便捷 基本用法: 123456var expense = &#123; type: "es6", amount: "45",&#125;;const &#123; type, amount &#125; = expense; //得和对象的key值一样console.log(type); 数组个数: 1234567const names = ["Henry", "Bucky", "Emily"];// 返回数组个数const &#123; length &#125; = names;// 结合展开运算符const [name, ...arr] = names;console.log(name); //打印了Henry 如何不借助第三个变量，让 a,b 值互换 12[a, b] = [b, a];console.log(a, b); 拿到数组对象中第一个的年龄: 1234567const people = [ &#123; name: "Henry", age: 20 &#125;, &#123; name: "Bucky", age: 25 &#125;, &#123; name: "Emily", age: 30 &#125;,];const [&#123; age &#125;] = people; //只此一句牛皮！console.log(age); 将数组转化为对象 12345678910111213141516const points = [ [4, 5], [10, 1], [0, 40],];// 期望数据格式// [// &#123;x:4,y:5&#125;,// &#123;x:10,y:1&#125;,// &#123;x:0,y:40&#125;// ]let newPoints = points.map(([x, y]) =&gt; (&#123; x, y &#125;));console.log(newPoints); 增强对象字面量 缩减代码 如 key 值可以省略 function 也可以省略 12345678910// k:v一样的情况下可以省略k$.ajax(&#123; url, //url:url data, //data:data method:'POST'&#125;)const save=function()&#123;alert()&#125;//省略function后const save=&#123;alert(1)&#125; 函数参数默认值 优化代码 123456789101112131415161718function dataAjax(url, method = "POST") &#123; return method;&#125;//当method没有传参的情况下会默认post// 栗子二生成用户id没有指定的情况下随机生成id 这个栗子不好不要看function User(id) &#123; this.id = id;&#125;function randomId() &#123; return Math.random() * 888888;&#125;function createAdminUser(user = new User(randomId())) &#123; user.admin = "新用户"; return user;&#125; 面向对象(class)1234567891011121314151617181920212223242526272829303132333435363738// ES5function Car(options) &#123; this.title = options.title;&#125;Car.prototype.drive = function () &#123; return "Vroom";&#125;;const car = new Car(&#123; title: "BMW" &#125;);// console.log(car);// console.log(car.drive());// ES5的对象继承有点复杂没有必要 我就不去总结了 直接看ES6的//constructor 是一种用于创建和初始化class创建的对象的特殊方法。class Car &#123; constructor(&#123; title &#125;) &#123; this.title = title; &#125; drive() &#123; return "Vroom"; &#125;&#125;const car = new Car(&#123; title: "BMW" &#125;);// console.log(car);// console.log(car.drive());//继承 在一个构造方法中可以使用super关键字来调用一个父类的构造方法。class Toyota extends Car &#123; constructor(options) &#123; super(options); this.color = options.color; &#125;&#125;const toyota = new Toyota(&#123; color: "red", title: "Focus" &#125;);// console.log(toyota);// console.log(toyota.drive()); generator 生成器 我…… 无中生有 无事生非 无语嘤噎新的数据结构：map 与对象不同的是键和值可以是任何类型 Array.from() 方法从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例。正常对象是没有迭代器 Symbol 的 也就是无法使用 Array.from() , for of 方法 但是 map 对象是有迭代器的可以被遍历或者转化成真正的数组 所以一般数据要转化成数组类型 如 map 或者 set 即可 Array.from(map1) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const map1 = new Map();// 设置key键const key1 = "some string", key2 = &#123;&#125;, key3 = function () &#123;&#125;;// 为key设置value值map1.set(key1, "Value of key1");map1.set(key2, "Value of key2");map1.set(key3, "Value of key3");// 根据key获取对应的valueconsole.log(map1.get(key1), map1.get(key2), map1.get(key3));// 获取对应的value数量console.log(map1.size);// for...of遍历map1中的key and valuefor (let [key, value] of map1) &#123; console.log(`$&#123;key&#125; = $&#123;value&#125;`);&#125;// only keyfor (let key of map1.keys()) &#123; console.log(key);&#125;// only valuefor (let value of map1.values()) &#123; console.log(value);&#125;// forEach遍历map1 map1.forEach((value, key) =&gt; &#123; console.log(`$&#123;key&#125; = $&#123;value&#125;`);&#125;);// 将map1转化为正常的数组const keyValueArray = Array.from(map1);console.log(keyValueArray);// 将map1中的key转化为数组const keyArray = Array.from(map1.keys());console.log(keyArray);// 将map1中的value值转换为数组const valueArray = Array.from(map1.values());console.log(); 新的数据结构：set 可以存储任何数据类型,并且是唯一的(不重复的值) 12345678910111213141516171819202122232425262728293031323334const set1 = new Set();const set2 = new Set([1, true, "string"]);// 添加set1.add(100);set1.add("A String");set1.add(&#123; name: "Henry" &#125;);set1.add(true);// set1.add(100); // 不可以重复添加,无作用// 删除set1.delete(100);// 计算数据个数 属性--sizeconsole.log(set1.size);// 清除所有数据-没有返回值set1.clear();// 检查set中是否拥有对应的值 一下都会返回trueconsole.log(set1.has(100));console.log(set1.has(50 + 50));console.log(set1.has(&#123; name: "Henry" &#125;)); //匹配的是地址 而地址在我们内存中都是唯一的 对象是地址的引用所以这个会返回falseconsole.log(&#123; name: "Henry" &#125; === &#123; name: "Henry" &#125;); // false// keys 遍历返回键名console.log(set1.keys());// values() 遍历返回键值console.log(set1.values());// entries() 遍历返回键值对console.log(set1.entries()); 这个数据结构最近常用语数字去重 12345function dedupe(array) &#123; return Array.from(new Set(array));&#125;dedupe([1, 1, 1, 2, 3]); // [1, 2, 3] Array.from（该方法可以将 Set 结构转为数组） 请求fetch fetch 相对 ajax 更为简洁，而且 fetch 请求属于 promise 结构，直接.then()方法处理回调数据，当出错时，会执行 catch 方法。 1234fetch(url) .then((response) =&gt; response.json()) .then((data) =&gt; console.log(data)) .catch((e) =&gt; console.log("Oops, error", e)); ajax 小型项目 或者请求的方法不常用 可以用 then()方法封装的 ajax 打包出来比 promise 更精简 1234567891011121314151617181920212223242526272829303132333435363738/** * @param &#123; String &#125; url =&gt; 接口名字 * @param &#123; Object &#125; data =&gt; 请求数据，默认空对象 * @param &#123; String &#125; method =&gt; 请求方式，默认post */function ajax(url, data = &#123;&#125;, method = 'post') &#123; function reject(err) &#123; var deferred = $.Deferred(); deferred.reject(err); return deferred.promise(); &#125; return $.ajax(&#123; type: method, url: 'https://xxx.cn/' + url, data: $.extend(&#123; sign: 'ycTI8DeuhNoHkLhhjBe', apptype: 'web', time: new Date() &#125;, data), headers: &#123; source: "bl" &#125;, dataType: "json" &#125;).then(function (res) &#123; var code = res.code if (code == 0) &#123; return res &#125; else &#123; return reject(res) &#125; &#125;);&#125;!(async () =&gt; &#123; const data = await ajax('v2/getList') console.log(data);&#125;)() 异步编程解决方案Promise 三种状态 等待 unresolve 成功回调 resolve 失败 reject 12345678910111213let promise = new Promise((resolve,reject) =&gt; &#123; setTimeout(()=&gt;&#123; resolve(); &#125;,3000) resolve(); reject();&#125;);console.log(promise);// promise.then(() =&gt; console.log("成功,没有任何问题!")).then(() =&gt; console.log("成功,可以无限调用then方法!")).catch(() =&gt; console.log("uh oh,出现了重大问题!")) async 和 await 用法更加简单且 async/await 的优势在于处理 then 链如 1234567891011121314151617// promise 写法var p1 = 1, p2, p3;step1(p1).then((param) =&gt; step2(p1, p2=param)).then((param) =&gt; step3(p1, p2, p3=param)).then((param) =&gt; &#123;console.log('result is', param);&#125;);// async await 写法async function doIt() &#123; const p1 = 300; const p2 = await step1(p1); const p3 = await step2(p1, p2); const result = await step3(p1, p2, p3); console.log(`result is $&#123;result&#125;`);&#125;doIt();]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户行为记录]]></title>
    <url>%2F2019%2F09%2F12%2F%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[用户行为记录 没啥难点吧 但是有个小坑耽误了点时间 一般我们记录用户操作后 在页面关闭的时候会给后台发送一个数据使用 onbeforeunload 来监听用户离开，浏览器可以，但是在微信中无效。貌似是 Safari 不兼容于是使用 pagehide 去代替 12345678const isiOS = !!navigator.userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端const eventName = isiOS ? 'pagehide' : 'unload'; //页面关闭事件兼容// 监听刷新window.addEventListener(eventName, (e) =&gt; &#123; e = e || window.event; $.ajax(&#123;……&#125;)&#125;) ok 没啥问题吧 事件能触发了吧 但是后台一直没收录到 我一度以为是微信浏览器的坑 原来是页面关闭发送不了异步请求 只能够同步请求 在 ajax 参数中添加 async: false ,即可 1234567891011121314151617const isiOS = !!navigator.userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端const eventName = isiOS ? "pagehide" : "unload"; //页面关闭事件兼容// 监听刷新window.addEventListener(eventName, (e) =&gt; &#123; e = e || window.event; $.ajax(&#123; type: "POST", url: URL, data: &#123; //参数 &#125;, dataType: "json", contentType: "application/x-www-form-urlencoded;charset=utf-8", async: false, &#125;);&#125;); 最终项目代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165var visit_type = 1; // 发送请求次数var URL = window.location.href.split("index.php")[0]; //取请求头var Userinfo = window.location.href.split("userinfo")[1].split("/")[1]; //取参数var second = 0;// 终端是否IOSconst isiOS = !!navigator.userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端const eventName = isiOS ? "pagehide" : "unload"; //页面关闭事件兼容// 监听刷新window.addEventListener(eventName, (e) =&gt; &#123; e = e || window.event; $.ajax(&#123; type: "POST", url: URL + "index.php/Home/Index/GetUserAction", data: &#123; userinfo: Userinfo || "", visit_time: second || 0, //访问用户的时长、 slide_muns: slide_muns || 0, //用户滑动次数、 slide_location: slide_location || "", //滑动位置、 longpress_qrcode: longpress_qrcode || 0, //长按次数、 visiti_muns: 0, //打开次数 visit_type: visit_type, pageState: 1, &#125;, dataType: "json", contentType: "application/x-www-form-urlencoded;charset=utf-8", async: false, //页面关闭事件中无法发送异步请求 只能发送同步请求 &#125;);&#125;);//进入页面就记录一次$.ajax(&#123; type: "POST", url: URL + "index.php/Home/Index/GetUserAction", data: &#123; userinfo: Userinfo || "", visit_time: 0, //访问用户的时长、 slide_muns: 0, //用户滑动次数、 slide_location: "", //滑动位置、 longpress_qrcode: 0, //长按次数、 visiti_muns: 1, //打开次数 visit_type: visit_type, pageState: 0, &#125;, dataType: "json", contentType: "application/x-www-form-urlencoded;charset=utf-8",&#125;);// 长按次数var longpress_qrcode = 0;var timeOutEvent = 0;$("body") .find("*[id*='wximg']") .each(function (i, ele) &#123; var nstr = $(ele).attr("id"); $("#" + nstr).on(&#123; touchstart: function (e) &#123; timeOutEvent = setTimeout(function () &#123; timeOutEvent = 0; longpress_qrcode += 1; // console.log("长按事件触发发"); &#125;, 800); // e.preventDefault(); &#125;, touchmove: function () &#123; clearTimeout(timeOutEvent); timeOutEvent = 0; &#125;, touchend: function () &#123; clearTimeout(timeOutEvent); if (timeOutEvent != 0) &#123; // console.log("这是点击，不是长按"); &#125; // return false; &#125;, &#125;); &#125;);// 发送数据function ajax() &#123; // console.log(second, slide_muns, slide_location, longpress_qrcode, visiti_muns); function reject(err) &#123; var deferred = $.Deferred(); deferred.reject(err); return deferred.promise(); &#125; return $.ajax(&#123; type: "POST", url: URL + "index.php/Home/Index/GetUserAction", data: &#123; userinfo: Userinfo || "", visit_time: second || 0, //访问用户的时长、 slide_muns: slide_muns || 0, //用户滑动次数、 slide_location: slide_location || "", //滑动位置、 longpress_qrcode: longpress_qrcode || 0, //长按次数、 visiti_muns: 0, //打开次数 visit_type: visit_type, pageState: 0, &#125;, dataType: "json", &#125;).then(function (res) &#123; if (res.code == 0) &#123; return res; &#125; else &#123; window.clearTimeout(Timer); reject(res); &#125; &#125;);&#125;// 滑动位置let slide_muns = 0; //次数let slide_top = 0;let slide_location = ""; //位置let startX, startY;$("body").on("touchstart", (e) =&gt; &#123; startX = e.originalEvent.changedTouches[0].pageX; startY = e.originalEvent.changedTouches[0].pageY;&#125;);$("body").on("touchend", (e) =&gt; &#123; const moveEndY = e.originalEvent.changedTouches[0].pageY; const Y = moveEndY - startY; if (Y &gt; 0 || Y &lt; 0) &#123; //下滑 slide_muns += 1; slide_top = Math.floor((moveEndY / document.body.clientHeight) * 100); // 0表示20%以内,1表示20%-40%,2表示40%-60%,3表示60%-80%,4表示80%以上 switch (true) &#123; case slide_top &lt;= 19: slide_location += "0,"; break; case slide_top &lt;= 41: slide_location += "1,"; break; case slide_top &lt;= 61: slide_location += "2,"; break; case slide_top &lt;= 81: slide_location += "3,"; break; default: slide_location += "4,"; break; &#125; // console.log('上下滑'+slide_top, slide_location); &#125;&#125;);//五秒记录一次行为var Timer = window.setInterval(function () &#123; second = 5; ajax().then(function (msg) &#123; clear(); &#125;);&#125;, 5000);//清除数据function clear() &#123; slide_muns = 0; slide_location = ""; longpress_qrcode = 0; visit_type += 1;&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack环境变量配置]]></title>
    <url>%2F2019%2F08%2F12%2Fwebpack%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[按照正常的步骤呢 装一个cross-env是用于跨平台环境变量配置的工具，支持在window系统、linux系统等多个平台使用同样的代码配置环境变量；npm i cross-env –save-dev package.json配置命令 1234567"scripts": &#123; "build": "cross-env NODE_ENV=production webpack --mode production --progress", "build:prod": "webpack --mode production --progress", "dev": "cross-env NODE_ENV=production webpack-dev-server --progress --colors --bail --watch --mode development", "prod": "webpack-dev-server --progress --colors --bail --watch --mode development" &#125;, 这里配置了四个命令 运行生产/测试环境 打包生产/测试环境生产环境我们给了一个变量cross-env NODE_ENV=production这个可以自己随意定义cross-env name=XXX 变量不冲突的情况下都是可以的也可以同时定义多个变量 cross-env name=XXX name2=2XXX 然后我们就可以用全局变量process.env去判断了在plugins.config.js文件中 plugins[]里面找个地方放着 1234new webpack.DefinePlugin(&#123; 'process.env': JSON.stringify(process.env.NODE_ENV)&#125;) 在项目中打印 NODE_ENV 结束就是个大概思路 反正我也没有实现 哈哈哈哈 cross-env的变量没有写进去 只能骚操作了 不正常操作步骤 package.json配置命令 1234567"scripts": &#123; "build": "webpack --mode production --progress", "build:prod": "webpack --mode development --progress", "dev": "webpack-dev-server --progress --colors --bail --watch --mode development", "prod": "webpack-dev-server --progress --colors --bail --watch --mode production" &#125; 区别就是 生产环境是 –mode production 一会我们就用production来判断 在plugins.config.js文件中 plugins[]里面找个地方放着 1234new webpack.DefinePlugin(&#123; API_URL: process.argv.includes('production') ? stringify('https://baidu/appIn/') : stringify('https://baidu/test/')&#125;) 那么这里也是可以自己配置多个变量的蛤。 在项目中打印 API_URL 会根据你当前运行环境返回不同的值 结束]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 4+]]></title>
    <url>%2F2019%2F08%2F07%2Fwebpack4%2B%2F</url>
    <content type="text"><![CDATA[简介它做的事情是，分析你的项目结构，找到 JavaScript 模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript 等）和浏览器不支持的新特性，并将其转换和打包为合适的格式供浏览器使用。 Webpack 有一个不可不说的优点，它把所有的文件都都当做模块处理，JavaScript 代码，CSS 和 fonts 以及图片等等通过合适的 loader 都可以被处理。 基本配置Entry(入口) 入口起点指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。 1234567// webpack.config.jsmodule.exports = &#123; // 入口配置 entry: &#123; index: "./src/index.js" &#125;&#125;; Output(出口) output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。 12345678module.exports = &#123; // 出口配置 output: &#123; // 必须是绝对路径 path: path.resolve(__dirname, "dist"), filename: "js/bundle.js" &#125;&#125;; Loaders 首先，webpack 自身只理解 JavaScrip，所以针对其他的文件，我们需要借助 loader 去处理。 loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。 比如对于 css 文件，我们可以这样写： 1234567891011module.exports = &#123;module: &#123; rules: [ &#123; // 通过正则匹配要处理的文件 test: /\.css$/, use: ["style-loader", "css-loader"] &#125; ]&#125;&#125;; 其他一些常用 loader image-loader：加载并且压缩图片文件 babel-loader：把 ES6 转换成 ES5 css-loader：加载 CSS，支持模块化、压缩、文件导入等特性 style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。 eslint-loader：通过 ESLint 检查 JavaScript 代码 file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去 source-map-loader：加载额外的 Source Map 文件，以方便断点调试 Plugins(插件) loader 被用于转换某些类型的模块，而 Plugins(插件)则可以用于执行范围更广的任务。 其他一些常用 Plugins html-webpack-plugin //生成 html 文件* copy-webpack-plugin //复制到剪切板* clean-webpack-plugin //这个插件是在打包的时候使用的 因为打包的 output 中使用了 hash 码，使文件名是唯一的，不删除的话 dist 文件夹里面就会一堆文件 define-plugin：//定义环境变量 commons-chunk-plugin：//提取公共代码 uglifyjs-webpack-plugin：//通过 UglifyES 压缩 ES6 代码 Mode(模式) 通过选择 development 或 production 之中的一个，来设置 mode 参数，你可以启用相应模式下的 webpack 内置的优化 做一个 demo 吧初始化项目 cd 进入新建文件夹 wpdemo 执行命令: npm init -y 就会创建 package.json 文件 新建 src 目录,用于放置我们的开发所需要的 css、img、js 和 html 文件(和平时开发一致就好) 在根目录新建 index.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 我们给最终编译出的js叫做bundle.js--&gt; &lt;script src="./dist/js/bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在根目录新建 webpack.config.js,这是 webpack 的默认配置文件 webpack 默认会读取 webpack.config.js 中的相关配置，如果更换其他名字，webpack 默是找不到的（当然我们也可以去指定 webpack 读取的配置文件） 安装 webpack 和 webpack-cli 在当前文件夹 执行命令: npm install –save-dev webpack webpack-cli ps: 为什么要装 webpack-cli ,是因为以前 webpack 的 cli 工具移动到了一个专门的包(webpack-cli)里了 ps: 如果是 全局安装 webpack 则执行: npm install -g webpack (鉴于前端技术迭代太快,一般不用这个) 接下来我们配置下 package.json，把”scripts”字段修改为： 123"scripts": &#123; "build": "webpack --mode development"&#125; 新建入口文件和配置 webpack.config.js 在 src/js 目录下新建 index.js 文件，作为 webpack 的入口文件，文件内容为： 1console.log("hello world"); 接下来我们打开 webpack.config.js ，配置下我们的编译规则 12345678910111213const path = require("path");module.exports = &#123; // 入口配置 entry: &#123; index: "./src/js/index.js" &#125;, // 出口文件 output: &#123; // 必须是绝对路劲 path: path.resolve(__dirname, "dist"), filename: "js/bundle.js" &#125;&#125;; ps: __dirname 是 node 暴露给全局的一个变量,表示当前文件所在的目录,path 模块是 node 自带的模块，用来处理路径的 在 webpack-demo 目录下执行 npm run build 命令 此时查看 dist/js 目录，会发现新增了一个 bundle.js 的文件，然后打开 index.html 文件，在 f12 打开控制台，是不是输出了 hello world 啊？ 针对 css 文件和 img 文件的 Loaders通过上面的小例子，发现好像少了些什么，一个页面不可以只有 js 的吧，我们强大的 css 和好看的 img 呢？ 接下来就开始学习强大的 Loaders 啦 安装 style-loader、css-loader 和 url-loader、file-loader 执行命令: npm install style-loader css-loader url-loader file-loader –save-dev 这里特别说明下，file-loader 与 url-loader 都是在 webpack 中引入图片的解决方案，但是与 file-loader 不同，url-loader 封装了 file-loader，并且可以在图片大小小于设定的 limit 的时候返回的是一个 bDataURL（base64 码），大于 limit 时会调用 file-loader 对图片进行处理。 添加 webpack 规则 在 webpack.config.js 添加规则 1234567891011121314151617181920212223module: &#123; rules: [ &#123; test: /\.css$/, // 从右向左(从下向上)开始执行 use: ["style-loader", "css-loader"] &#125;, &#123; test: /\.(png|jpg|gif)$/, use: [ &#123; loader: "url-loader", options: &#123; // 小于10kb转成base64 limit: 10240, // 打包后的文件夹 outputPath: "img" &#125; &#125; ] &#125; ];&#125; 在 src/css 目录下新建 index.css，在 src/img 目录下放一个 img.jpg 后，接下来就是修改我们的代码了 1234/* css */body &#123; background: skyblue;&#125; 12345678// 修改我们的入口文件index.jsimport "../css/index.css";import imgSrc from "../img/img.jpg";const img = document.createElement("img");img.src = "./dist/" + imgSrc;document.body.appendChild(img);console.log("hello world"); 在运行一下 npm run build，然后打开我们的浏览器，页面是不是有了个蓝色背景和一张图片呢 安装 babel有的浏览器对 es6 不兼容 所以针对我们写的 js 也需要做下 babel 编译 安装 babel 执行命令: npm install babel-core babel-loader babel-preset-env –save-dev 新建.babelrc 文件 这里 babel 会默认读取根目录下的.babelrc 文件作为 babel 的编译规则 1234567&#123;"presets": [ ["env", &#123; "modules": false &#125;]]&#125; 配置 js 的 loader 规则 增加 loader 的配置项： 123456789101112module.exports = &#123; module: &#123; rules: [ &#123; test: /\.js$/, use: ["babel-loader"], // 除node_modules目录外，其他都用babel编译 exclude: /node_modules/ &#125; ] &#125;&#125;; 拓展 output 规则现在我的 output 的文件名是定死的，每次打包名字都不会改变, webpack 提供提议[name]的占位符， 表示入口的的文件名。 于是修改下 webpack.config.js: 123456output: &#123; // 必须是绝对路径 path: path.resolve(__dirname, 'dist'), filename: 'js/[name].js'&#125; 那么问题又来了，我们怎么引入我们动态生成的[name].js 呢？也许有人说改成和入口文件一样的名字不就行了吗？ 这样的确是一种方案，但是能不能可以通过一个模板，自动注入我们生成的 js 文件呢？接下来就是用我们更强大的插件啦 常用的插件html-webpack-plugin针对于上面的问题，我们就可以借助 html-webpack-plugin 自动生成我们的 html 啦。 安装 html-webpack-plugin 执行命令 npm install html-webpack-plugin –save-dev 创建我们的模板页面 在 src 目录下新建 index.html，用于我们的模板页面，如下： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 这样我们就可以直接打开 dist 的 index.html 文件就好，不需要根目录下的 index.html 文件了 打开 index.html 文件后，你会发现图片 404，并且多了一些文件，我们先解决我们图片 404 的问题，因为我们的 index.html 所在目录目录发生了改变，所以 js 也需要跟着改变一下 1234567import "../css/index.css";import imgSrc from "../img/img.jpg";const img = document.createElement("img");// 更改img.src = imgSrc;document.body.appendChild(img);console.log("hello world"); clean-webpack-plugin到目前为止，我们学会了动态生成模板页面了，然后怎么清除之前多余的文件呢，这里我们需要借助 clean-webpack-plugin 插件 安装 clean-webpack-plugin 执行命令: npm install clean-webpack-plugin –save-dev 配置 webpack.config.js 规则 123456789101112// 注意! 这种写法4+后会报错CleanWebpackPlugin is not a constructorconst CleanWebpackPlugin = require("clean-webpack-plugin");module.exports = &#123; plugins: [new CleanWebpackPlugin(["dist"])]&#125;;// 正确写法const &#123; CleanWebpackPlugin &#125; = require("clean-webpack-plugin");module.exports = &#123; plugins: [new CleanWebpackPlugin()]&#125;; 最新的需要进行解构,即 const {CleanWebpackPlugin} = require(“clean-webpack-plugin”);其次它支持传入参数的形式，如果什么都不配置默认删除未使用的资源，如果想删除指定文件需要配置 cleanOnceBeforeBuildPatterns 参数(已经没有 root 选项了),表示在构建之前指定目录，当然还有 cleanAfterEveryBuildPatterns 参数，具体可以参考 npm 文档. 这样每次执行我们命令的时候就会先删除 dist 目录在创建 服务器运行到目前为止，我们已经怎么通过模板自动生成页面，自动生成 js，可是每次更改代码后都需要 webpack 重新去编译，并且我们的文件还是以文件系统在浏览器打开的，很显然，这不是 webpack 的正确姿势。因此，我们考虑怎么让我们的项目运行在服务器端。 DIY 一个临时的静态服务器既然我们知道了我们最终生成的文件在 dist 文件夹，那么我们好像只要将 dist 文件夹的文件在服务器端跑起来不就好了吗？那么用 express 搭建一个静态的服务器,尝试一下吧. 在根目录下新建一个 app.js 文件，并安装 express 执行命令: npm install express –save-dev 在 app.js 中，我们利用 express 写一个简单的服务器 12345// app.jsconst express = require("express");const app = express();app.use("/", express.static(__dirname + "/dist"));app.listen(3000); 配置下我们 package.json 的 script 字段 为了统一下我们的命令，不在命令行执行 node app.js，我们统一用 npm 执行我们的命令 1234"scripts": &#123; "server": "node app.js", "build": "webpack --mode development" &#125; 然后我们可以在控制台执行：npm run server 接下来我们在浏览器输入 localhost:3000，是不是可以看到我们打包后的文件了 devServer写完这个，虽然他可以在服务器端运行我们的代码，但是我们还是要重新通过 webpack 编译，而且还不能实现热更新和自动从浏览器中打开，当然我们也可以通过引入 node 的 child_process 模块中的 exec 来自动打开我们的文件，因为本篇不是 node 的教程就不拓展了。 其实对于这个问题，webpack 也早已经想到了，所以他就提供了一个 devServer 的配置字段，可以配置我们的本地服务器，解决热更新问题。 安装 webpack-dev-server 执行命令: npm install webpack-dev-server –save-dev 配置 webpack.config.js 规则 增加一个 devServer 字段 以及在 plugins 调用一下 webpack 提供的热更新模块 12345678910111213141516171819202122// webpack.config.jsconst webpack = require("webpack");module.exports = &#123; plugins: [ // 使用热更新 new webpack.HotModuleReplacementPlugin() ], // 开发服务器 devServer: &#123; // 设置服务器访问的基本目录 contentBase: path.resolve(__dirname, "dist"), // 设置开发服务器的地址 host: "localhost", // 设置开发服务器的端口 port: 8080, // 自动打开浏览器 open: true, // 配置热更新 hot: true &#125;&#125;; 这样我们就可以实现热更新啦，热更新的好处不知道发现没有，他只会替换更新的部分,而不会把整个页面给刷新。我们可以尝试修改下 index.css，把 body 的背景修改成红色就可以发现效果了,然后在尝试把 hot 去掉，在修改 body 背景色看看，会发现整个页面都刷新了。 打包优化在服务器看到我们的页面没什么问题了之后，我们就可以打包我们的文件啦，打包过后其实我们会发现我们的文件好像有点大，知识在控制台输出一个 helloworld 还有创建了一个 img 标签，居然要 50kb 的代码，简直太大了吧。 压缩 jswebpack4 提供了 mode 的 production 属性就是压缩 js 的，我们通过命令行开启，修改 webpack.config.js 或者 package.json 的 script 就可以了，这里我采用 package.json 的方式 123"scripts": &#123; "build": "webpack --mode production"&#125; 由于 css 还在 js 里面，接下来我们单独提取出 css 提取 css提取 css 官方提供了两个方式，一个是 extract-text-webpack-plugin，另一个是 mini-css-extract-plugin，这里我们采用 extract-text-webpack-plugin，原因是 extract-text-webpack-plugin 提供更多的操作 api，相比 mini-css-extract-plugin 更为的好用。 首先安装 执行命令: npm install extract-text-webpack-plugin@next –save-dev ps: 一定要安装 extract-text-webpack-plugin@next,因为 extract-text-webpack-plugin 最新版本为 3.0.2，这个版本还没有适应 webpack 4 的版本 配置 webpack.config.js 规则,loader 的配置也需要修改一下 123456789101112131415161718192021222324252627// 提取cssconst ExtractTextPlugin = require("extract-text-webpack-plugin");module.exports = &#123; module: &#123; rules: [ &#123; test: /\.css$/, // 从右向左(从下向上)开始执行 // 提取css use: ExtractTextPlugin.extract(&#123; // 只在开发环境使用 // use style-loader in development fallback: "style-loader", use: ["css-loader"] &#125;) &#125; ] &#125;, plugins: [ // 提取css new ExtractTextPlugin(&#123; filename: "css/[name].css", // 根据不同环境走不同的配置（在开发环境下不使用） disable: process.env.NODE_ENV === "development" &#125;) ]&#125;; 这样不仅 css 提取出来了，连 js 也变的小了许多，然后打开 css 文件发现 css 文件居然没有压缩- -，然后我们接着配置一下我们的 loader，实现对 css 的压缩，或许你之前听过一个叫 cssnano 的神器，想用他来压缩，不用担心 css-loader 是默认把 cssnano 封装进去了 实际上 webpack 对于 loader 的 use 写法有很多种，我们之前用的是比较简单的一种，不使用任何的配置项，接下来我们配置一下压缩的配置项 打开 webpack.config.js，修改下 loader 的代码: 注意：新版的 css-loader 已经把 minimize 参数删除掉，下面请不要使用 1234567891011121314151617181920212223module.exports = &#123; module: &#123; rules: [ &#123; test: /\.css$/, // 从右向左(从下向上)开始执行 // 提取css use: ExtractTextPlugin.extract(&#123; // 只在开发环境使用 // use style-loader in development fallback: 'style-loader', use: &#123; loader:'css-loader', options: &#123; minimize: true //css压缩 &#125; &#125;, // 解决css打包背景图的路径问题 publicPath: '../' &#125;) &#125; &#125;&#125; 暴露第三方库很经常的时候，我们的页面不只是只有我们写的 js，还可能引入各种各样的库，比如 jquery，underscroe 这种第三方工具库，我们怎么把它暴露给我们的 js 呢，其实只需要用到 webpack 的 ProvidePlugin 插件 这插件是 webpack 自带的所以不需要安装，只需要我们修改 webpack 的配置规则 12345// 向全局暴露第三方库new webpack.ProvidePlugin(&#123; $: "jquery", jQuery: "jquery"&#125;); 提取公共 jsWebpack3 的 commonschunk hash 问题非常的不雅，使用复杂, Webpack4 直接将 CommonsChunkPlugin 插件改为 optimization.splitChunks 和 optimization.runtimeChunk 两个配置 1234567891011121314151617181920module.exports = &#123; optimization: &#123; splitChunks: &#123; cacheGroups: &#123; // 这会创建一个vendor代码块，这个代码块包含所有被其他入口(entrypoints)共享的代码。 vendor: &#123; test: /node_modules/, chunks: "initial", name: "vendor", priority: 10, enforce: true &#125; &#125; &#125;, // 为每一个入口默认添加一个只包含 runtime 的 chunk runtimeChunk: &#123; name: "runtime" &#125; &#125;&#125;; img 压缩 这个其实我不用 我都用熊猫压图的 安装 image-webpack-loader 执行命令: npm install image-webpack-loader –save-dev 修改下 loader 配置 123456789101112131415161718192021222324module.exports = &#123; module: &#123; rules: [&#123; test: /\.(png|jpg|gif)$/, use: [&#123; loader: 'url-loader', options: &#123; // 小于10kb转成base64 limit: 10240, // 打包后的文件夹 outputPath: 'img' &#125; &#125;, &#123; loader: 'image-webpack-loader', options: &#123; // 设置对jpg格式的图片压缩的程度设置 mozjpeg: &#123; progressive: true, quality: 65 &#125; &#125; &#125;] &#125;]&#125; css 优化——css 自动增加前缀我们知道在写 css 的时候由于要兼容不同厂商浏览器，一些比较新的属性需要给它们添加厂商前缀来兼容，移动端还好，一般只需要兼容 webkit，pc 接很苦逼啦，谷歌、火狐、欧朋、ie 每个都不一样，可以说泯灭人性啊。 针对于这个，我们就可以通过 webpack 来实现帮我们自动给 css 增加前缀，这里采用最常用的 postcss 中的 Autoprefixer 插件来给我们自动增加前缀 安装 postcss-loader 和 autoprefixer 执行命令: npm install postcss-loader autoprefixer –save-dev 新建 postcss.config.js 文件 代码如下： 12345678910111213module.exports = &#123; plugins: [ // browsers模式选择： // 主流浏览器最近2个版本用 last 2 versions // 全球统计有超过1 % 的使用率使用 &gt; 1% // 仅新版本用 ff &gt; 20 或 ff&gt;=20 . // cascade 是否美化属性值(默认为true) require("autoprefixer")(&#123; browsers: ["last 4 versions", "IE 10", "ff &gt; 10"], cascade: true &#125;) ]&#125;; 配置 webpack.config.js 的规则 123456789101112131415161718192021222324module.exports = &#123; module: &#123; rules: [&#123; test: /\.css$/, // 从右向左(从下向上)开始执行 // 提取css use: ExtractTextPlugin.extract(&#123; // 只在开发环境使用 // use style-loader in development fallback: 'style-loader', use: [&#123; loader: 'css-loader', options: &#123; minimize: true //css压缩 &#125; &#125;, &#123; loader: 'postcss-loader' &#125;], // 解决css打包背景图的路径问题 publicPath: '../' &#125;) &#125; &#125;&#125; 我们修改下 index.css 的代码，做个 body 的背景颜色由深到浅的悬浮过度动画 1234567body &#123; background: blue; transition: all 1s;&#125;body:hover &#123; background: skyblue;&#125; 运行 npm run dev，就可以看到我们的效果啦，并且该加上的前缀也加上了 css 优化篇——去除冗余 css 代码 安装 purify-css、purifycss-webpack 和 glob 执行命令: npm install purifycss-webpack purify-css glob –save-dev 123456789101112131415// 删除冗余css代码const PurifyCssWebpack = require("purifycss-webpack");// 用于获取指定文件夹下的文件const glob = require("glob");module.exports = &#123; plugins: [ // 删除冗余css代码 new PurifyCssWebpack(&#123; // purifycss会根据配置的路劲遍历你的HTML文件，查找你使用的CSS paths: glob.sync(path.join(__dirname, "src/*.html")), // 压缩css minimize: true &#125;) ]&#125;; 测试一波，我们在 index.css 增加一些无用代码,比如 123456.a &#123; background: #000;&#125;.b &#123; font-size: 30px;&#125; 运行 npm run build，再看看打包后的 index.css 是不没有这两个样式 使用 less 安装 less-loader 执行命令: npm install less-loader –save-dev 配置 webpack.config.js 的规则 其实和配置 css-loader 就类似了 12345678910111213141516171819module.exports = &#123; module: &#123; rules: [ &#123; test: /\.less$/, // use:['style-loader','css-loader','less-loader'] // 如果想分离less use: ExtractTextPlugin.extract(&#123; // 只在开发环境使用 // use style-loader in development fallback: "style-loader", use: ["css-loader", "postcss-loader", "less-loader"], // 解决css打包背景图的路径问题 publicPath: "../" &#125;) &#125; ] &#125;&#125;; 常用命令npm info webpack 可查看 webpack 相关信息，第一条就是版本号。 安装:cd webpack-demo //进入一个空文件npm init -y //初始化npm install webpack webpack-cli –save-dev //安装 webpack 和 cli]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode配置]]></title>
    <url>%2F2019%2F08%2F06%2FVSCode%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[又来看这篇文章啦 这次是换工作了 还是重装系统了呢 扩展 Setting Sync 快速 copy 曾经安装的所有 VSC 插件 VSCode 安装扩展 Setting Sync 获取 tokens (记录在备忘录中 如果没有则按下述方法重新生成)进入 github -&gt; Settings 在左侧 Developer settings -&gt; Personal access tokens 点击按钮 Generate new token 新增一个 token 记住你自己生成的 token 值，忘记可以登录自己的 github 查看 回到 VSCode 配置将 token 配置到本地Shift + Alt + U 在弹窗里输入你的 token， 回车后会生成 syncSummary.txt 文件（也有可能不创建）syncSummary.txt 文件会存储 VSCode 的设置及所安装的插件列表 有点类似 package.json 这样形式的文件可以将自己的 token 分享到自己的团队里面去，这样团队可以共用一套设置。 小 tip: Setting Sync 快捷键：上传： Shift + Alt + U (Sync: Update / Upload Settings)下载： Shift + Alt + D (Sync: Download Settings) vscode 的 Mac 个人配置123456789101112131415161718192021222324252627282930313233&#123;“files.autoSave”: “afterDelay”,“editor.formatOnPaste”: true,“editor.formatOnType”: true,“editor.formatOnSave”: true,“explorer.confirmDelete”: false,“git.enableSmartCommit”: true,“emmet.triggerExpansionOnTab”: true,“emmet.includeLanguages”: &#123;“vue-html”: “html”,“vue”: “html”&#125;,“workbench.activityBar.visible”: true,“files.associations”: &#123;“.wxss”: “css”,“.swig”: “html”&#125;,“window.zoomLevel”: 0,“editor.minimap.enabled”: true,“editor.renderWhitespace”: “none”,“editor.renderControlCharacters”: false,“git.autofetch”: true,“px2rem.rootFontSize”: 75,“px2rem.isNeedNotes”: false,“workbench.statusBar.visible”: true,“terminal.integrated.shell.windows”: “C:\windows\System32\WindowsPowerShell\v1.0\powershell.exe”,“git.confirmSync”: false,“git.ignoreMissingGitWarning”: true,“workbench.iconTheme”: “vscode-icons”,“gitlens.advanced.messages”: &#123;“suppressShowKeyBindingsNotice”: true&#125;,&#125; wakatime]]></content>
      <tags>
        <tag>编译器配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[邀请码/验证码]]></title>
    <url>%2F2019%2F08%2F02%2F%E9%AA%8C%E8%AF%81%E9%82%80%E8%AF%B7%E7%A0%81%2F</url>
    <content type="text"><![CDATA[简简单单纯代码 12345678910&lt;div class="inputbox"&gt; &lt;input type="tel" pattern="[0-9]*" id="ipt" maxlength="6" unselectable="on" οnfοcus="this.blur()" /&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt; &lt;article class="sub"&gt;确定提交&lt;/article&gt; 123456789101112131415161718192021222324252627282930313233343536.inputbox &#123; margin: .666667rem 0; display: flex; justify-content: space-between; padding: 0 .866667rem; position: relative; span &#123; width: .88rem; height: .88rem; border: 2px solid rgba(255, 255, 255, 1); text-align: center; line-height: .88rem; color: #fff; font-size: .533333rem; &#125; input &#123; width: 1px; height: 1px; position: absolute; z-index: -100; left: 0; top: 0; opacity: 0; outline: none; color: transparent; &#125; input:focus &#123; outline: none; background: transparent; opacity: 0; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637//输入监测事件 Typescript$('.inputbox').on('click', function () &#123; $('#ipt').focus()&#125;)$('#ipt').focus()let num: any = new RegExp(/[0-9.]/);let span: any = document.querySelectorAll(".inputbox span");var ipt: any = document.querySelector("#ipt");ipt.value = ''$('#ipt').bind('input propertychange', function (this: any) &#123; var valth = this.value.length; for (var k = 0; k &lt; span.length; k++) &#123; span[k].innerText = ''; &#125; for (var i = 0; i &lt; valth; i++) &#123; if (!num.test(ipt.value[i])) &#123; ipt.value = ipt.value.substr(0, i); return false; &#125; span[i].innerText = ipt.value[i]; &#125;&#125;);// 判断输入$('.sub').on('click', async () =&gt; &#123; const iptValue = ipt.value const isEmpty = /^\d&#123;6&#125;$/ // alert(iptValue); if (!isEmpty.test(iptValue)) &#123; return Msg(&#123; content: '请填写六位数字邀请码' &#125;) &#125;&#125;)]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无缝滚动]]></title>
    <url>%2F2019%2F07%2F02%2F%E6%97%A0%E7%BC%9D%E6%BB%9A%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[js版123456789101112131415&lt;section class="listName"&gt; &lt;section class="title"&gt; &lt;article&gt;昵称&lt;/article&gt; &lt;article&gt;奖励&lt;/article&gt; &lt;/section&gt; &lt;div id="list"&gt; &lt;ul&gt; &lt;!-- &lt;li&gt; &lt;span class="name"&gt;最多****六字&lt;/span&gt; &lt;span class="time"&gt;2019/4/21 10:28:30&lt;/span&gt; &lt;/li&gt; --&gt; &lt;/ul&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/div&gt; &lt;/section&gt; 1234567891011.listName &#123; width: 100%; height: 13.453333rem; overflow: hidden; #list &#123; position: relative; max-height: 10rem; overflow: hidden; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637// 无缝滚动var timer;var len = 0;len = 10 //数据条数var Marquee = function (id) &#123; var container = document.getElementById(id), original = container.getElementsByTagName("ul")[0], clone = container.getElementsByTagName("ul")[1], speed = arguments[1] || 30; clone.innerHTML = original.innerHTML; var rolling = function () &#123; if (container.scrollTop == clone.offsetTop) &#123; container.scrollTop = 0; &#125; else &#123; container.scrollTop++; &#125; &#125; timer = setInterval(rolling, speed)&#125;// 触发方法1 进入页面数据超过6条就触发if (len &gt; 6) &#123; Marquee('list')&#125;// 触发方法2 用户滚动页面后触发// $(window).on('scroll', function () &#123;// var scrollTop = $(this).scrollTop();// var scrollHeight = $('body')[0].scrollHeight;// var offsetTop = $('.tabBoxCenter').offset().top + $('#list').height()// if (len &gt; 5 &amp;&amp; scrollHeight - scrollTop &lt;= offsetTop) &#123; //条数大于5条和距离顶部高度达到才会触发// (timer == undefined || !timer) &amp;&amp; Marquee('list')// &#125; else &#123;// clearInterval(timer)// timer = null// &#125;// &#125;) vue版尝试自己写了滚动但是卡卡顿顿的看起来很恶心就不放出来了最终还是用了这个 vue-seamless-scroll在线演示文档：https://chenxuan1993.gitee.io/component-document/index_prod#/component/seamless-default https://www.cnblogs.com/AdamFamily/p/10649232.html]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目中遇到的问题]]></title>
    <url>%2F2019%2F07%2F02%2F%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[页面中嵌入的组件如何自动刷新 给组件一个key 如何判断数组对象里面有相同的元素https://segmentfault.com/q/1010000010928885如 var a = [{des:”qwe”,b:”reg”},{des:”vfg”,b:”fgdfd”},{des:”qwe”,b:”fdfd”},{des:”vfg”,b:”fdfd”}] let arr=[{resourceCode: “RESb4dd24f2bb9a490a82f28213f063ccb3”,insuredLands: “150000,210000”},{resourceCode: “RESb4dd24f2bb9a490a82f28213f063ccb3”,insuredLands: “210000,330000”},{resourceCode: “RESdecbbef35c0c4d3b8af0522a192feaab”,insuredLands: “330000,360000”}] arr.reduce((res,item)=&gt;{ const resourceCode = item.resourceCode const isHas = res.get(resourceCode) res.set(resourceCode,isHas ? { resourceCode, insuredLands:[…new Set([…isHas.insuredLands.split(‘,’),…item.insuredLands.split(‘,’)])].join(‘,’) }:item) return res},new Map) iview tree 复选的时候 要做父子节点不联动的需求:check-strictly=”true” // 显示复选框的前提下，是否让父子节点不联动 https://www.cnblogs.com/lishiyuan/p/10638425.htmliview弹窗的问题是因为第一个弹窗关闭影响了第二个 这算是iview框架的坑应该让第一个完全关闭再去弹第二个嘛我按照他写的给第二个套了定时器解决了]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上拉加载更多]]></title>
    <url>%2F2019%2F01%2F21%2F%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[加载时的loding12345678&lt;div class="scrollload-bottom"&gt; &lt;div style="height: 50px;"&gt; &lt;div class="sl-ld"&gt; &lt;div class="sl-ld-ball sl-ld-ball-anim"&gt;&lt;/div&gt; &lt;div class="sl-ld-ball sl-ld-ball-anim"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// 加载更多@-webkit-keyframes sl-ld-ball-anim1 &#123; 0% &#123; z-index: 1; -webkit-transform: translate3d(-18px, 0, 0); transform: translate3d(-18px, 0, 0) &#125; 50% &#123; -webkit-transform: translate3d(18px, 0, 0); transform: translate3d(18px, 0, 0) &#125; to &#123; z-index: 2; -webkit-transform: translate3d(-18px, 0, 0); transform: translate3d(-18px, 0, 0) &#125;&#125;@keyframes sl-ld-ball-anim1 &#123; 0% &#123; z-index: 1; -webkit-transform: translate3d(-18px, 0, 0); transform: translate3d(-18px, 0, 0) &#125; 50% &#123; -webkit-transform: translate3d(18px, 0, 0); transform: translate3d(18px, 0, 0) &#125; to &#123; z-index: 2; -webkit-transform: translate3d(-18px, 0, 0); transform: translate3d(-18px, 0, 0) &#125;&#125;@-webkit-keyframes sl-ld-ball-anim2 &#123; 0% &#123; z-index: 2; -webkit-transform: translate3d(18px, 0, 0); transform: translate3d(18px, 0, 0) &#125; 50% &#123; -webkit-transform: translate3d(-18px, 0, 0); transform: translate3d(-18px, 0, 0) &#125; to &#123; z-index: 1; -webkit-transform: translate3d(18px, 0, 0); transform: translate3d(18px, 0, 0) &#125;&#125;@keyframes sl-ld-ball-anim2 &#123; 0% &#123; z-index: 2; -webkit-transform: translate3d(18px, 0, 0); transform: translate3d(18px, 0, 0) &#125; 50% &#123; -webkit-transform: translate3d(-18px, 0, 0); transform: translate3d(-18px, 0, 0) &#125; to &#123; z-index: 1; -webkit-transform: translate3d(18px, 0, 0); transform: translate3d(18px, 0, 0) &#125;&#125;.sl-ld &#123; position: relative; width: 0; margin: 0 auto; height: 50px&#125;.sl-ld-ball &#123; width: 16px; height: 16px; border-radius: 50%; position: absolute; top: 17px; left: -8px&#125;.sl-ld-ball:first-of-type &#123; -webkit-transform: translate3d(-18px, 0, 0); transform: translate3d(-18px, 0, 0); background: #0462dc; z-index: 1&#125;.sl-ld-ball:nth-of-type(2) &#123; -webkit-transform: translate3d(18px, 0, 0); transform: translate3d(18px, 0, 0); background: #fc0284; z-index: 2&#125;.sl-ld-ball-anim:first-of-type &#123; -webkit-animation: sl-ld-ball-anim1 1.2s linear infinite; animation: sl-ld-ball-anim1 1.2s linear infinite&#125;.sl-ld-ball-anim:nth-of-type(2) &#123; -webkit-animation: sl-ld-ball-anim2 1.2s linear infinite; animation: sl-ld-ball-anim2 1.2s linear infinite&#125; 1234567891011121314151617// 上拉加载let is_load = false //加载标识 免重复加载$(window).scroll(function () &#123; var scrollTop = $(this).scrollTop(); var scrollHeight = $('body')[0].scrollHeight; var windowHeight = $(this).height(); // console.log(scrollTop, scrollHeight, windowHeight); if (scrollTop + windowHeight &gt;= scrollHeight - 50) &#123; if (is_load) &#123; page += 1 is_load = false 各种数据加载渲染…… 结束后is_load = true &#125; &#125;&#125;);]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web存储]]></title>
    <url>%2F2018%2F10%2F02%2FlocalStorage%2F</url>
    <content type="text"><![CDATA[存储 localStorage sessionStorage cookier 相同点：都保存在浏览器端，同源的 不同点： 传递方式不同 cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 数据大小不同 cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。 sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 数据有效期不同 sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持； localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据； cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 作用域不同 sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面； localStorage 在所有同源窗口中都是共享的； cookie也是在所有同源窗口中都是共享的。 Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。 localStorage - 没有时间限制的数据存储 只能存取字符串形式 但是不会自动将Json对象转成字符串形式 so 存储前先用JSON.stringify()方法将json对象转换成字符串形式123456如果存的是json 要多一步--- data = JSON.stringify(data);localStorage.setItem("temp",data); 存localStorage.getItem("temp") 取后续要操作该JSON对象，要将之前存储的JSON字符串先转成JSON对象再进行操作--- obj=JSON.parse(localStorage.getItem("temp"));localStorage.removeItem("temp"); 清除指定localStorage.clear() 清除所有 sessionStorage - 关闭标签页后清除数据 只能存取字符串形式 他的存取清除方式都和localStorage是一样的！12sessionStorage.setItem('temp',data); 存sessionStorage.getItem("temp") 取 cookier - 兼容好 但 不安全-cookie在http中是明文传递的，其中的数据都可以被他人访问篡改、盗用，容量限制-大小限制在4kb左右，增加流量-cookie每次请求都会被自动添加到Request Header中，无形中增加了流量。cookie信息越大，对服务器请求的时间越长。 字符串规律：（1）每个 cookie 都以名/值对的形式，即 name=value，（2）名称和值都必须是URL编码的，（3）且两对cookie间以 分号 和 空格 隔开。 name、value 、domian 、Path 、 Expires/max-age 、Size 、Http 、 Secure等都属cookie的属性。 domain 参数是用来控制 cookie对「哪个域」有效，默认为设置 cookie的那个域。 path用来控制cookie发送的指定域的「路径」，默认为”/“，表示指定域下的所有路径都能访问。例如cookie设置为”domain=.google.com.hk; path=/webhp”，那么只有”.google.com.hk/webhp”及”/webhp”下的任一子目录如”/webhp/aaa”或”/webhp/bbb”会发送cookie信息，而”.google.com.hk”就不会发送，即使它们来自同一个域。 expries/max-age失效时间 expries 表示的是失效时间，准确讲是「时刻」，max-age表示的是生效的「时间段」，以「秒」为单位。 简单存储 document.cookie=”temp=”+username;如 document.cookie = “test4=myCookie4; domain=.google.com.hk; path=/webhp; max-age=10800;” 鉴于他的参数比较多 我们一般封装方法来使用123456//写cookies，一个小时过期 function setCookie(name, value) &#123; var exp = new Date(); exp.setTime(exp.getTime() + 60 * 60 * 1000); document.cookie = name + "=" + escape(value) + ";expires=" + exp.toGMTString() + ";path=/"; &#125; path=/，path参数用来设置cookie路径，同一路径下不能存储相同名字的两个cookie，当存第二个的时候会把第一个覆盖其实相当于对第一个进行了赋值操作；不同路径下可以存储相同名字的cookie。读取时如果在多个路径下存在多个cookie，则会读取页面所对应的路径（不是物理路径，是cookie的路径）下的cookie，不注意这点可能会造成读取的cookie值不正确。删除时只能删除对应路径下的cookie，不指定路径，默认删除的是页面所对应的路径下的cookie。 12345678910//读取cookies function getCookie(name) &#123; var arr, reg = new RegExp("(^| )" + name + "=([^;]*)(;|$)"); if (arr = document.cookie.match(reg)) return unescape(arr[2]); else return null; &#125; 12345678//删除cookies function delCookie(name) &#123; var exp = new Date(); exp.setTime(exp.getTime() - 60 * 60 * 1000); var cval = getCookie(name); if (cval != null) document.cookie = name + "=" + cval + ";expires=" + exp.toGMTString() + ";path=/"; &#125; 删除时只能删除对应路径下的cookie，不指定路径，默认删除的是页面所对应的路径下的cookie。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用命令]]></title>
    <url>%2F2018%2F09%2F07%2F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[查看本机IPMac ifconfig （比如我的就是 然后拼接 http://192.168.31.31:8080/appIn/marathon3/） vs code1.运行安装依赖 cnpm install live-server -gf2.在运行 live-server mac 端口被占用 解决办法 查看端口号占用 终端输入：sudo lsof -i tcp:port 将port换成被占用的端口(如：8080、8888) 然后根据PID杀进程：sudo kill 716 12345sudo lsof -i :8080java 716 a 313u IPv6 0x1111111111111 0t0 TCP *:cslistener (LISTEN)sudo kill 716]]></content>
      <categories>
        <category>工作我是认真的</category>
      </categories>
      <tags>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APP方法]]></title>
    <url>%2F2018%2F08%2F02%2FAppFunction%2F</url>
    <content type="text"><![CDATA[登陆相关12345678910function login() &#123; if (isAndroid &amp;&amp; isApp) &#123; return WaveApp.gotoLogin() &#125; else if (isiOS &amp;&amp; isApp) &#123; HJBridgeHandle.callNativeFunction('gotoNewLogin', null, 'gotoNewLogin132456' + Math.random(), function (data) &#123; &#125;, function (data) &#123; // 重新登陆 &#125;) &#125;&#125; 获取token12345678910if (isAndroid) &#123; tokenin = WaveApp.getToken()&#125; else if (isiOS &amp;&amp; isApp) &#123; HJBridgeHandle.callNativeFunction('getIsLogin', null, 'getIsLogin123' + Math.random(), function (data) &#123; tokenin = data getAllData() &#125;, function (date) &#123; &#125;)&#125; 获取token,不会跳到登陆 因为iostoken是异步的原因，所以需要多获取一次 1234 HJBridgeHandle.callNativeFunction('getNewToken', null, 'getNewToken123' + Math.random(), function (data) &#123; tokenin = data; getAll()&#125;, function (data) &#123;&#125;); 更新token ps：因为安卓和ios的不同，安卓是调用web端的方法，而ios是web调用ios的方法 1234567891011121314151617181920212223242526272829getAndroidToken.prototype.count = 0function getAndroidToken(n) &#123; tokenin = n getAndroidToken.prototype.count++ getAndroidToken.prototype.count &gt; 1 ? login() : PageLoding()&#125;//安卓过期执行 自动调用上面的方法function getNowToken() &#123; if (isAndroid &amp;&amp; isApp) &#123; WaveApp.getLoginToken() &#125;&#125;//新版本iOS 没有token二次获取if (!tokenin) &#123; if (isiOS &amp;&amp; isApp) &#123; HJBridgeHandle.callNativeFunction('getUpdateToken', null, 'getUpdateToken8' + Math.random(), function (data) &#123; tokenin = data; PageLoding() &#125;, function (data) &#123; login() &#125;); &#125;&#125; else &#123; setTimeout(function () &#123; PageLoding() &#125;, 0)&#125; 个人中心1234567function getMyCenter() &#123; if (isAndroid) &#123; WaveApp.getMyCenter() &#125; else &#123; HJBridgeHandle.callNativeFunction('getMyCenter', null, 'getMyCenter123' + Math.random(), null, null) &#125;&#125; 实名认证1234567function gotoAuthentication() &#123; if (isAndroid) &#123; WaveApp.gotoAuthentication() &#125; else &#123; HJBridgeHandle.callNativeFunction('gotoAuthentication', null, 'gotoAuthentication456' + Math.random(), null, null) &#125;&#125; 绑定手机号1234567function bindPhone() &#123; if (isAndroid) &#123; WaveApp.bindPhone() &#125; else &#123; HJBridgeHandle.callNativeFunction('bindPhone', null, 'bindPhone123' + Math.random(), null, null) &#125;&#125; 绑定邮箱1234567function bindEmial() &#123; if (isAndroid) &#123; WaveApp.bindEmial() &#125; else &#123; HJBridgeHandle.callNativeFunction('bindEmial', null, 'bindEmial132' + Math.random(), null, null) &#125;&#125; 分析师1234567if (isAndroid) &#123; WaveApp.gotoTrader('2')&#125; else if (isiOS) &#123; window.webkit.messageHandlers.gotoTrader.postMessage(&#123; anId: String(2) &#125;)&#125; 分析师详情12345678// 传入分析师idif (isAndroid) &#123; WaveApp.getAnalystDetailsView('205')&#125; else if (isiOS) &#123; HJBridgeHandle.callNativeFunction('getAnalystDetailsView', &#123; anId: String(205) &#125;, 'getAnalystDetailsView1231', null, null)&#125; 进入appstore下载波浪智投 只有ios需要，安卓的直接通过 a 标签跳转即可 123HJBridgeHandle.callNativeFunction('applicationOpenURL', &#123; WebViewUrl: 'https://itunes.apple.com/cn/app/id413251709?mt=8'&#125;, 'applicationOpenURL132' + Math.random(), null, null) 联系客服12345if (isAndroid) &#123; WaveApp.customerService()&#125; else &#123; window.webkit.messageHandlers.customerService.postMessage(null)&#125; 跳转跟单页12345if (isAndroid &amp;&amp; isApp) &#123; WaveApp.goFollowPage()&#125; else if (isiOS &amp;&amp; isApp) &#123; HJBridgeHandle.callNativeFunction('goFollowPage', null, 'goFollowPage567' + Math.random(), null, null)&#125;]]></content>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise/async]]></title>
    <url>%2F2018%2F06%2F02%2Fpromise%2F</url>
    <content type="text"><![CDATA[常用Promise封装123456789101112131415161718192021222324252627282930313233343536373839window.AJAXurl='http://ptest.xxx.cn:8400/api/v1'window.request = function (mark, data) &#123; return new Promise(function (resolve, reject) &#123; $.ajax(&#123; type: 'POST', url: AJAXurl + mark, dataType: "json", data: $.extend(&#123; "sign": getSign(Date.parse(new Date())), "did": "12345dg", "apptype": "web", 'time': new Date() &#125;, data || &#123;&#125;), headers: tokenin||'', success: function (res) &#123; if (res.code === 0) &#123; resolve(res.data) &#125; else if (res.code == 10001) &#123; reject(res.code) &#125;else &#123; Msg(&#123; content: res.message &#125;) &#125; &#125;, error: function (err) &#123; // Msg(&#123; // content: JSON.stringify(err) // &#125;) &#125; &#125;); &#125;)&#125;//调用 request('/login',&#123; 'phone':'182.....', 'password':'prq' &#125;).then(res =&gt; &#123;&#125;) 小程序常用Promise封装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function request(url, data) &#123; let token = wx.getStorageSync('userToken') return new Promise((resolve, reject) =&gt; &#123; wx.showLoading(&#123; title: '加载中', &#125;) wx.request(&#123; url: httpsHead + url, data: Object.assign(&#123; 'apptype': "web", 'did': "12345dg", 'sign': getSign(Date.parse(new Date())) &#125;, data || &#123;&#125;), header: &#123; 'content-type': 'application/x-www-form-urlencoded', 'token': token || '' &#125;, method: "POST", success: res =&gt; &#123; if (res.data.code === 0) &#123; res.data.hasOwnProperty('count') ? resolve(res.data || res) : resolve(res.data.data || res); &#125; else if (res.data.code === 10001) &#123; wx.reLaunch(&#123; url: '/pages/user/login/index' &#125;) &#125; else &#123; wx.showToast(&#123; title: res.data.message || '网络有误', icon: 'success', duration: 1000 &#125;); &#125; wx.hideLoading() &#125;, fail: err =&gt; &#123; reject(new Error(err.status)) &#125; &#125;) &#125;)&#125;//调用 request('/login', &#123; type: 'login', code: this.data.codeNum, phone: this.data.codePhone &#125;).then(res =&gt; &#123; wx.setStorageSync('userInfo', res) wx.setStorageSync('userToken', res.token) wx.showToast(&#123; title: '登陆成功', icon: 'succes', duration: 1000 &#125;) setTimeout(() =&gt; &#123; wx.reLaunch(&#123; url: '../index' &#125;) &#125;, 1000) &#125;) 实际测试一下，看看Promise是如何异步执行的：setTimeout可以看成一个模拟网络等异步执行的函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 new Promise(function (resolve, reject) &#123; console.log('start new Promise...'); var timeOut = Math.random() * 2; console.log('set timeout to: ' + timeOut + ' seconds.'); setTimeout(function () &#123; if (timeOut &lt; 1) &#123; console.log('call resolve()...'); resolve('200 OK'); &#125; else &#123; console.log('call reject()...'); reject('timeout in ' + timeOut + ' seconds.'); &#125; &#125;, timeOut * 1000); &#125;).then(function (r) &#123; console.log('Done: ' + r); &#125;).catch(function (reason) &#123; console.log('Failed: ' + reason); &#125;);``` ## Promise还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。job1.then(job2).then(job3).catch(handleError); ``` javascript // 0.5秒后返回input*input的计算结果: function multiply(input) &#123; return new Promise(function (resolve, reject) &#123; console.log('calculating ' + input + ' x ' + input + '...'); setTimeout(resolve, 500, input * input); &#125;); &#125; // 0.5秒后返回input+input的计算结果: function add(input) &#123; return new Promise(function (resolve, reject) &#123; console.log('calculating ' + input + ' + ' + input + '...'); setTimeout(resolve, 500, input + input); &#125;); &#125; var p = new Promise(function (resolve, reject) &#123; console.log('start new Promise...'); resolve(123); &#125;); p.then(multiply) .then(add) .then(function (result) &#123; console.log('Got value: ' + result); &#125;); 用Promise.all()可以将；两个任务并行执行实现特点是：同时执行请求2，并在它们都完成后再执行then: 1234567891011121314151617181920212223242526272829 Promise.all([ request('userInfo', &#123; //个人资料 article_id: articleId &#125;), request('friendList', &#123; //好友列表 article_id: articleId, page: page, limit: limit &#125;), request('new') //消息 ]).then(function (res) &#123; console.log(res[0],res[1],res[2]) &#125;)``` ## 有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用Promise.race()实现：特点是： 由于p1执行较快，Promise的then()将获得结果'P1'。p2仍在继续执行，但执行结果将被丢弃。``` javascript var p1 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 500, 'P1'); &#125;); var p2 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 600, 'P2'); &#125;); Promise.race([p1, p2]).then(function (result) &#123; console.log(result); // 'P1' &#125;);]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各类验证]]></title>
    <url>%2F2018%2F06%2F02%2F%E5%90%84%E7%B1%BB%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[终端是否安卓window.isAndroid = navigator.userAgent.indexOf(‘Android’) &gt; -1 || navigator.userAgent.indexOf(‘Adr’) &gt; -1; //android终端 终端是否IOSwindow.isiOS = !!navigator.userAgent.match(/(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端 终端是否APPwindow.isApp = (isAndroid || isiOS) &amp;&amp; (typeof window.webkit !== ‘undefined’ || typeof WaveApp !== ‘undefined’);]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scss]]></title>
    <url>%2F2018%2F05%2F02%2Fsass%2F</url>
    <content type="text"><![CDATA[常用到的其实就是嵌套子元素，代码块，变量，继承 常用代码块123456789101112131415161718@mixin bgCover($url) &#123; background: url($url) center no-repeat; background-size: cover;&#125;//调用 @include bgCover('../img/icon.png');%flexRow &#123; display: flex; align-items: center; justify-content: center;&#125;//调用 @extend %flexRow;%flexColumn &#123; display: flex; flex-direction: column; align-items: center;&#125; 1.自定义变量1234$color:pink;.test1&#123; background-color:$color;&#125; 2.插入一个变量1234$right:right;.test2&#123; border-#&#123;$right&#125;:1px solid #000;&#125; 3.子元素书写12345.text3&#123; .text33&#123; border:1px solid; &#125; &#125; 4.样式的加减乘除123456$paramer:3;.text4&#123; height:(1px+3px); width: (96px/6); right: $paramer*4;&#125; 5.继承1234567.class5&#123; border:1px solid red;&#125;.class5E&#123; @extend .class5; font-size:20px;&#125; 6.代码块的复用123456789101112131415@mixin text6 &#123; height:50px; left:20px;&#125;.text6M&#123; @include text6&#125;//这里的mixin就是定义一个可以复用的代码段，当然我们也可以给它传递一个参数，就像这样一样：@mixin bgCover($url) &#123; background: url($url) center no-repeat; background-size: cover;&#125;.text6N&#123; @include bgCover('../img/icon.png');&#125; 7.if语法，通过对if的判断来决定使用那一套样式1234567891011121314151617.text7&#123; @if 1 +2 == 3 &#123; border:1px solid ; &#125; @if 5 &lt; 3 &#123; border:2px dsahed red; &#125;&#125;当然，我们都知道if一般是要和else配合的，所以我们也可以这样写.test77&#123; @if lightness($color) &gt; 30%&#123; background-color:#fff; &#125;@else&#123; background:#0ff; &#125;&#125;这里的lightness是一个scss颜色函数，$color指向之前定义的值。 8.循环语法，包括最常见的三种循环方法，for,while,each123456789101112131415161718192021//for 循环@for $i from 1 to 5 &#123; .item-#&#123;$i&#125; &#123; border:#&#123;$i&#125;px solid; &#125;&#125;//while 循环$m:8;@while $m &gt; 0 &#123; .items-#&#123;$m&#125; &#123; width:2em*$m; &#125; $m:$m - 2 ;&#125;//这里可以对$m进行运算 让它每次都减去2//each 语法@each $img in q,w,e,r &#123; .#&#123;$img&#125; &#123; background-image:url('#&#123;$img&#125;.png') &#125;&#125; 9.函数语法123456@function double ($number)&#123; @return $number*2;&#125;.text9&#123; font-size:double(20px);&#125; 10.import导入语法1@import 'other.scss']]></content>
      <tags>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Meta标签]]></title>
    <url>%2F2018%2F05%2F01%2Fmeta%2F</url>
    <content type="text"><![CDATA[目前webview用到的meta标签12345678910&lt;meta charset="UTF-8"&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"&gt;&lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;&lt;meta name="keywords" content="****,外汇跟单,外汇交易平台,外汇跟单社区,外汇跟单系统,外汇代理合作机构"&gt;&lt;meta name="description" content="****是一款致力于为用户提供可靠的外汇跟单平台的智能投顾软件,提供外汇跟单系统,外汇交易入门,外汇分析软件"&gt;&lt;meta http-equiv="Expires" content="-1"&gt;&lt;meta http-equiv="Pragma" content="no-cache"&gt;&lt;meta http-equiv="Cache-control" content="no-cache"&gt;&lt;meta http-equiv="Cache" content="no-cache"&gt;&lt;!-- &lt;link rel="shortcut icon" href="wave.ico"&gt; --&gt; 目前pc页用到的meta标签123456&lt;meta charset="UTF-8"&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=1.0"&gt;&lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;&lt;meta name="keywords" content="****,外汇跟单,外汇交易平台,外汇跟单社区,外汇跟单系统,外汇代理合作机构"&gt;&lt;meta name="description" content="****是一款致力于为用户提供可靠的外汇跟单平台的智能投顾软件,提供外汇跟单系统,外汇交易入门,外汇分析软件,外汇模拟交易平台,外汇策略,外汇理财,外汇交易高手"&gt; &lt;!-- &lt;link rel="shortcut icon" href="wave.ico"&gt; --&gt; Edge 模式通知 /指示IE以目前可用的最高模式显示内容 直接将IE8使用IE7进行渲染 文字编码 采用的语言 他的作者 他的版权 对网站的简单描述 本网站的关键字 打开网页，则自动以原始比例显示，并且不允许用户修改的话 而则是可以让网页的宽度自动适应手机屏幕的宽度。其中：width=device-width ：表示宽度是设备屏幕的宽度initial-scale=1.0：表示初始的缩放比例minimum-scale=0.5：表示最小的缩放比例maximum-scale=2.0：表示最大的缩放比例user-scalable=yes：表示用户是否可以调整缩放比例]]></content>
      <tags>
        <tag>meta</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识vue]]></title>
    <url>%2F2018%2F04%2F03%2Fvue%2F</url>
    <content type="text"><![CDATA[搭建 vue 项目 安装 node 在终端中 凡是命令行中带 –global 或者-g(简略)的前面都加上 sudo 创建项目先去到对应的文件夹cd Desktop/vue 测试/然后创建 vue init webpack vue-webpack其中(vue-webpack)是你创建的文件名字 或者使用其他模板 webpack-simple 接着我们进入到刚才创建的项目文件中 cd vue-webpac再安装依赖 npm install 打开项目 npm run dev 查看 node 版本 node –v 查看 npm 版本 npm –v 查看 vue 版本 vue -V 所遇到的问题:vue 中 npm run dev 运行项目不能自动打开浏览器!(到 main.js 中改一个参数的值)http://blog.csdn.net/bright2017/article/details/78825333 vue list 查看有哪些模板可以调用； 在运行 npm run dev 中可以使用 cnpm run dev 来代替。其中安装 cnpm 命令 npm install -g cnpm –registry=https://registry.npm.taobao.org 刚开始新建页面空白 发现 webpack 模板需要手动在 main.js 中 new vue 里添加 render: h =&gt; h(App), sublime 对 vue 的项目没有高亮安装一个插件就好了, 知乎有:https://www.zhihu.com/question/52215834 如果有端口冲突 就试试到 build 文件中的 dev-server.js 的 16 行改 var port = 8081 基本语法1234567891011121314151617181920212223242526&lt;script src=&quot;app.js&quot;&gt;&lt;script/&gt; 一定要应用在 body 后面引用 cdn 实例化对象 在页面中创建根容器~ el: element需要获取的元素,一定是html中的根容器元素 data: 用于存储数据~ methods: 用于存储各种方法 里面可以字符拼接 也可以直接this. 去拿实例化中其他的vue对象 (一旦触发其中一个方法 methods里面所有的方法都会执行一遍)~computed:计算属性 (比methods性能要好 只执行指定方法) 但是它操作的是虚拟dom所以只有耗时大量计算如搜索这种才会用computed~ 给属性绑定data中的值 在属性前加上v-bind:~ 给页面中插入data中定义的结构 在要插入的标签前括号中v- html=&quot;websideTag&quot;在页面中直接操作改变数据 写在标签身上一般不这么做 v-on:click=&quot;age++&quot;单击v-on:click= &quot; &quot; 双击v-on:dblclick=&quot; &quot; 移动v-on:mousemove=&quot;&quot;v-on: 可以简略为@ 如 @click=&quot;&quot;事件修饰符 在事件后加 .修饰符如@click.once=&quot; &quot;.stop阻止事件继续传播.prevent阻止默认事件.once只触发一次键值修饰符 v-on:keyup.enter=&quot;&quot; 也可以连续条件 v-on:keyup.alt.enter=&quot;&quot; 双向数据绑定123456789一定是要有输入和输出的地方 所以一定会是和input select textarea 这三个有关1.给输出的标签绑定v-model=&quot;name&quot;,当标签内容发生变化 name的值同时改变 如果data中声明了变量text 那么v-model=&quot;text&quot; input的value值就赋给了text2.(ref用于标记 在input标签身上标记ref=&quot;name&quot; 那么在js中取this.$refs.name就选择到了那个input 那么this.$refs.name.value就拿到了那个input的value值)结构中调用方法&#123;&#123; methods() &#125;&#125; 如果是事件触发v-on:click=&quot;methods()&quot;结构中调用computed 直接&#123;&#123; computed &#125;&#125;不需要()结构中调用data &#123;&#123; data &#125;&#125; 如果是 插入标签v-html=&quot;websideTag&quot; 更改属性v-bind:href=&quot;data&quot;data v值是false true时不需要”” changcolor:false, changleng:false可再标签身上直接写v-on:click=&quot;data = !data&quot; v-on:click=&quot;data++&quot; 动态加载 css 的时候 用方法操作类1234567891011v-bind:class=&quot; data / methods() / computed&quot;v-bind:class=&quot;&#123;changImg:change&#125;&quot;v-show=&quot;!change&quot;v-bind:style=&quot;&#123;width:reduce + &apos;%&apos;&#125;&quot;v-on:click=&quot;bobo()&quot;v-if 不占位 在dom结构中不存在 v-show占位存在v-for=&quot;(value, key, index) in object&quot; 写在模版template 上 template是不会被渲染出来的&lt;\li&gt; &#123;&#123;value&#125;&#125; / &#123;&#123;index&#125;&#125; / &#123;&#123;value.key&#125;&#125; &lt;\/li&gt;实例化两个对象 在js中也可以去操控另一个对象里面的内容one.title=&quot;改变one对象里面的title内容&quot; 路由 须先安装通过 cd 命令进入项目目录里12345678910111213141516171819202122232425执行以下命令 cnpm install vue-router --save路由不需要重新请求和整个页面的刷新就可以去到要去的页面1. 先在main.js引入路由模块 使用路由模块import VueRouter from &apos;vue-router&apos; //1.引入vue-routerVue.use(VueRouter)2. 配置路由var router = new VueRouter(&#123; routes:[ &#123;path:&apos;/&apos;,component:Home&#125;, &#123;path:&apos;/helloworld&apos;,component:HelloWorld&#125; ], mode:&quot;history&quot; //6配置另一个属性去掉网址中#/&#125;)3. 定义路由 在el: &apos;#app&apos;, 后面写上 router,4. 导入路由中相关组件import Home from &apos;./components/Home&apos;import HelloWorld from &apos;./components/HelloWorld&apos;6. 配置另一个属性去掉网址中#/ mode:&quot;history&quot;7. 跳转 &lt;router-link to=&quot;/lixin&quot;&gt;lixin User组件&lt;/router-link&gt; 一定要在路由末尾加上&lt;router-view&gt;&lt;/router-view&gt; http 请求1234567891011121314151617181920212223241. http请求 和路由的使用方法差不多通过cd命令进入项目目录里 执行以下命令 cnpm install vue-resource --save2. 第一二步和路由一样 在main.js里面引用和使用 import VueResource from &apos;vue-resource&apos; Vue.use(VueResource)3. 在需要http请求的组件中写created()&#123; //在页面显示前拿到数据 this.$http.get(&quot;http://jsonplaceholder.typicode.com/users&quot;) .then((data) =&gt;&#123; //如果请求到数据会执行一个.then函数 console.log(data); this.conten = data.body //把数据赋给以声明的变量 &#125;) &#125;测试数据API http://jsonplaceholder.typicode.com提交表单中会自动刷新页面所以 阻止默认事件需要加 e.preventDefault();data()&#123; return&#123;&#125; &#125; props 属性 父组件向子组件传值 两个组件之间的传值很常用123456789101112131415在子组件 定义属性props:&#123; content:&#123; type:String, default:&apos;默认就是当前文字&apos; &#125; &#125;也可以简单定义 props:[TranslationTxt ]在父组件 调用组件标签的身上绑定修改&lt;Vif v-bind:content=&quot;向子组件传值&quot;&gt;&lt;\/Vif&gt;在父组件 调用组件标签的身上绑定修改&lt;Vif v-text=&quot;向子组件传值TranslationTxt &quot;&gt;&lt;\/Vif&gt; 子组件则直接使用模板即可拿到数据&#123;&#123; TranslationTxt &#125;&#125;传值:string number boolean 不会改变全局传引用:array object 数据被改变那么所有组件中引用的都会被改变 子组件向父组件传值12345678910111. 在子组件中用$emit()注册一个事件 this.$emit(“formclick”,this.data) formclick是定义的方法名称 this.data 是传过去的数据内容2. 在App.vue中的对应子组件绑定 : &lt;Formm v-on:formclick=&quot;newfuncti&quot; /&gt;3. 在App.vue的methods 中 实现这个方法newfuncti:function(text)&#123; alert(text)&#125; 新建组件的步骤 : 模板里面有且只有一个跟标签12345678910111. 新建一个文件名如:Test 一般首字母大写2. 里面的结构用 template 标签包裹 底下有且只能有一个父标签3. js部分 export default &#123; name:&quot;Test&quot;,&#125;4. css部分 给style标签加上 scoped 声明作用域5. 然后到App.vue中 注册 import Test from &apos;./components/Test.vue&apos; 加不加.vue都可以6. 引用 components:&#123; Test&#125; 接着就可以使用了 &lt;Test/&gt; 名字和引用的一样 用单标签 以下是生命周期 钩子函数123456789101112131415161718192021222324beforeCreate:function()&#123; alert(&quot;组件实例化之前执行的函数&quot;)&#125;,created:function()&#123; alert(&quot;组件实例化完毕,但页面还未显示&quot;)&#125;,beforeMount:function()&#123; alert(&quot;组件挂在前,页面仍未展示,但虚拟Dom已经配置&quot;)&#125;,mounted:function()&#123; alert(&quot;组件挂在后,此方法执行后,页面显示&quot;)&#125;,beforeUpdate:function()&#123; console.log(&quot;组件更新前,页面仍未更新,但虚拟Dom已经配置&quot;)&#125;,updated:function()&#123; console.log(&quot;组件更新,此方法执行后,页面显示&quot;)&#125;,beforeDestroy:function()&#123; console.log(&quot;组件销毁前&quot;)&#125;,destroyed:function()&#123; console.log(&quot;组件销毁&quot;)&#125;]]></content>
      <categories>
        <category>前端拓展</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[倒计时]]></title>
    <url>%2F2018%2F04%2F02%2FsixCountDown%2F</url>
    <content type="text"><![CDATA[六小时倒计时Demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;count down &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt; ul &#123; width: 80%; margin: 0 auto; padding: 0; &#125; ul li &#123; list-style: none; float: left; width: 33.3%; text-align: center; margin-top: 50px; background: #111; color: #fff; &#125;&lt;/style&gt;&lt;body&gt; &lt;ul id="timer"&gt; &lt;li&gt;00&lt;/li&gt; &lt;li&gt;00&lt;/li&gt; &lt;li&gt;00&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;script src="jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt; let sixM = 21600000 //六个小时的毫秒数 let t = '2018-12-26 10:52:00' //后台传过来的开始时间 let start = new Date() let end = new Date(t) //转毫秒级 let startTime = start.getTime() let endTime = end.getTime() let remain = sixM - (startTime - endTime) let h = parseInt(remain / 1000 / 60 / 60 % 24) let m = parseInt(remain / 1000 / 60 % 60) let s = parseInt(remain / 1000 % 60) console.log('剩余时间=' + h + '时' + m + '分' + s + '秒'); //在6小时内才初始化时间且开启倒计时 if (h &gt;= 0 &amp;&amp; m &gt;= 0 &amp;&amp; s &gt;= 0) &#123; changText(h, m, s) //开启倒计时 showTime() &#125; //倒计时 function showTime() &#123; let timer = null let numTime = s clearInterval(timer); timer = setInterval(() =&gt; &#123; if (numTime &gt; 0) &#123; numTime-- $('#timer li').eq(2).text(numTime) &#125; else &#123; numTime = 60 if (m &gt; 0) &#123; m = m - 1 &#125; else &#123; if (h == 0) &#123; clearInterval(timer); changText(00, 00, 00) return &#125; else &#123; m = 60 h = h - 1 &#125; &#125; changText(h, m, numTime) &#125; &#125;, 1000); &#125; //封装渲染时间 function changText(a, b, c) &#123; $('#timer li').eq(0).text(a) $('#timer li').eq(1).text(b) $('#timer li').eq(2).text(c) &#125;&lt;/script&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[块级代码]]></title>
    <url>%2F2018%2F04%2F02%2F%E5%9D%97%E7%BA%A7%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[弹窗1234567891011121314151617// 没有背景的弹窗window.Msg = (function ($) &#123; return function (options) &#123; if ($('.msgContainer')) &#123; $('.msgContainer').remove(); &#125; options = $.extend(&#123; content: ' ', time: 2, &#125;, options || &#123;&#125;); var $msg = $('&lt;div class="msgContainer"&gt;&lt;div class="msg"&gt;' + options.content + '&lt;/div&gt;&lt;/div&gt;'); $('body').append($msg); setTimeout(function () &#123; $msg.remove(); &#125;, options.time * 2000); &#125;;&#125;)(window.jQuery); 12345678910111213141516171819202122232425262728293031323334353637383940414243/* 弹窗 */.msgContainer &#123; position: fixed; left: 0; top: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; pointer-events: none;&#125;.msg &#123; position: relative; bottom: -150px; width: auto; max-width: 90%; font-size: 14px; background-color: rgba(0, 0, 0, .7); color: #fff; padding: 10px 20px; border-radius: 5px; box-shadow: 0 0 8px rgba(0, 0, 0, .1); pointer-events: auto; animation-name: up; animation-fill-mode: both; animation-duration: .2s&#125;@keyframes up &#123; 0% &#123; opacity: 0; -webkit-transform: translateY(800px); transform: translateY(800px) &#125; 100% &#123; opacity: 1; -webkit-transform: translateY(0); transform: translateY(0) &#125;&#125; 调用 123Msg(&#123; content: '内容' &#125;); 一个有背景有title，conten，关闭按钮的弹窗1234567891011121314151617// 弹窗window.flip = (function ($) &#123; return function (options) &#123; if ($('.flip')) &#123; $('.flip').remove(); &#125; options = $.extend(&#123; top: '头', content: '内容' &#125;, options || &#123;&#125;); var $flip = $(' &lt;section id="flip"&gt;&lt;section class="flipIn"&gt;&lt;section class="flipConten"&gt;&lt;article class="top"&gt; ' + options.top + ' &lt;/article&gt;&lt;article class="text"&gt;' + options.content + '&lt;/article&gt;&lt;/section&gt;&lt;article class="close"&gt;&lt;/article&gt;&lt;/section&gt;&lt;/section&gt;'); $('body').append($flip); $('.close').click(function () &#123; $flip.remove(); &#125;) &#125;;&#125;)(window.jQuery); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/* 弹窗flip */#flip &#123; width: 100%; height: 100vh; position: fixed; top: 0; left: 0; background: rgba(0, 0, 0, 0.5); z-index: 100;&#125;#flip .flipIn &#123; width: 100%; height: 100%; position: relative; animation-name: up; animation-fill-mode: both; animation-duration: .2s&#125;.flipIn .flipConten &#123; width: 7.733333rem; height: auto; background: #fff; border-radius: .2rem; margin: 0 auto; margin-top: 4rem;&#125;.flipConten .top &#123; width: 100%; height: 2.666667rem; background: red; font-size: .8rem; color: #fff; text-align: center; line-height: 2.666667rem; letter-spacing: 0.1rem; font-weight: bold;&#125;.flipConten .text &#123; height: auto; padding: .533333rem; font-size: .373333rem; color: #333; line-height: .533333rem;&#125;.flipIn .close &#123; width: .8rem; height: .8rem; background: url(../img/flipClose.png) no-repeat; background-size: 100% 100%; margin: 0 auto; margin-top: 1.2rem;&#125;@keyframes up &#123; 0% &#123; opacity: 0; -webkit-transform: translateY(800px); transform: translateY(800px) &#125; 100% &#123; opacity: 1; -webkit-transform: translateY(0); transform: translateY(0) &#125;&#125; 调用1234flip(&#123; top: '很遗憾', content: '该活动仅限40个自然日内参加有效，您已超过该时间。'&#125;) 原本的结构贴出来 如果要修改可以参照次结构 不用在HTML中添加这个结构！！！12345678910111213141516&lt;!-- 弹窗 --&gt;&lt;!-- &lt;section id="flip"&gt; &lt;section class="flipIn"&gt; &lt;section class="flipConten"&gt; &lt;article class="top"&gt;恭喜您&lt;/article&gt; &lt;article class="text"&gt;恭喜您完成了新手7天成长期，现在可以 参与新手专属马拉松活动，你可参与下列 产品的跟投，获得对应的奖励，限期40天 内完成，40天后您还可以继续跟投，但是 没有额外奖励，赶紧选择你想跟投的产品 吧！ &lt;/article&gt; &lt;/section&gt; &lt;article class="close"&gt;&lt;/article&gt; &lt;/section&gt;&lt;/section&gt; --&gt; loading123456// loadingvar $loading = $('&lt;div class="loading-container"&gt;&lt;img src="images/loading.gif" class="loading-img"&gt;&lt;/div&gt;')添加loading $('body').append($loading);去掉loading $loading.remove(); 123456789101112131415161718192021/* loading */.loading-container &#123; position: fixed; z-index: 10; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, .4);&#125;.loading-img &#123; position: fixed; z-index: 1; width: 1rem; height: 1rem; top: 50%; left: 50%; -webkit-transform: translate(-50%, -50%); transform: translate(-50%, -50%);&#125; 一个创建json的方法12345678910111213//生成jsonfunction LXPDObj(m_Usd, m_Rmb, m_Timer, m_channel, m_channelChan) &#123; var PDBBB = new Object(); PDBBB.gUsd = m_Usd; PDBBB.gRmb = m_Rmb; PDBBB.gTimer = m_Timer; PDBBB.gchannel = m_channel; PDBBB.gchannelChan = m_channelChan; return PDBBB; //创建obj&#125;调用传值LXPDObj(Usd, Rmb, Timer, channel, channelChan) 16进制的时间戳Date.parse(new Date()) 时间戳转成时间123456789101112131415161718192021222324252627282930//时间转化function formatDate(date) &#123; var date = new Date(date * 1000) var year = date.getFullYear() var month = date.getMonth() + 1 var day = date.getDate() var hours = date.getHours() var minutes = date.getMinutes() month = month &gt; 9 ? month : "0" + month day = day &gt; 9 ? day : "0" + day hours = hours &gt; 9 ? hours : "0" + hours minutes = minutes &gt; 9 ? minutes : "0" + minutes return year + "-" + month + "-" + day + " " + hours + ":" + minutes&#125;调用 formatDate('1543481161')打印 2018-11-29 16:46//时间转化function getLocalTime(nS) &#123; return new Date(parseInt(nS) * 1000).toLocaleString().replace(/:\d&#123;1,2&#125;$/, ' ');&#125;调用 formatDate('1543481161')打印 2018-11-29 上午 11:46 当前时间 返回 “2018-10-16 17:03”12345678910//当前时间function getTime() &#123; var date = new Date(); var Minutes = date.getMinutes() if (Number(Minutes) &lt; 10) &#123; Minutes = '0' + Minutes &#125; var d = date.getFullYear() + "-" + (date.getMonth() + 1) + "-" + date.getDate() + " " + date.getHours() + ":" + Minutes; return d&#125; 本月12345678910111213141516function thisMonth() &#123; let date = new Date; let year = date.getFullYear(); let month = date.getMonth() + 1; if (month == 0) &#123; year = year - 1; month = 12; &#125; let lastDay = new Date(year, month, 0); let start = year + "-" + month + "-" + "01" let end = year + "-" + month + "-" + lastDay.getDate() startTimeD = Math.round(new Date(start) / 1000) endTimeD = Math.round(new Date(end) / 1000)&#125;startTimeD 输出 2018-0101endTimeD 输出 2018-01-31 上月12345678910111213141516function upMonth() &#123; let date = new Date; let year = date.getFullYear(); let month = date.getMonth(); if (month == 0) &#123; year = year - 1; month = 12; &#125; let lastDay = new Date(year, month, 0); let start = year + "-" + month + "-" + "01" let end = year + "-" + month + "-" + lastDay.getDate() startTimeD = Math.round(new Date(start) / 1000) endTimeD = Math.round(new Date(end) / 1000)&#125;startTimeD 输出 2018-12-01endTimeD 输出 2018-12-31 今天12 Math.round(new Date() / 1000)打印 2019-01-21 回到顶部事件123$('html,body').animate(&#123; scrollTop: 0&#125;, 800); 如有模态窗的时候 需要禁止页面滚动1234567891011121314151617181920212223// 禁止页面滚动-双重保障function forbidScroll() &#123; window.ontouchmove = function (e) &#123; e.preventDefault &amp;&amp; e.preventDefault(); e.returnValue = false; e.stopPropagation &amp;&amp; e.stopPropagation(); return false; &#125;; var top = $(window).scrollTop(); //这是当前滚动的页面滚动条位置 $("body").css(&#123; "position": "fixed", "width": "100%", "top": top * -1 //此处为当前需要定住的位置 &#125;);&#125;// 解除禁止function openScroll() &#123; window.ontouchmove = ""; $("body").css(&#123; "position": "static" &#125;);&#125; 点击模态窗关闭 并阻止事件冒泡12345678$('.windowTip').click(function () &#123; $(this).hide() openScroll()&#125;)// 阻止事件冒泡$('.windowBIn').on("click", function (e) &#123; e.stopPropagation();&#125;) 有时候展示用户手机号码 中间四位需要用*号代替123var reg = /1(\d&#123;2&#125;)\d&#123;4&#125;(\d&#123;4&#125;)/g;console.log(phone.replace(reg, "1$1****$2"))打印182****6684]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归]]></title>
    <url>%2F2018%2F04%2F02%2F%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[123456789101112131415traverseTree(data) &#123; const _this = this; if (!data) &#123; return; &#125; for (let i = 0; i &lt; data.length; i++) &#123; data[i].title = data[i].deptName; data[i].expand = true; if (data[i].children &amp;&amp; data[i].children.length &gt; 0) &#123; _this.traverseTree(data[i].children); data[i].title = data[i].deptName; &#125; &#125; return data; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647recursionData(data) &#123; data.map((item, index) =&gt; &#123; item.title = item.deptName; item.expand = true; item.render = (h, &#123; root, node, data &#125;) =&gt; &#123; return h( "span", &#123; class: &#123; span_title: true, active: data.active &#125;, style: &#123; display: "inline-block", cursor: "pointer" &#125;, on: &#123; click: () =&gt; &#123; this.treeTitleActive(node, data); &#125; &#125; &#125;, [ h("img", &#123; attrs: &#123; src: require("_a/img/form/" + (data.active ? "bluefolder.png" : "folder.png")) &#125;, style: &#123; verticalAlign: "text-bottom", marginRight: "10px" &#125; &#125;), h("span", data.title) ] ); &#125;; if (item.children &amp;&amp; item.children.length) &#123; this.handleRoleData(item.children); &#125; else &#123; item.children = []; &#125; &#125;); return data; &#125; &#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则]]></title>
    <url>%2F2018%2F03%2F02%2F%E6%AD%A3%E5%88%99%2F</url>
    <content type="text"><![CDATA[正则表达式 参考教程 ()[]https://deerchao.net/tutorials/regex/regex.htmhttp://www.cnblogs.com/zery/p/3438845.html摘抄一点下来 \b是正则表达式规定的一个特殊代码（好吧，某些人叫它元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\b并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置. ( 单词的分界 )列如：精确写查找区分大小一本小说里面的hi \bhi\b .是另一个元字符，匹配除了换行符以外的任意字符。（不包含换行的字符） 同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定前边的内容可以连续重复使用任意次以使整个表达式得到匹配.( 任意数量 )那么 . 连在一起就意味着任意数量的不包含换行的字符。假如要找的是hi后面不远处跟着一个Lucy \bhi\b.\bLucy\b ?重复零次或一次 \d是个元字符，匹配一位数字(0，或1，或2，或……)。 -不是元字符，只匹配它本身——连字符(或者减号，或者中横线，或者随你怎么称呼它)。列：匹配一个0开头的3位数区号的电话号码 0\d\d-\d\d\d\d\d\d\d\d为了避免这么多重复我们可以写个表达式0\d{2}-\d{8} \s匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。 \w匹配字母或数字或下划线或汉字等。列如：\ba\w\b匹配以字母a开头的单词——先是某个单词开始处(\b)，然后是字母a,然后是任意数量的字母或数字(\w)，最后是单词结束处(\b)。 +是和类似的元字符，不同的是匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。如 \d+匹配1个或更多连续的数字。\b\w{6}\b 匹配刚好6个字符的单词。 元字符^（和数字6在同一个键位上的符号）和$都匹配一个位置，这和\b有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：^\d{5,12}$。{2}是重复两次 {5,12}则是重复的次数不能少于5次，不能多于12次 如果你想查找元字符本身的话，比如你查找 . 这时你就得使用 \ 来取消这些字符的特殊意义。你应该使用 . 。当然，要查找 \ 本身，你也得用 \.例如：deerchao.net匹配deerchao.net，C:\Windows匹配C:\Windows。 接着看几个实例0\d{2}-\d{8}|0\d{3}-\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。(0\d{2})[- ]?\d{8}|0\d{2}[- ]?\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。\d{5}-\d{4}|\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。]]></content>
      <categories>
        <category>js拓展</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一丢丢的js]]></title>
    <url>%2F2018%2F03%2F02%2Fjs%2F</url>
    <content type="text"><![CDATA[判断当前设备123456// 终端是否安卓window.isAndroid = navigator.userAgent.indexOf('Android') &gt; -1 || navigator.userAgent.indexOf('Adr') &gt; -1; //android终端 // 终端是否IOSwindow.isiOS = !!navigator.userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端// 终端是否APPwindow.isApp = (isAndroid || isiOS) &amp;&amp; (typeof window.webkit !== 'undefined' || typeof WaveApp !== 'undefined'); 操控数组 filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。 不会对空数组进行检测及改变原始数组 123456var ages = [32, 33, 16, 40];function checkAdult(age) &#123; return age &gt;= 18;&#125;返回 32,33,40 sort() 按照数字大小或者字母顺序排序 使用arr.sort() 操控对象操控字符串 parseFloat() 如果字符串的第一个字符不能被转换为数字，那么 parseFloat() 会返回 NaN。 整个字符串只返回一个数字 num.toString() String(num) 转字符串 indexOf() 检测是否存在某个字符 不存在返回-1 否则返回字符位置 replace() 替换字符串如 replace(‘字’,’’) split() 分割字符串 string.split(‘.’) 操控数组 push() 写入数组，对象等 arr.push（’2’） 对象例：obj.push(obj) join() 方法用于把数组中的所有元素放入一个字符串。 要合并或连接两个数组，则需要使用concat() 方法 1234567891011//concat()把两个或者多个数组链接在一起，但是不改变已经存在的数组//而是返回一个链接之后的新数组var a = [1,2,3];a.concat([4,5]);// console.log(a);//此处输出为 [1, 2, 3]var a = [1,2,3];a = a.concat([4,5]);// console.log(a);//此处输出为 [1, 2, 3 ,4 ,5] 删除数组中指定元素 12345678//数组删除指定元素function spliceArr(arrs, vars) &#123; var currentNum = select.indexOf(vars) if (currentNum &gt; -1) &#123; arrs.splice(currentNum, 1) &#125;&#125;调用 spliceArr(arr, '全公司') 返回各种数字 数学对象Math。 包含了js中一切和数学有关的功能；如：随机数函数 Math.random() 可以产生任意的浮点数 Math.round() 四舍五入得出一个最接近的整数 toFixed() 把Number四舍五入为指定小数位数的数字。 num.toFixed(‘2’) isNaN() 判断传入值是否为数字 返回布尔值 parseInt(参数) 将字符型的数字转化为数字，去掉小数点只保留整数。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一丢丢的css]]></title>
    <url>%2F2018%2F02%2F02%2Fcss%2F</url>
    <content type="text"><![CDATA[文字类强制不换行 white-space:nowrap; 自动换行 word-wrap: break-word; word-break: normal; 强制英文单词断行 word-break:break-all; 保留省略号：width: 8em;overflow: hidden;text-overflow: ellipsis;white-space: nowrap; css文字两行或者几行显示省略号width: 250px; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; //这个代表你要在几行显示省略号 -webkit-box-orient: vertical; word-break: break-all; //英文还得加这个 文字中间加横线text-decoration: line-through; 背景图背景图片靠右对齐，并且间距从右算起可以这样写background:url(“images/test.png”)no-repeat right 10px center; //这样间距从右算起。 居中left: 50%;transform: translateX(-50%);-webkit-transform: translateX(-50%);-moz-transform: translateX(-50%);-ms-transform: translateX(-50%);-o-transform: translateX(-50%); input禁止出现键盘(兼容ios) 去掉a标签点击时的背景色！ 取消a标签在移动端点击时的蓝色：-webkit-tap-highlight-color: rgba(255, 255, 255, 0);-webkit-user-select: none;-moz-user-focus: none;-moz-user-select: none;使用图片作为a标签的点击按钮时，当触发touchstart的时候，往往会有一个灰色的背景：a,a:hover,a:active,a:visited,a:link,a:focus{-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-tap-highlight-color: transparent;outline:none;background: none;text-decoration: none;} 改变选中内容的背景颜色：::selection {background: #FFF;color: #333;}::-moz-selection {background: #FFF;color: #333;}::-webkit-selection {background: #FFF;color: #333;} 去除ios input框点击时的灰色背景：-webkit-tap-highlight-color:rgba(0,0,0,0);]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex布局]]></title>
    <url>%2F2018%2F01%2F05%2Fflex%2F</url>
    <content type="text"><![CDATA[前言 任何一个容器都可以指定为Flex布局 包括行内如 display: flex; display: inline-flex; Webkit内核的浏览器，必须加上-webkit前缀。display: -webkit-flex; / Safari / 设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 快捷常用 jcc jcsb align-items: center 以下6个属性设置在容器上 1.lex-direction属性决定主轴的方向（即项目的排列方向） 1flex-direction: row（默认值）从左往右 | row-reverse右往左 | column上往下 | column-reverse;下往上 2.flex-wrap如果一条轴线排不下，如何换行 1flex-wrap: nowrap（默认）不换行 | wrap换行第一行在上面 | wrap-reverse; 换行第一行在下面 3.flex-flow是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 1flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; 4.ustify-content项目在主轴上的对齐方式，让他能够自由的伸缩 这也是flex布局的优势之一 1justify-content: flex-start | flex-end | center | space-between | space-around; 5.align-items定义项目在交叉轴上如何对齐。 1align-items: flex-start | flex-end | center | baseline | stretch; 6.align-content定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 1align-content: flex-start | flex-end | center | space-between | space-around | stretch; 以下6个属性设置在项目上。 1.order 定义项目的排列顺序。数值越小，排列越靠前，默认为0 2.flex-grow 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。！如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 3.flex-shrink 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。！如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 4.flex-basis 定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。！它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 5.flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。！该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 6.align-self 允许单个项目有与其他项目不一样的对齐方式 1align-self: auto | flex-start | flex-end | center | baseline | stretch;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[md语法]]></title>
    <url>%2F2018%2F01%2F02%2FMarkdown%2F</url>
    <content type="text"><![CDATA[前言Markdown 是一种轻量级的「标记语言」非常简单十分轻量所有的标签后面空一格再写内容 这是标准的 md 语法 不然可能会报鬼错接下来我介绍一下常用的几个标签 然后就没有然后了~ 常用的标签标题标签 #一级标题 ##二级标题 以此类推 一共有六级标题 列表 *这是无序列表 🌰 1.这是有序列表 🌰 引用&gt; 就像这样 分割线***或者-或者_ 插入代码前三个`后也是三个```` html/javascript/css这里面就是插入的代码啦``` 插入链接链接为： [百度](www.baidu.com\) 插入图片图片为：![]() 字体与颜色文字 红：255，0，0 #FF0000橙: 255,125,0 #FF7D00黄：255，255，0 #FFFF00绿：0，255，0 #00FF00蓝：0，0，255 #0000FF靛: 0,255,255 #00FFFF紫: 255,0,255 #FF00FF]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HexoBlog设置密码]]></title>
    <url>%2F2018%2F01%2F02%2FhexoPassword%2F</url>
    <content type="text"><![CDATA[原博地址: 跳吧 安装hexo-blog-encrypt在 hexo 根目录里找到package.json。在package.json文件的”dependencies”: {…..里添加 “hexo-blog-encrypt”: “1.1.“记得添加”hexo-blog-encrypt”: “1.1.”之后加逗号,。dependencies中的每行代码都要有,隔开接着在终端执行 npm install 命令等待该插件自动安装 启动插件在根目录的_config.yml中启用该插件:1234 \# Security\#\#encrypt: enable: true 然后在你文章的头部添加上对应的字段 如 password, abstract, message 大功告成其他，如对 TOC 进行加密、修改加密模板都可以在 官方ReadMe.zh.md中找到。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[coding-hexo-next]]></title>
    <url>%2F2018%2F01%2F02%2Fcoding-hexo-next%2F</url>
    <content type="text"><![CDATA[前言 Hexo是一款基于Node.js的静态博客框架 可以生成静态网页托管在GitHub上面 就省去了买服务器了 博客文章是用MarkDown语法编写的,对开发者非常友好 也不怕数据库被删了Hexo GitHub上面的项目是开源的 总觉得有点怪 于是在coding上建一个私有项目coding 然后需要一个域名 一是为了美观 二是coding提供的URL在微信是打不开的 主题用的是Next 最多人用所以查个文档很方便 功能也很完善Next 搭建 需要安装 这两货不多说 Node.js 和 Git 执行命令安装Hexo $ npm install -g hexo-cli 安装完Hexo后 尝试一下 新建-进入目录-安装依赖-打开 $ hexo init &lt;folder>$ cd &lt;folder>$ npm install$ hexo s 基本配置 参数/描述 官方文档都有 我挑几个会出错的说一下 language/网站使用的语言 设置了不生效的话 可以看看主题里面的language文件都支持哪些文件是怎么命名的url 没有配域名的情况下用coding提供的网址 配了域名就改成自己的root/网址根目录 如何网址被放入子目录中如http://0li.xin/blog 那么root设为 /blog/ 否则直接 / 就可以了theme: Next 设置你想要的主题 主题 Next本来看上了一个其他的主题 但是很容易看腻也没文档什么的 还是向现实妥协 首先进入站点目录下 安装主题 $ git clone https://github.com/iissnan/hexo-theme-next themes/next 到站点配置文件config.yml 启用主题 theme: next 运行看看没毛病我们就设置菜单了 对应字段是menu 我只开启了标签 分类 和归档 menu:home: / || hometags: /tags/ || tagscategories: /categories/ || tharchives: /archives/ || archive 主题中不同的外观scheme 我用的是 scheme: Mist 如果要自定义样式需要去到/Blog/themes/next/source/css/_schemes 目录下修改css 常用命令 新建一个网站 $ hexo init [folder]新建一篇文章 $ hexo new &lt;title>生成静态文件 $ hexo g启动服务器。默认网址为：http://localhost:4000/ $ hexo s部署网站。$ hexo deploy提示常用命令 $ hexo _help清除缓存文件 $ hexo clean列出网站资料。 $ hexo list &lt;type>显示 Hexo 版本。 $ hexo version 添加点元素简书有篇文总结的不错地址 腾讯公益404页面 新建 404.html 页面，放到博客或者主题的 source 目录下，内容如下： 12345678910111213141516171819&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow" /&gt; &lt;link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="回到我的主页"&gt; &lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 页面底部添加图片或者添加Coding Pages的链接(把下面这段链接放入newBlog/themes/next/layout/_partials/footer.swig) 否则他会先跳转到coding的主页才跳过来 1&lt;a href="https://pages.coding.me" style="font-weight: bold"&gt;Coding Pages&lt;/a&gt; 给页面加点小星星然后下面的代码copy一下，新建love.js文件并且将代码复制进去，然后保存。将love.js文件放到路径/themes/next/source/js/src里面，然后打开\themes\next\layout_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码： 1&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354! function (e, t, a) &#123; function n() &#123; c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"), o(), r() &#125; function r() &#123; for (var e = 0; e &lt; d.length; e++) d[e].alpha &lt;= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = "left:" + d[e].x + "px;top:" + d[e].y + "px;opacity:" + d[e].alpha + ";transform:scale(" + d[e].scale + "," + d[e].scale + ") rotate(45deg);background:" + d[e].color + ";z-index:99999"); requestAnimationFrame(r) &#125; function o() &#123; var t = "function" == typeof e.onclick &amp;&amp; e.onclick; e.onclick = e.ontouchstart = function (e) &#123; t &amp;&amp; t(), i(e) &#125; &#125; function i(e) &#123; var a = t.createElement("div"); a.className = "heart", d.push(&#123; el: a, x: e.clientX || e.touches[0].clientX - 5, y: e.clientY || e.touches[0].clientY - 5, scale: 1, alpha: 1, color: s() &#125;), t.body.appendChild(a) // console.log(a); &#125; function c(e) &#123; var a = t.createElement("style"); a.type = "text/css"; try &#123; a.appendChild(t.createTextNode(e)) &#125; catch (t) &#123; a.styleSheet.cssText = e &#125; t.getElementsByTagName("head")[0].appendChild(a) &#125; function s() &#123; return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")" &#125; var d = []; e.requestAnimationFrame = function () &#123; return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) &#123; setTimeout(e, 1e3 / 60) &#125; &#125;(), n()&#125;(window, document);]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[beginning]]></title>
    <url>%2F2018%2F01%2F01%2Fbeginning%2F</url>
    <content type="text"><![CDATA[上一次服务器挂的时候 丢了一波图片 从那以后文章就真的是干货了 一张图都没有 emmmm 重新搭了一个博客 coding-hexo-next md的语法 慢慢把之前的东西搬过来 先用着吧 不花钱 😜]]></content>
      <categories>
        <category>记录生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用URL传所需参数]]></title>
    <url>%2F2017%2F12%2F02%2Furl%2F</url>
    <content type="text"><![CDATA[#前言 location 对象包含有关当前 URL 的信息。location 对象是 Window 对象的一个部分，可通过 window.location 属性来访问。hash 设置或返回从井号 (#) 开始的 URL（锚）。host 设置或返回主机名和当前 URL 的端口号。hostname 设置或返回当前 URL 的主机名。href 设置或返回完整的 URL。pathname 设置或返回当前 URL 的路径部分。port 设置或返回当前 URL 的端口号。protocol 设置或返回当前 URL 的协议。search 设置或返回从问号 (?) 开始的 URL（查询部分）。 如 location.href; //取得整个地址栏 location.search; //获取url中”?”符后的字串 链接中只有一个参数的话 就很简单了 根据需要截取一下字符串即可123456789function handleUrl() &#123; var url = location.search; //获取url中"?"符后的字串 if (url.indexOf("?") != -1) &#123; url = url.substr(1); url = url.split('=')[1]; var fjont=url.split('&amp;')[0]; return fjont &#125;&#125; 链接中有多个参数 那么我们要取对应参数的值1234567891011function getQueryString(name) &#123; var reg = new RegExp('(^|&amp;)' + name + '=([^&amp;]*)(&amp;|$)', 'i'); var r = window.location.search.substr(1).match(reg); if (r != null) &#123; return unescape(r[2]); &#125; return null;&#125;调用如 getQueryString('id');]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序]]></title>
    <url>%2F2017%2F02%2F02%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[tab栏切换12345678910111213141516&lt;view class="tab"&gt; &lt;view class="&#123;&#123;tabIndex==0?'active':''&#125;&#125;" data-index="0" bindtap="showTab"&gt; &lt;text&gt;正&lt;text&gt;在跟&lt;/text&gt;随&lt;/text&gt; &lt;/view&gt; &lt;view class="&#123;&#123;tabIndex==1?'active':''&#125;&#125;" data-index="1" bindtap="showTab"&gt; &lt;text&gt;历&lt;text&gt;史跟&lt;/text&gt;随&lt;/text&gt; &lt;/view&gt;&lt;/view&gt;&lt;view class="tabCon &#123;&#123;tabIndex==0?'active':''&#125;&#125;"&gt; 正在跟随&lt;/view&gt;&lt;view class="tabCon &#123;&#123;tabIndex==1?'active':''&#125;&#125;"&gt; 历史跟随&lt;/view&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859.tab &#123; width: 100%; height: 90rpx; background: #fff;&#125;.tab &#123; display: flex; justify-content: space-around; font-size: 30rpx; padding-top: 0; color: #666; background: #fff&#125;.tab&gt;view &#123; display: flex;&#125;.tab&gt;view&gt;view &#123; margin-right: 60rpx&#125;.tab&gt;view.active &#123; color: #0088FF&#125;.tab view.active text &#123; padding-bottom: 25rpx&#125;.tab view.active text text &#123; border-bottom: 3rpx solid #0088FF; border-radius: 2rpx&#125;.tabCon &#123; display: none&#125;.tabCon.active &#123; display: block&#125;.tabCon&gt;view:first-child &#123; display: flex; align-items: center; text-align: center; font-size: 26rpx; padding: 20rpx 0 20rpx 30rpx; justify-content: space-around&#125;.tabCon&gt;view:first-child&gt;text,.followWrap&gt;view&gt;view,.followWrap&gt;view&gt;text &#123; flex-basis: 25%;&#125;&#125; 1234567891011Page(&#123; data: &#123; tabIndex: 0 &#125;, showTab(e) &#123; let tabIndex = e.currentTarget.dataset.index this.setData(&#123; tabIndex &#125;) &#125;&#125;) 获取当前页面的url123456789使用getCurrentPages可以获取当前加载中所有的页面对象的一个数组，数组最后一个就是当前页面。var pages = getCurrentPages() //获取加载的页面var currentPage = pages[pages.length-1] //获取当前页面的对象var url = currentPage.route //当前页面urlvar options = currentPage.options //如果要获取url中所带的参数可以查看options]]></content>
      <categories>
        <category>工作我是认真的</category>
      </categories>
      <tags>
        <tag>块级代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作宝典-style]]></title>
    <url>%2F2012%2F07%2F02%2F%E5%B7%A5%E4%BD%9C%E5%AE%9D%E5%85%B8-css%2F</url>
    <content type="text"><![CDATA[css 实现对元素自动排序在 CSS2.1 中的自动编号由两个属性控制，它们分别为：“counter-increment”和“counter-reset”。由这些属性定义的计数器（counter）与“content”属性的 counter()和 counters()函数一起使用。 . 例：显示了使用“第 1 章”，“1.1”，“1.2”等对章节进行编号的方法。 12345678 &lt;h1&gt;大标题&lt;/h1&gt; &lt;h2&gt;小标题1&lt;/h2&gt; &lt;h2&gt;小标题2&lt;/h2&gt; ` 清除浮动 父级 div 定义 height 父级 div 定义 overflow:hidden 结尾处加空 div 标签 clear:both]]></content>
      <tags>
        <tag>style</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作宝典]]></title>
    <url>%2F2012%2F07%2F02%2F%E5%B7%A5%E4%BD%9C%E5%AE%9D%E5%85%B8-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[前端有什么网络安全措施前端常见的网络安全包括：xss（跨站脚本攻击）、csrf（跨站请求伪造）、sql 注入攻击、DNS 挟持、http 挟持等 在地址栏输入严格 url，到页面呈现，会发生什么？1.输入 url，浏览器先查看缓存，若缓存中有，直接显示页面，若没有，则进行域名解析，获取相应 IP 地址 2.浏览器想服务器发送 TCP 连接，建立三次握手 3.握手成功后，建立 http 请求 5.服务器收到请求后，将数据返回至服务器 6.浏览器收到响应。读内容，渲染页面 关于 DNS 挟持页面输入 url 之后，获取原域名的 DNS 解析权，修改掉原先的 ip 地址，将 DNS 指向攻击者的 ip 地址。（即输入https://www.baidu.com/时，出来的是别的页面）…后果：用户被诱骗到冒牌网站进行登录等操作导致泄露隐私数据。 防范：_使用备用域名_手动指定 DNS 服务器地址 关于 http 挟持即在 http 传输过程中，对响应体进行篡改（一般通用的方法都是插入静态脚本或者是 HTML Content，或者是将整体替换成 Iframe，然后再在顶层的 Iframe 上进行内容的植入） 防范:换成 HTTPS，建立安全通道 XSS(跨站脚本攻击)攻击者往页面注入恶意 script 代码，用户在浏览页面的时候会执行这些代码，造成用户的 cookie 信息被盗取或会话被劫持等 类型 反射型 XSS：用户点击攻击连接，服务器解析后响应，在返回的内容中包含 xss 的恶意攻击脚本，被浏览器执行。(主要发生在一些带有诱导性的链接的按钮邮件等) 持久型 XSS:攻击者将恶意代码提交到目标网站的数据库中。用户打开目标网站时，网站服务端将恶意代码从数据库取出，返回到浏览器。用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执。(存储型攻击常发生在微博论坛等用户发帖、提交文章评论等地方) DOM 型 XSS:用户打开带有恶意的链接,浏览器在 DOM 解析的时候直接执行恶意代码（由前端 js 代码不严谨，随意执行不可信代码导致） 防范 1.对用户的输入内容进行过滤，对输出在网页上的内容进行转译或编码。 2.在 cookie 中设置 HttpOnly 属性，让 js 脚本将无法读取到 cookie 信息。 CSRF（跨站请求伪造）攻击者盗取用户身份，以用户身份采取一系列恶意操作，即恶意网站利用网站的 cookie 信息，伪造想网站发起请求，如：转账；例子：当用户在 A 网站用用户名和密码登录上去的同时，在同一浏览器进入网站 B，B 网站返回一些攻击性代码，并发出一个请求要求访问第三方站点 A，浏览器接受到恶意代码后，将恶意代码和 Cookie 信息向 A 网站发起恶意请求。防范 1.在 HTTP 头中自定义属性并验证：服务器想客户端发起严格 Token 值，每次请求都需要携带 Token，服务器会验证 Token 值是否有效 2.验证 HTTP Referer 字段：通过 Referer 验证请求是否是第三方网站发起的 3.对 Cookie 设置 SameSite 属性，限制 Cookie 不随着跨域请求发送 SQL 注入:攻击者可以在 web 应用程序中事先定义好的查询语句的结尾上添加额外的 SQL 语句，以此来非法获取数据库信息以及对数据库进行操作防范: 1.对用户的输入进行校验 2.对主要信息加密]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作宝典]]></title>
    <url>%2F2012%2F07%2F02%2F%E5%B7%A5%E4%BD%9C%E5%AE%9D%E5%85%B8%2F</url>
    <content type="text"><![CDATA[nodejs中间件在软件领域，中间件是在应用与应用之间充当连接服务的1.express 2.koa 优化打开浏览器，输入 URL，到页面展示出来的过程及优化：传送门: https://blog.csdn.net/weixin_33709590/article/details/88567259 输入 URL(浏览器查找当前 URL 是否存在缓存) 服务器对静态资源设置浏览器缓存信息，浏览器在有缓存的情况下直接从本地读取资源。传送门：https://www.cnblogs.com/chenq... 关键词: 强制缓存 协商缓存 Cache-Control DNS 解析地址栏输入的域名并不是最后资源所在的真实位置，域名只是与 IP 地址的一个映射。网络服务器的 IP 地址那么多，我们不可能去记一串串的数字，因此域名就产生了，域名解析的过程实际是将域名还原为 IP 地址的过程。 无优化点 TCP 握手DNS 解析后得到了服务器的 ip，接下来就是和服务器建立起连接，这通过 TCP 的三次握手完成。 无优化点 HTTP 请求完整的 HTTP 请求包含请求起始行、请求头部、请求主体三部分。缓存信息是存储在请求头中，在阶段 1 上的连接有介绍优化点: 减少请求次数 合并外部请求的 js、css 文件对 icon 文件进行处理。运用 CSS 精灵合并处理多个 icon 文件、运用图标字体、把小图标转为 base64 等 HTTP 响应返回数据 浏览器解析并渲染页面1&gt; js 会阻塞页面渲染的，那么解决方法有很多，可以把 js 放在 body 的底部，或者是异步加载 js(script 标签的 async 和 defer 属性)。 https://blog.csdn.net/qq_34986769/article/details/521558712&gt; 以及 js 代码的优化 如 尽可能少声明变量,减少闭包的使用,少使用循环3&gt; 分页加载 图片懒加载 使用精灵图等4&gt; 如果是 vue 项目 页面渲染全靠 js 的 render，如果这个入口 js 过大，必然会导致页面白屏时间过长。可以对入口的 js 进行代码分割webpack 在编译时，会静态地解析代码中的 require.ensure()，同时将模块添加到一个分开的 chunk 当中。这个新的 chunk 会被 webpack 通过 jsonp 来按需加载。 123456789101112131415//写在主入口main.js中? document.querySelector('button').onclick = () =&gt; &#123; require.ensure([], ()=&gt; &#123; // 引入异步加载的js let loadJS = require('./asyncJS') alert(loadJS.flag) &#125;, 'asyncJS') &#125; //webpack的配置文件? output: &#123; path: path.resolve(__dirname, './dist'), filename: '[name].bundle.js', publicPath: '../dist/', chunkFilename: 'chunks/[name]-[hash].js' &#125;; 5&gt; webpack 优化 优化 loader 配置1.1 缩小文件匹配范围(include/exclude) 缩小了 loader 加载搜索范围 高概率命中文件1.2 缓存 loader 的执行结果(cacheDirectory) 减少 webpack 构建时 Babel 重新编译过程loaders: [ { test: /\.jsx?$/, exclude: /node_modules/, loader: &quot;babel-loader?optional=runtime&amp;cacheDirectory&quot; }] HappyPack 多进程打包HappyPack 是让 webpack 对 loader 的执行过程，从单一进程形式扩展为多进程模式，也就是将任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。从而加速代码构建 与 DLL 动态链接库结合来使用更佳。 多进程压缩 ParallelUglifyPlugin 开启多个子进程同时压缩 提取公共代码 webpack3 使用 CommonsChunkPlugin webpack4 使用 splitChunks 生产环境关闭 sourceMap (开启得话打包出来的 js 文件中的代码可以映射到代码文件的具体位置,这种映射关系会帮助我们直接找到在源代码中的错误。) uni.app常见问题uni 打包的时候 会报错会出现不同的兼容问题因为打包的设备不同 也要设定不同的方法 平台兼容性https://blog.csdn.net/Sunshine0508/article/details/104820498 ios app 真机测试到上架 App Store 详细教程http://blog.applicationloader.net/blog/zh/88.html 发布流程uniapp 通过 appuploader 下载发布证书 描述文件 然后通过 HB 打包下载 IPA 文件，通过 appuploader 上传 ipa, 成功后去苹果官网构建版本发布版本 分包优化多开一条 subPage 底层设计原理? html前端常用设计模式工厂模式/观察者模式/单例模式https://www.jianshu.com/p/4f3014fb8b8b 什么是设计模式，设计模式的作用。设计模式是一套被反复使用的、多数人知晓、经过分类编目的优秀代码设计经验的总结。特定环境下特定问题的处理方法。 1）重用设计和代码 重用设计比重用代码更有意义，自动带来代码重用2）提高扩展性 大量使用面向接口编程，预留扩展插槽，新的功能或特性很容易加入到系统中来3）提高灵活性 通过组合提高灵活性，可允许代码修改平稳发生，对一处修改不会波及到其他模块4） 提高开发效率 正确使用设计模式，可以节省大量的时间 写出你用过的设计模式https://blog.csdn.net/zhongqw_00/article/details/98469433 工厂设计模式思路说明：由一个工厂类根据传入的参数（一般是字符串参数），动态决定应该创建哪一个产品子类（这些产品子类继承自同一个父类或接口）的实例，并以父类形式返回 优点：客户端不负责对象的创建，而是由专门的工厂类完成；客户端只负责对象的调用，实现了创建和调用的分离，降低了客户端代码的难度；缺点：如果增加和减少产品子类，需要修改简单工厂类，违背了开闭原则；如果产品子类过多，会导致工厂类非常的庞大，违反了高内聚原则，不利于后期维护。 1234567891011121314151617function CreatePerson(name, age, sex) &#123; var obj = new Object(); obj.name = name; obj.age = age; obj.sex = sex; obj.sayName = function () &#123; return this.name; &#125;; return obj;&#125;var p1 = new CreatePerson("longen", "28", "男");var p2 = new CreatePerson("tugenhua", "27", "女");// 返回都是object 无法识别对象的类型 不知道他们是哪个对象的实列console.log(typeof p1); // objectconsole.log(typeof p2); // objectconsole.log(p1 instanceof Object); // true 单列设计模式保证一个类只有一个实例，并提供一个全局访问点。实现方法：先判断实例是否存在，不存在先创建后返回，存在则直接返回。 1234567891011121314151617let CreateDiv = function (html) &#123; this.html = html;&#125;;let Singleton = (function () &#123; let instance; return function (html) &#123; if (!instance) &#123; instance = new CreateDiv(html); &#125; return instance; &#125;;&#125;)();let a = new Singleton("seven1");let b = new Singleton("seven2");console.log(a);console.log(b);console.log(a === b); // true 实际应用模态框，以及弹框 vue 双向绑定模式vue 数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的 Object.defineProperty( )是用来做什么的？它可以来控制一个对象属性的一些特有操作，比如读写权、是否可以枚举，它对应的两个描述属性 get 和 setget 就是在读取 name 属性这个值触发的函数，set 就是在设置 name 属性这个值触发的函数 https://www.cnblogs.com/canfoo/p/6891868.html SVG 和 CANVAS 的区别 svg 绘制出来的每一个图形元素都是独立的 DOM 节点，可方便后期绑定事件或修改，而 canvas 输出的是一整幅画布； svg 输出的图形是矢量的，后期可以修改参数来自由放大缩小，无失真，canvas 输出标量画布，就像一张图片一样 哪些浏览器有自主内核?IE 火狐 谷歌 欧朋 Safari 前端页面有哪三层构成，分别是什么?作用是什么?结构 html、表现 css、和行为 js html5/css3 新特性 参考 https://www.cnblogs.com/star91/p/5659134.html 更多的语义化标签：例如用于定义头部(header)、尾部(footer)、导航区域(nav)、侧边栏(aside)良好的多媒体支持：对于先前的以插件的方式播放音频、视频带来的麻烦，HTML5 有了解决方案，audio 标签和 video 标签能够方便的实现应变。HTML5 拥有多个新的表单输入类型。这些新特性提供了更好的输入控制和验证。email、number、tel提供了对 WebSockets 的支持 新增了两个存储方式(sessionStorage localeStorage)HTML5 提供了对 Web Sockets 的支持 新增选择器： li:nth-child(odd)奇(even)偶行、a:hover,复选框等，代码标记更少。新增阴影 box-shadow、圆角 border-radius、渐变 background-image:-webkit-gradient(linear,0% 0%,100% 0%,from(#2A8BBE),to(#FE280E))、动画 animation,过渡 Transition,2D 转换效果 Transforms,等视觉效果 HTML5 提供了对 Web Sockets 的支持。( WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。当你获取 Web Socket 连接后，你可以通过 send() 方法来向服务器发送数据，并通过 onmessage 事件来接收服务器返回的数据。以下 API 用于创建 WebSocket 对象。) 特点:建立在 TCP 协议之上，服务器端的实现比较容易。与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443 ，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。数据格式比较轻量，性能开销小，通信高效。可以发送文本，也可以发送二进制数据。没有同源限制，客户端可以与任意服务器通信。协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 连接保持 + 心跳WebSocket 为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的 TCP 通道保持连接没有断开。然而，对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。 WebSocket.onopen 用于指定连接成功后的回调函数WebSocket.onmessage 用于指定当从服务器接受到信息时的回调函数WebSocket.send(data) 对要传输的数据进行排队WebSocket.onerror 用于指定连接失败后的回调函数 WebSocket.readyState(只读) 当前的链接状态 状态 readyState属性返回实例对象的当前状态,有4种； CONNECTING：值为0，表示正在连接。 OPEN：值为1，表示连接成功，可以通信了。 CLOSING：值为2，表示连接正在关闭。 CLOSED：值为3，表示连接已经关闭，或者打开连接失败。 新增了两个存储方式 [老的-cookie(4kb 时间限制 明文存储)]sessionStorage(5mb 标签页关闭就会清除 不会跨标签页存储,只存在当前页)，localeStorage(5mb 长期储存 会跨标签页存储) 盒模型content,padding,border,margin. 标准盒模型 的宽高只是内容（content）的宽高， IE 盒模型 的宽高是内容(content)+填充(padding)+边框(border)的总宽高。 css 如何设置两种模型 使用 CSS3 的属性 box-sizing即 box-sizing 属性可以指定盒子模型种类，content-box 指定盒子模型为 W3C（标准盒模型），border-box 为 IE 盒子模型（怪异盒模型）。 12345/* 标准模型 */box-sizing: content-box;/*IE模型*/box-sizing: border-box; BCF( Block Format Content)BFC 布局规则：内部的 Box 会在垂直方向，一个接一个地放置。Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。BFC 的区域不会与 float box 重叠。BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。计算 BFC 的高度时，浮动元素也参与计算BFC 会阻止垂直外边距（margin-top、margin-bottom）折叠 我们可以利用 BFC 的第三条特性来“清浮动”:float 为 left|rightoverflow 为 hidden|auto|scrolldisplay 为 table-cell|table-caption|inline-blockposition 为 absolute|fixed css 部分最小字体PC 端的浏览器进行最小 12px 的限制，手机端默认没有开该限制，还是可以直接通过 CSS 设置最小字体的PC 使用 transform: scale(); 属性缩放字体所在元素即可实现小字体显示 使元素水平垂直居中方案 flexdisplay: flex;justify-content: center;align-items: center; fixedposition:fixed;left:0;top:0;reight:0;bottom:0;margin:auto; absoluteposition:absolute;left:0;top:0;right:0;bottom:0;margin:auto; display: table flex 常用参数 flex-direction: row | row-reverse | column | column-reverse; 排列方向 flex-wrap: nowrap | wrap | wrap-reverse; 是否允许换行 定义项目在主轴的对齐方式 (主轴取决于 flex-direction 默认横轴)justify-content: flex-start | flex-end | center |space-between(两端对齐项目之间的间隔都相等) | space-around(每个项目两侧的间隔相等) 定义项目在交叉轴上如何对齐。align-items: flex-start | flex-end | center(中点对齐) |baseline(项目的第一行文字的基线对齐)stretch(默认值如果项目未设置高度或 auto，将占满整个容器的高度); 移动端 1px 解决方案归根结底有两种方案，一种是利用 css 中的 transfrom：scaleY(0.5)，另一种是设置 媒体查询根据不同 DPR 缩放 参考文章 https://zhuanlan.zhihu.com/p/100752129 解决方法 1利用 css 的 伪元素::after + transfrom 的 scale 缩小一半为什么用伪元素？ 因为伪元素::after 或::before 是独立于当前元素，可以单独对其缩放而不影响元素本身的缩放 伪元素大多数浏览器默认单引号也可以使用，和伪类一样形式，而且单引号兼容性（ie）更好些 解决方案二（升级方案一）使用 less 对公共代码（方案一）封装，同时增加媒体查询分别对不同 DPR 的设备，进行不同的缩放 有缺憾的解决方式使用图片：兼容性最好，灵活行最差，不能改变颜色、长度使用 viewport 和 rem，js 动态改变 viewport 中 scale 缩放，缺点在于不适用于已有的项目，例如：使用 vh 和 vw 布局的使用 css 渐变 linear-gradient 或者 box-shadow less 和 sass 或者 scss 有什么区别吗？ 声明和使用变量LESS 采用 @ 符号，SCSS 采用 \$ 符号。 变量插值（Variable Interpolation）LESS 采用 @{xxxx} 的形式，SCSS 采用 \${xxxx} 的形式。 Mixins 的定义、使用及参数定义一个 Mixin：LESS 使用 dot 符号（也就是句点）来定义一个 Mixin， 使用 Mixin 仍是使用句点,如果 Mixin 没有参数的话可以省略后面的圆括号SCSS 使用 @mixin 指令来定义一个 Mixin。 SCSS 使用 @include 指令来引入一个 Mixin。 Sass 支持条件语句，可以使用 if{}else{},for{}循环等等。而 Less 不支持 12345678910111213141516171819202122// if-else if-else示例@mixin txt($weight) &#123; color: white; @if $weight == bold &#123; font-weight: bold; &#125; @else if $weight == light &#123; font-weight: 100; &#125; @else &#123; font-weight: normal; &#125;&#125;.txt1 &#123; @include txt(bold);&#125;// for@for $i from 1 to 10 &#123; .border-#&#123;$i&#125; &#123; border: #&#123;$i&#125;px solid blue; &#125;&#125; 引用外部 CSS 文件scss@import 引用的外部文件如果不想编译时多生成同名的.css 文件，命名必须以开头, 文件名如果以下划线开头的话，Sass 会认为该文件是一个引用文件，不会将其编译为同名 css 文件. 如: @import “_test1.scss”;Less 引用外部文件和 css 中的@import 没什么差异。 css 选择器高级选择器$(“A+B”) 就是查找A元素后面的第一个兄弟B节点$(“A~B”) 查找 A 元素后面的所有兄弟 B 节点A&gt;B 表示选择 A 元素的所有第一级子 B 元素。属性 href 的值以”http:”开头的元素 a[href^=”http:”]属性 href 的值以”http:”结尾的元素 a[href$=”http:”]属性 href 的值包含”http:”字符串的元素 a[href*=”http:”] 排序不同级别优先级排序!important &gt; 行内样式 &gt; ID 选择器 &gt; 类选择器 &gt; 元素 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性 同一级别优先级排序 同级别中后写的会覆盖先写的样式 同级别 css 引入方式不同，优先级不同总结排序：内联(行内)样式 &gt; 内部样式表 &gt; 外部样式表 &gt; 导入样式(@import)。 JS 部分拷贝对象深拷贝JSON.parse() string-&gt;jsonJSON.stringify() json-&gt;string深拷贝 a 对象赋值给 b 对象 修改 b 对象会影响到 a 应为他们在内存中地址是一样的 我们在赋值的时候用深拷贝就不会了JSON.parse(JSON.stringify(XXXX)) 我们在使用 JSON.parse(JSON.stringify(xxx))时应该注意一下几点：由于 json 不支持函数、undefined、NaN，!!!所以使用 JSON 方法转换时，对象的函数、NaN 属性会被忽略，undefined 会被转换为 null。1、如果 obj 里面存在时间对象，JSON.parse(JSON.stringify(obj))之后，时间对象变成了字符串。2、如果 obj 里有 RegExp、Error 对象，则序列化的结果将只得到空对象。3、如果 obj 里有函数，undefined，则序列化的结果会把函数， undefined 丢失。4、如果 obj 里有 NaN、Infinity 和-Infinity，则序列化的结果会变成 null。5、JSON.stringify()只能序列化对象的可枚举的自有属性。如果 obj 中的对象是有构造函数生成的， 则使用 JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的 constructor。6、如果对象中存在循环引用的情况也无法正确实现深拷贝。 深拷贝处理空值会怎么样? 会被转换为 null 浅拷贝 Object.assign() ES6 的展开运算符…js 常用操作push() 写入数组splice() 方法用于插入、删除或替换数组的元素。 Array.splice(start,deleteCount,itemN)从末尾删除 只保留最前面一位 [1,2,3,4].splice(1) 只留下[1] split(‘,’) 分割字符串并返回数组 string.split(‘,’)join() 方法用于把数组中的所有元素放入一个字符串。 array.join() slice(开始位置,结束位置) 结束位置是可选的。开始位置必选，可以是正数，也可是负数 负数时，就是倒着来的。 parseInt() 一般用它返回整数 numbertoFixed() 四舍五入返回指定小数位的数字 String()可以将 null 和 undefined 转换为字符串，但是没法转进制字符串.toString()可以将所有的的数据都转换为字符串，但是要排除 null 和 undefined 括号中的可以写一个数字，代表进制，对应进制字符串 toString(8)replace() 方法用于在字符串中用一些字符替换另一些字符,或替换一个与正则表达式匹配的子串。 原生 js 查找/操作元素方法document.createElement(“div”); //创建一个元素节点 重要!node.appendChild(newNode);// 在指定元素后面新增子节点document.createTextNode(“hello world!”); //创建一个文本节点newNode.cloneNode(true);//克隆一个节点，参数 true 表示会克隆当前节点以及他的所有子节点，flase 表示只克隆当前节点，默认为 falseparentNode.removeChild(item);//删除指定的子节点，并返回 deleteNode 只是在 dom 树中删除了，但在内存中还可以访问 document.getElementById(“list”);//返回第一个带有指定 id 的元素document.getElementsByClassName(“wrapper”); //返回所有带有指定 class 的元素的集合(返回数组形式) document.getElementsByName() 获取所有指定 name 的元素集合document.getElementsByTagName(“li”);//返回所有指定标签的元素集合 (数组形式) document.querySelector(“.wrapper”);//返回第一个带有指定 id 或 class 的元素document.querySelectorAll(“.wrapper”);//返回所有带有指定 id 或 class 的元素 获取元素属性 .setAttribute(“属性”)设置属性 .setAttribute(“属性”,”值”)删除属性 .removeAttribute unbind() 方法移除被选元素的事件处理程序 \$(window).unbind(‘mouseup’) js 数据类型 js 的数据类型分为两种：原始类型（即基本数据类型）和对象类型（即引用数据类型）； js 常用的基本数据类型(栈)包括 undefined、null、number、boolean、string；以及 es6 新增的 Symbol js 的引用数据类型(堆)也就是对象类型 Object，如：（对象、数组、函数）； 基本数据类型特点 基本数据类型是按值访问的，就是说我们可以操作保存在变量中的实际的值； 基本数据类型的值是不可变的，任何方法都无法改变一个基本数据类型的值; 基本数据类型不可以添加属性和方法; 基本数据类型的赋值是简单的赋值（如果从一个变量向另一个变量赋值基本类型的值，会在变量对象上创建一个新值，然后把该值赋值到位新变量分配的位置上）; 基本数据类型的比较是值的比较; 基本类型的值在内存中占据固定大小的空间，被保存在栈内存中; (看不懂就点击看详解)[https://blog.csdn.net/lareinalove/article/details/79895760] typeof 共返回 6 种数据格式：“number”、”string”、”boolean”、”object”、”function”、”undefined” (如果检测 null,对象和数组都会返回’object’) null 和 undefined 的区别null 表示没有对象，即该处不应该有值 默认转成 0undefined 表示缺少值，即此处应该有值，但没有定义 默认转成 NaN 如何判断是否为数组 instanceof 123function isArray(obj) &#123; return obj instanceof Array;&#125; instanceof 是怎么实现判断数组的https://zhidao.baidu.com/question/757412065588762204.html?fr=iks&amp;word=js%D6%D0%B5%C4instanceof+%C5%D0%B6%CF%CA%FD%D7%E9%B5%C4%D4%AD%C0%ED%CA%C7&amp;ie=gbk Array 对象的 isArray 方法 123function isArray(obj) &#123; return Array.isArray(obj);&#125; Object.prototype.toString 123function isArray(obj) &#123; return Object.prototype.toString.call(obj) === "[object Array]";&#125; 常用的数组方法数组循环方法reduce() 数组扁平化、数组去重、统计数组 原数组不变map() 原数组被“映射”到新数组 原数组不变filter() 通过测试的元素集合成新数组，都没通过则返回空数组 原数组不变some() 用于检测数组中的元素是否满足指定条件every() 方法用于检测数组所有元素是否都符合指定条件（通过函数提供）includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false。 indexOf() 返回符合条件的第一个值的索引 无则返回-1 原数组不变find() 返回符合条件的第一个数组的值 无则返回 undefined 原数组不变 splice() 通过删除现有元素/或添加新元素来修改数组,并以数组返回原数组中被修改的内容push pop(删最后一个) shift(删第一个) reverse(倒叙) sort(排序)这些都会改变原数组 注解：arr.sort((a,b)=&gt;a-b) 操作 a-b 数字小到大排列反之大到小排列 数组七个原生方法“push”, //添加到末尾“pop”, //删最后一个“shift”, //删第一个“unshift”, // 添加到开头。 arr.unshift(1,2))“splice”, //通过删除现有元素/或添加新元素来修改数组 Array.splice(start,deleteCount 个数,itemN 要添的内容)“sort”, //排序“reverse”, //倒序 for in 和 for of的区别详解以及为for in的输出顺序使用foreach遍历数组的话，使用break不能中断循环，使用return也不能返回到外层函数。重点!!! for in遍历的是数组的索引（即键名），而for of遍历的是数组元素值 一. for in遍历数组的毛病1.index索引为字符串型数字，不能直接进行几何运算2.遍历顺序有可能不是按照实际数组的内部顺序3.使用for in会遍历数组所有的可枚举属性，包括原型。例如上栗的原型方法method和name属性所以for in更适合遍历对象，不要使用for in遍历数组。 for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引namefor of 不同与 forEach, 它可以与 break、continue和return 配合使用,也就是说 for of 循环可以随时退出循环。 ES6 Proxy属性https://www.cnblogs.com/gaozonghui/p/13419556.htmlhttps://www.jianshu.com/p/ee181bd7e711 Proxy 用于修改某些操作的默认行为(如属性查找，赋值，枚举，函数调用等)，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。语法let proxy = new Proxy(target, handler);1、set(target, key, value, receiver) 拦截对象属性的设置2、get(target, key, receiver) 拦截对象属性的读取 get方法拦截了读取操作，set方法拦截了改写操作3、has(target, Key) 判断对象是否具有某个属性。4、apply(target, thisArgs, args) 拦截函数的调用、call和apply操作5、construct(target, args，newTarget) 拦截new命令 Vue3解决问题之Proxy在Vue中的作用👇https://www.cnblogs.com/xiaonian8/p/13764938.html 返回各种数字 数学对象 Math。 包含了 js 中一切和数学有关的功能；如：随机数函数 Math.random() 可以产生任意的浮点数 Math.round() 四舍五入得出一个最接近的整数 toFixed() 把 Number 四舍五入为指定小数位数的数字。 num.toFixed(‘2’) 但是这个方法并不能够精确保留 四舍五入精确保留两位小数 公式: Math.round(9.225 Math.pow(10,2) )/Math.pow(10,2); 或者 Math.round(2.128100)/100把一个数字舍入为最接近的整数。比如 0.5 将舍入为 1，而 -0.5 将舍入为 0 公式: Math.round(x) isNaN() 判断传入值是否为数字 返回布尔值 parseInt(参数) 将字符型的数字转化为数字，去掉小数点只保留整数。 内存泄漏当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象停留在堆内存中，产生了内存泄漏。 意外的全局变量（在 js 中，一个未声明变量的使用，会在全局对象中创建一个新的变量；在浏览器环境下，全局对象就是 window） 计时器和回调函数 timers js 闭包 console 垃圾回收机制JavaScript 引擎中有一个后台进程称为垃圾回收器，它监视所有对象，并删除那些不可访问的对象。无法访问的数据块 es6 新增箭头函数 let const 模板字符串 展开运算符 解构赋值新的数组结构 set(可以存放任何数据类型的唯一值) 和 map(传统对象 key 值必须为字符串 这个可以声明任何类型的 key)Promise(es6) async 和 await(es7) 用法更加简单且 async/await 的优势在于处理 then 链式操作新的数组方法 Array.of() Array.from find() includes() var 与 let、const 的区别 什么是变量提升？JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。JavaScript 中，变量可以先使用再声明。 var 声明变量存在变量提升，let 和 const 不存在变量提升 let、const 都是块级局部变量 同一作用域下只有 var 可以声明同名变量 const 的特性和 let 完全一样，const 不同的只是1）声明时候必须赋值2）只能进行一次赋值，即声明后不能再修改3）如果声明的是复合类型数据，可以修改其属性 解构赋值及其原理https://segmentfault.com/a/1190000018628030 // 基础类型解构let [a, b, c] = [1, 2, 3]console.log(a, b, c) // 1, 2, 3 使用场景 浅拷贝 交换变量等 解构是 ES6 提供的语法糖，其实内在是针对可迭代对象的 Iterator 接口，通过遍历器按顺序获取对应的值进行赋值。这里需要提前懂得 ES6 的两个概念：Iterator 可迭代对象 对 promise 的理解和 解决回调地狱没有 Promise 之前,解决异步都是依赖回调,操作多时就会回调中嵌着回调,这就是回调地狱.Promise 让代码变得更具有可读性和可维护性，将请求和数据处理明确的区分开 总结: 状态三个 方法四个.then .catch、.all、.race 三个状态：Pending(进行中)、Fulfilled(已成功)、Rejected(已失败)Promise 存在 resolve 和 reject 两个回调函数作为自身参数：new Promise((resolve, reject){}); 四个方法:.then 方法，解决回调地狱问题，可以传递两个参数，一个是成功的回调一个是失败的回调。 .catch 异常处理 .all(传入一个数组,每一项分别是一个 Promise 实例), 当数据里的 Promise 状态都变为 resolve 时,.all 状态才变为 resolve(里面的请求是同时执行的) .race(传入一个数组,每一项分别是 Promise 实例), 与.all 相反, 只要有一个 Promise 状态变为 resolve, .all 就变为 resolve(里面的请求是同时执行的) Promise 静态方法 all/race 的差别Promise.all: 在所有的 Promise 异步操作完成之后，执行某个任务就可以使用 Promise.allPromise.race: 在第一个 Promise 异步操作完成之后，就执行某个任务 12345678910111213141516171819var p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log("执行完成"); //1秒之后输出： 执行完成 resolve("我的数据-成功"); // reject('我的数据-失败') &#125;, 0); console.log("我先执行"); //先输出：我先执行&#125;);//使用p.then((value) =&gt; &#123; console.log(value); //100&#125;).catch((error) =&gt; &#123; console.error(error);&#125;);Promise.all([p, p, p]).then((values) =&gt; &#123; console.log(Date.now(), values);&#125;); 手写一个 promisehttps://blog.csdn.net/chenjuan1993/article/details/81632465 async 和 awaitasync/await 则直接将异步操作变成了同步的写法 async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。 (await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。) await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try…catch 代码块中。 123456789101112131415async function myFunction() &#123; try &#123; await somethingThatReturnsAPromise(); &#125; catch (err) &#123; console.log(err); &#125;&#125;// 另一种写法async function myFunction() &#123; await somethingThatReturnsAPromise().catch(function (err) &#123; console.log(err); &#125;);&#125; export 与 export default 区别都可以导出常量 函数 文件和模块在一个文件或者模块中 export default 只能有一个 而 export,import 可以有多个通过 export 方式导出 在导入的时候要加{} export default 则不用使用 export default 为模块指定默认输出 所以加载的时候不需要知道加载模块的变量名 而 export default 需要知道 递归递归函数就是在函数体内调用本函数； 递归函数的使用要注意函数终止条件避免死循环 闭包是什么，有什么特性，对页面有什么影响?闭包是指可以访问另一个函数作用域中的变量的函数。创建闭包的常见方式就是在一个函数内部创建另一个函数。 为什么要用：1.可以在全局作用域中读取内部函数的的变量，2.可以重复使用变量，并且不会造成变量污染 3.可以让闭包中引用的变量始终保存在内存中。 注意：闭包的变量会保存在内存中比其他函数占更多内存 滥用闭包会导致性能问题以及内存泄漏。因此可以手动解除对匿名函数的引用(赋值 null)，以便释放内存。生命周期-&gt; 回收机制 原型原型: 每一个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，实例都包含一个指向原型对象的内部指针。 原型链原型链: js 中所有对象都是由原型对象继承而来，而原型对象自身也是一个对象，他也有自己的原型对象。这样层层递进，就是原型链的基本概念。-原型链上的所有元素都是对象 原型链的终点是 obj 函数的 prototype 属性，而 objec.prototype 指向的原型对象同样拥有原型 他的原型就是 null 作用域就是一个独立的地盘，让变量不会外泄、暴露出去. 最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。全局作用域和函数作用域 块级作用域 作用域链当前作用域没有定义的变量，这成为自由变量 。一层一层向上寻找自由变量的值，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 作用域链 js 是怎么实现继承的链接 👉链接 👉 原型链继承(prototype) —不能向父级传参，原型对象属性会被所有实例共享 借用构造函数 通过使用 apply(最多接受两个参)和 call(可以接受多个参)方法在新创建的对象上执行构造函数–可以向父级传参 不会被共享 缺点是无法实现构造函数复用，只能继承父类构造函数的属性 组合继承–每个实例引入的构造函数都是私有的 缺点是调用了两次父类构造函数耗内存将原型链和借用构造函数的技术组合到一块，从而发挥二组之所长的一种继承模式。使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承 原型式继承 –所有实例都会继承原型上的属性。 无法实现复用（新实例属性都是后面添加的） 寄生式继承 –没用到原型，无法复用 寄生组合式继承（常用） –重点：修复了组合继承的问题 es6 新增 extends 继承 class 可以通过 extends 关键字实现继承 1234567891011121314151617class ClassDemo &#123; constructor(value) &#123; this.value = value; &#125; test() &#123; console.log(this.value); &#125;&#125;class ClassExtends extends ClassDemo &#123; constructor(value) &#123; super(value); //子类构造函数中必须调用 super &#125;&#125;//测试var demo = new ClassExtends("我是测试语句");demo.test(); //我是测试语句console.log(demo.__proto__); 事件绑定和普通事件有什么区别?事件绑定 事件叠加事件只能回收 不精准能精准的解除哪个函数如:document.addEventListener(“mousemove”, myFunction);document.removeEventListener(“mousemove”, myFunction); 对事件循环的理解JavaScript 的事件分两种，宏任务(macro-task)和微任务(micro-task) 宏任务：包括整体代码 script，setTimeout，setInterval微任务：Promise.then(非 new Promise)，process.nextTick(node 中) 事件的执行顺序，是先执行宏任务，然后执行微任务，这个是基础，任务可以有同步任务和异步任务，同步任务进入主线程，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。这个过程的不断重复就是事件循环 任务队列中会优先执行微任务在执行宏任务(而且会先执行异步任务再执行同步任务) 一次性执行完微任务 宏任务是一个一个执行的 https://blog.csdn.net/yun_hou/article/details/88697954 事件委托(事件代理)是什么利用事件冒泡的原理，让父元素代替执行自己所触发的事件！适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。不适合的：mouseover 和 mouseout 虽然也有事件冒泡，因为需要经常计算它们的位置，处理起来不太容易。不能的：focus，blur 之类的，本身就没用冒泡的特性，自然就不能用事件委托了。 如何阻止事件冒泡？stopPropagation();cancelBubble = true; 数组去重 for 加 if new Map()通过 filter 过滤 1234function unique(arr) &#123; const res = new Map(); return arr.filter((a) =&gt; !res.has(a) &amp;&amp; res.set(a, 1));&#125; new Set()数据类型 可以存储任何数据类型,并且是唯一的(不重复的值)再通过 Array.from()转化成数组类型 1234function dedupe(array) &#123; return Array.from(new Set(array));&#125;dedupe([1, 1, 2, 3]); // [1, 2, 3] 箭头函数和普通函数的区别 外形不同：箭头函数使用箭头定义，普通函数中没有 箭头函数都是匿名函数普通函数可以有匿名函数，也可以有具体名函数，但是箭头函数都是匿名函数。 箭头函数不能用于构造函数，不能使用 new普通函数可以用于构造函数，以此创建对象实例。 箭头函数中 this 的指向不同在普通函数中，this 总是指向调用它的对象，如果用作构造函数，this 指向创建的对象实例。 1.箭头函数本身不创建 this也可以说箭头函数本身没有 this，但是它在声明时可以捕获其所在上下文的 this 供自己使用。注意：this 一旦被捕获，就不再发生变化 this 的指向this 永远指向的是最终调用它的对象 除非改变 this 指向或者箭头函数这种特殊情况 call 和 apply 和 bind 的区别?都是改变 this 的指向call 和 apply 都是可以把函数直接调用, bind 不会直接调用函数 call -&gt; 从第二个参数 开始 就是指的调用的函数的形参apply -&gt; 第二个参数 是一个数组 bind() 最简单的用法是创建一个函数，不论怎么调用，这个函数都有同样的 this 值call和apply都是对函数的直接调用，而bind方法返回的仍然是一个函数，因此后面还需要()来进行调用才可以。 call()方法的作用和 apply() 方法类似，区别：call 传参的时候要求我们给函数传参是一个个传的，而 apply 的要传的参数是以一个数组保存起来； call 的性能要比 apply 好一些（尤其是传递给函数的参数超过三个的时候） let arr = [10, 20, 30], obj = { } function fn (x, y, z) { } fn.apply (obj, arr); fn.call (obj, …arr); =》基于 ES6 的展开运算符也可以实现把数组中的每一项一次传递给函数 fn.bind(obj)(…arr); //但是由于bind返回的仍然是一个函数，所以我们还可以在调用的时候再进行传参。 防抖节流 防抖：指触发事件后在规定时间内回调函数只能执行一次，如果在规定时间内又触发了该事件，则会重新开始算规定时间。 用途：按钮提交做法：通过定时器将回调函数进行延时.如果在规定时间内继续回调,发现存在之前的定时器,则将该定时器清除,并重新设置定时器.这里有个细节,就是后面所有的回调函数都要能访问到之前设置的定时器,这时就需要用到闭包 节流：当持续触发事件时，在规定时间段内只能调用一次回调函数。如果在规定时间内又触发了该事件，则什么也不做,也不会重置定时器.用途 拖拽 总结：防抖是将多次执行变为最后一次执行，节流是将多次执行变为在规定时间内只执行一次 Git 部分git clone –初始化仓库git checkout ‘分支名字’ –切换到某分支git checkout –放弃分支修改git add –将修改加入缓存git commit -m ‘备注修改内容’ –提交到本地仓库git pull –拉取远程仓库变化git push –将本地仓库改动提交到远程git log –查看当前提交日志 提交代码流程1、git add .(后面有一个点，意思是将你本地所有修改了的文件添加到暂存区） 2、git commit -m””(引号里面是你的介绍，就是你的这次的提交是什么内容，便于你以后查看，这个是将索引的当前内容与描述更改的用户和日志消息一起存储在新的提交中) 3、git pull origin远程分支名 这是下拉代码，将远程最新的代码先跟你本地的代码合并一下，如果确定远程没有更新，可以不用这个，最好是每次都执行以下，完成之后打开代码查看有没有冲突，并解决，如果有冲突解决完成以后再次执行 1 跟 2 的操作 4、git push origin master(git push origin 本地分支名:refs/remotes/远程分支名） 将代码推至远程就可以了 不提交修改的代码时切换分支的方法 git stash 暂存当前修改的代码 (git stash 的栈会直接给一个 hash 值作为版本的说明) git stash pop 查看其他分支代码后，切换回来当前分支找回修改的代码。 (将 git stash 栈中最后一个版本取出来) 将某个分支的某个文件合并到当前分支在当前分支 使用命令 👉 git checkout 某分支名字 某些要合并过来的文件(文件之间用空格隔开) 请求这一块的HTTP 协议 参考https://zhuanlan.zhihu.com/p/57142784HTTP 协议通过请求/响应的方式，在客户端和服务端之间进行通信。http 和 https http 传输不安全 它的内容容易被第三方截获 https 在 http 的基础上增加了 ssl 安全层 HTTP 请求头属性Accpet 告诉服务端,客户端接收什么类型的响应Referer 表示这是请求是从哪个 URL 进来的,比如想在网上购物,但是不知道选择哪家电商平台,你就去问度娘,说哪家电商的东西便宜啊,然后一堆东西弹出在你面前,第一给就是某宝,当你从这里进入某宝的时候,这个请求报文的 Referer 就是www.baidu.comCache-Control 对缓存进行控制,如一个请求希望响应的内容在客户端缓存一年,或不被缓可以通过这个报文头设置Accept-Encoding 这个属性是用来告诉服务器能接受什么编码格式,包括字符编码,压缩形式(一般都是压缩形式) 例如:Accept-Encoding:gzip, deflate(这两种都是压缩格式)Host 指定要请求的资源所在的主机和端口User-Agent 作用：告诉服务器，客户端使用的操作系统、浏览器版本和名称 浏览器缓存-强制缓存和协商缓存原理：浏览器在本地磁盘对用户最近请求过的资源进行存储，当再次访问同一页面时，按照特定的策略加载缓存中的资源。浏览器缓存的优点有： 减少多余的数据传输，减少服务器的负担，提升网站的性能 加快了客户端加载网页的速度 强制缓存—— 状态码 200 不发送请求直接从缓存取 F5 刷新和 Ctrl+F5 强制刷新会致 Expires/Cache-Control 失效浏览器会先获取该资源缓存的 header 信息，根据其中的 expires 和 cahe-control(用来表示资源的缓存时间)判断是否命中强缓存，若命中则直接从缓存中获取资源，包括缓存的 header 信息，本次请求不会与服务器进行通信；Cache-Control:max-age=3600，代表着资源的有效期是 3600 秒。Cache-Control 还有其他的一些常用值 no-cache：不使用本地缓存。 no-store：直接禁止游览器缓存数据 协商缓存—— 状态码 304 不发送请求通过服务器来告知缓存是否可用 Ctrl+F5 强制刷新会致 Last-Modied/Etag 失效如果没有命中强缓存，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的 header 字段信息（Last-Modified/IF-Modified-Since、Etag/IF-None-Match）,由服务器根据请求中的相关 header 信息来对比结果是否命中协商缓存，若命中，则服务器返回新的响应 header 信息更新缓存中的对应 header 信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容 前端常见的攻击以及防御 XSS（Cross Site Scripting）跨站脚本攻击 （1）原理：页面渲染的数据中包含可运行的脚本（2）攻击的基本类型：反射型（url 参数直接注入）和存储型（存储到 DB 后读取时注入）（3）注入点：HTML 节点内的内容（text）；HTML 中 DOM 元素的属性；Javascript 代码；富文本解决: 1.我们可以在 http 响应头中设置 Content-Security-Policy 2.浏览器自带防御机制，http 响应头中自动添加 x-xss-protection，值为 0（关闭），1（打开），默认打开 //同时 meta 中也支持设置 Content-Security-Policy CSRF（Cross Site Request Forgy）跨站请求伪造原理：在第三方网站向本网站发起请求（1）用户在 a 站前端页面发起登录（身份认证）请求（2）a 站后端确认身份，登录成功，cookie 中存在用户的身份认证信息（3）b 站前端页面向 a 站后端发起请求，带着 a 站的 cookie 信息（身份认证信息），请求成功解决: 1.禁止第三方网站携带本网站的 cookie 信息 2.本网站前端页面添加验证信息：使用验证码或者添加 token 验证 点击劫持 原理：第三方网站通过 iframe 内嵌某一个网站，并且将 iframe 设置为透明不可见，将其覆盖在其他经过伪装的 DOM 上，伪装的可点击 DOM（按钮等）与实际内嵌网站的可点击 DOM 位置相同，当用户点击伪装的 DOM 时，实际上点击的是 iframe 中内嵌的网页的 DOM 从而触发请求操作特点：用户自己做了点击操作；用户毫不知情；解决:禁止内嵌 看这个 https://www.cnblogs.com/zhiying/p/11018331.html Iframe 有什么好处，有什么坏处？1.建立长连接 2.可以跨越通信(如多页面的中的音乐播放器) 3. https://www.zhihu.com/question/20653055 javascript 的同源策略?一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是主机名、协议和端口号的组合 浏览器为什么要有同源策略一个重要原因就是保护 cookie，cookie 中存着用户的登陆凭证，就相当于用户的账号密码。如:想象以下场景，你突然收到一封邮件说你的银行账号存在安全隐患，点击www.shazilai.com修复。虽然银行的官方网站是www.anquan.com，慌乱的你没有注意这么多点击链接输入帐号密码进行登陆。这个网站其实是 在你输入帐号密码的时候，如果没有同源策略，外部已经有脚本获取你的输入或者直接通过document.cookie窃取了你的信息并且发送给攻击者了。 ajax 请求的时候 get 和 post 方式的区别?get 请求和发送数据的内容都在 地址栏里 明文传输 不安全 32kpost (参数是有一个包的 所以比较安全) 比较安全 2g 既然如此那么 get 还有什么存在的意义GET 有如下几个特点：get 表达的是一种幂等的，只读的，纯粹的操作，即它除了返回结果不应该会产生其它副作用（如写数据库），因此绝大部分 get 请求（通常超过 90%）都直接被 CDN 缓存了，这能大大减少 web 服务器的负担。 POST 请求有如下特点：而 post 所表达的语义是非幂等的，有副作用的操作，所以必须交由 web 服务器处理。 问“为什么不用 POST 代替 GET”是没有意义的，就像“为什么不用写代替读”一样没有意义。 跨域解决方案? 造成跨域是因为（域名不同、端口不同，IP 不同）参考 https://www.cnblogs.com/itmacy/p/6958181.html 使用 ajax 的 jsonp 利用&lt; script\ &gt;标签的 src 可以跨域,就有了 jsonp 这种非正式传输协议请求方式只能是 get 请求 与服务端协商 callback 返回值 返回的数据也是 jsonp 格式的-回调函数名(json 数据) 1234567$.ajax(&#123; url:'', type:'get', dataType:'jsonp', //接收服务器数据的类型 jsonp:'callback', //用于服务端的获取函数的参数 jsonpCallback:'callback-success' //函数名称&#125;) 还有使用 jQuery 的 jsonp 插件 与方式一相比，请求方式不只局限于 get 请求，还可以是 post 请求，但从服务器从获取的数据依然是 jsonp 格式 vue 在 Config/index.js 里面进行配置 proxyTable: {} 123456789101112131415proxytable&#123; '/apis':&#123; target:'http://www.news.com',//接口域名 changeOrgin:true,//是否跨域 pathRewrite:&#123; '^/apis':' '//需要rewrite重写的 &#125; &#125;&#125; 关闭 chrome 安全策略实现跨域 多级域名跨域吗应该算跨域的 但这里有两个关键字 父域 cookie 和认证中心 TCP/IP 协议按照层次由上到下，层层包装。最上面的是应用层，这里面有 http，ftp,等等我们熟悉的协议。而第二层则是传输层，著名的 TCP 和 UDP 协议就在这个层次。第三层是网络层，IP 协议就在这里，它负责对数据加上 IP 地址和其他的数据以确定传输的目标。第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行 CRC 编码，为最后的数据传输做准备。 http 的三次握手和四次挥手 https://www.jianshu.com/p/bd31d3b23725 第一次握手：主机 A 发送位码为 syn ＝ 1,随机产生 seq number=1234567 的数据包到服务器，主机 B 由 SYN=1 知道，A 要求建立联机；第二次握手：主机 B 收到请求后要确认联机信息，向 A 发送 ack number=(主机 A 的 seq+1),syn=1,ack=1,随机产生 seq=7654321 的包；第三次握手：主机 A 收到后检查 ack number 是否正确，即第一次发送的 seq number+1,以及位码 ack 是否为 1，若正确，主机 A 会再发送 ack number=(主机 B 的 seq+1),ack=1，主机 B 收到后确认 seq 值与 ack=1 则连接建立成功。 第一次挥手：TCP 发送一个 FIN(结束)，用来关闭客户到服务端的连接。第二次挥手：服务端收到这个 FIN，他发回一个 ACK(确认)，确认收到序号为收到序号+1，和 SYN 一样，一个 FIN 将占用一个序号。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。（服务器端继续发送未发送完的数据）第三次挥手：服务端发送一个 FIN(结束)到客户端，服务端关闭客户端的连接。第四次挥手：客户端发送 ACK(确认)报文确认，并将确认的序号+1，这样关闭完成。注：1、那么为什么是 4 次挥手呢？tcp 握手的时候为何 ACK(确认)和 SYN(建立连接)是一起发送。挥手的时候为什么是分开的时候发送呢？因为当 Server 端收到 Client 端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当 Server 端收到 FIN 报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉 Client 端，”你发的 FIN 报文我收到了”。只有等到我 Server 端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。故需要四步握手。 状态码:状态码的第一位数字表示了响应状态的类型，其中1xx 信息提示2xx 成功3xx 重定向4xx 客户端错误5xx 服务器错误100 继续。客户端应继续其请求101 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议200 表示从客户端发来的请求在服务器端被正常处理了。204 该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中 不含实体的主体部分。206 该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。301 永久重定向。该状态码表示请求的资源已被分配了新的 URI，以后 应使用资源现在所指的 URI。302 临时重定向。该状态码表示请求的资源已被分配了新的 URI，希望 用户（本次）能使用新的 URI 访问。400 该状态码表示请求报文中存在语法错误。401 该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、 DIGEST 认证）的认证信息。403 该状态码表明对请求资源的访问被服务器拒绝了。404 该状态码表明服务器上无法找到请求的资源。 打开浏览器，输入 URL，到页面展示出来的过程：输入 URLDNS 解析TCP 握手HTTP 请求HTTP 响应返回数据浏览器解析并渲染页面 vue对于 MVC MVVM 的理解？MVC: MVC 是一种设计思想 分成 3 个核心模块，业务层(负责实现应用程序的业务逻辑，封装有各种对数据的处理方法)-视图层(负责应用程序对用户的显示)-控制层(负责控制应用程序的流程)优点: 1.有利于代码的复用 2.有利于开发人员分工 3.有利于降低程序模块间的耦合，便于程序的维护与扩展。所有通信都是单向的 MVVM: 数据模型 视图 视图模型 通过双向数据绑定把 View 层和 Model 层连接了起来 开发者只需关注业务逻辑,不需要手动操作 DOM. 双向数据绑定原理 Vue2：通过 es5 的 Object.defineProperty，中的 set 方法来实现数据劫持的，在数据发生变动的时候通知订阅着触发相应的回调。但是有一个弊端就是无法兼听到数组内部的数据变化(当然我们可以通过 arr = arr.concat([]))，来实现内部数据变化的检测。相比 Vue3 有一定的性能问题。 Vue3：是用 ES6 的语法 Proxy 对象来实现的，这个玩意儿也可以实现数据的劫持，相比 Object.defineProperty 的优势是：可以检测到数组内部数据的变化（IE 系列都不兼容 Proxy，所以可能还是用 Object. Object.defineProperty 是怎么监听数组变化的通过重写 Array 的原型方法 原理就是重写数组的七个原始方法,当使用者执行这些方法时,我们就可以监听到数据的变化,然后做些跟新操作https://blog.csdn.net/lyh6665/article/details/107929324 123456789101112131415161718const orginalProto = Array.prototype;const arrayProto = Object.create(orginalProto); // 先克隆一份Array的原型出来const methodsToPatch = [ "push", "pop", "shift", "unshift", "splice", "sort", "reverse",];methodsToPatch.forEach((method) =&gt; &#123; arrayProto[method] = function () &#123; // 执行原始操作 orginalProto[method].apply(this, arguments); console.log("监听赋值成功", method); &#125;;&#125;); 数组下标更改数组的值不生效Vue2并不支持数组下标的响应式。也就是说Vue2检测不到通过下标更改数组的值。为何Object.defineProperty已经实现了对对象属性和数组已有元素的监听 确不支持数组下标修改的双向绑定呢? 对此尤大的回答是性能代价和获得的用户体验收益不成正比 解决办法：使用Vue官网提供的方法更改数组下标的值 this.$set(this.list, index, this.list[index]) Proxy 的优势如下Proxy 可以直接监听整个对象而非属性。Proxy 可以直接监听数组的变化。Proxy 有 13 中拦截方法，如 ownKeys、deleteProperty、has 等是 Object.defineProperty 不具备的。Proxy 返回的是一个新对象，我们可以只操作新的对象达到目的，而 Object.defineProperty 只能遍历对象属性直接修改;Proxy 做为新标准将受到浏览器产商重点持续的性能优化,也就是传说中的新标准的性能红利。 Object.defineProperty 的优势如下兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平。 Object.defineProperty 不足在于：Object.defineProperty 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。Object.defineProperty 不能监听数组。是通过重写数据的那 7 个可以改变数据的方法来对数组进行监听的。Object.defineProperty 也不能对 es6 新产生的 Map,Set 这些数据结构做出监听。Object.defineProperty 也不能监听新增和删除操作，通过 Vue.set()和 Vue.delete 来实现响应式的。 proxy 都有哪些参数https://www.cnblogs.com/xiaonian8/p/13764938.html Object.defineProperty() 将属性变为不可修改http://cn.voidcc.com/question/p-xqtmixbf-uc.html防止在Javascript原型对象中更改属性的值我有一个对象，我有一个名为“country”的属性作为Ireland。我想阻止开发人员在尝试更新代码时修改这个属性 一个可能的方法与Object.defineProperty()定义在init()这个属性为不可写1234567891011const Car = &#123;country:'England'&#125;; Car.prototype = &#123; init: function() &#123; Object.defineProperty(this, 'country', &#123; value: this.country, enumerable: true, &#125;); &#125;, country: 'Ireland', &#125;; 单向数据流和双向数据绑定单向数据流： 数据是单向的 流动方向单一方便跟踪 追查问题更快速 缺点就是写起来不太方便双休数据绑定： 数据之间相通 将数据变更操作隐藏在框架内部 会简化大量业务代码 但是出错时增加了追查问题的难度 组件生命周期2.0 生命生命周期变化感觉变得更加语义化一点（有规律可寻，更好记了），而且增加了 beforeUpdate、updated、activated、deactivated，删除了 attached、detached。(Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载 Dom→ 渲染、更新 → 渲染、销毁等一系列过程，称之为 Vue 的生命周期。) beforeCreate（创建前）在数据观测和初始化事件还未开始 created（创建后）完成数据观 vue 测，属性和方法的运算，初始化事件，\$el 属性还没有显示出来 beforeMount（载入前）在挂载开始之前被调用，相关的 render 函数首次被调用。实例已完成以下的配置：编译模板，把 data 里面的数据和模板生成 html。注意此时还没有挂载 html 到页面上。 mounted（载入后）在 el 被新创建的 vm.\$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的 html 内容替换 el 属性指向的 DOM 对象。完成模板中的 html 渲染到 html 页面中。此过程中进行 ajax 交互。 beforeUpdate（更新前）在数据更新之前调用，发生在虚拟 DOM 重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。 updated（更新后）在由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用。调用时，组件 DOM 已经更新，所以可以执行依赖于 DOM 的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。 activated keep-alive 组件激活时调用。该钩子在服务器端渲染期间不被调用 deactivated keep-alive 组件停用时调用。该钩子在服务器端渲染期间不被调用 beforeDestroy（销毁前）在实例销毁之前调用。实例仍然完全可用。 destroyed（销毁后）在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 errorCaptured（2.5.0+ 新增） 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生 错误的组件实例以及一个包含错误来源信息的字符串，此钩子可以返回 false 以阻止该错误继续 向上传播 父子组件的生命周期顺序父 beforeCreate-&gt; 父 created-&gt; 父 beforeMount-&gt; 子 beforeCreate-&gt; 子 created-&gt; 子 beforeMount-&gt; 子 mounted-&gt; 父 mounted 子组件在父组件的 beforemounted 生命钩子完后才能后就开始实例化自己，并走完自己的整个生命周期等子组件的生命周期构建完成后挂载到父组件上，父组件的 mounted 才会执行，所以子组件先父组件完成生命周期。这也就是为什么在只有在 mounted 中的 children 属性才能看有子组件值，而不是空数组 子组件更新过程父 beforeUpdate-&gt; 子 beforeUpdate-&gt; 子 updated-&gt; 父 updated 父组件更新过程父 beforeUpdate-&gt; 父 updated 销毁过程父 beforeDestroy-&gt; 子 beforeDestroy-&gt; 子 destroyed-&gt; 父 destroyed 第一次页面加载会触发哪几个钩子？答：会触发 下面这几个 beforeCreate, created, beforeMount, mounted 。 DOM 渲染在 哪个周期中就已经完成？答：DOM 渲染在 mounted 中就已经完成了。 在哪个生命周期内调用异步请求一般来说，可以在，created，mounted 中都可以发送数据请求，但是，大部分时候，会在 created 发送请求。 在 created 钩子函数触发时，组件的 data 数据、通过路由注入的数据已经具备，此时可以使用这些数据发送 ajax 请求。在 mounted 钩子函数中发起也可以，但是相对比 created 稍微迟了一些。如果不需要依赖任何数据发起 ajax 请求，那么在 beforeCreate 发起也可以。 有两个优点：第一点：能更快获取到服务端数据，减少页面 loading 时间；第二点：放在 created 中有助于一致性，因为 ssr 不支持 beforeMount 、mounted 钩子函数。 created 与 activated 有什么区别created(): 在创建 vue 对象时，当 html 渲染之前就触发，但是全局 vue.js 不强制刷新或者重启时只创建一次，就是说 created()只会触发一次 activated()：是在路由设置时，才会有这个生命周期。在被 keep-alive 缓存的组件激活时调用。 keep-alive 两个属性-&gt; include、exclude 属性https://www.jianshu.com/p/4b55d312d297 123456&lt;keep-alive include="bookLists,bookLists"&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;keep-alive exclude="indexLists"&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; include 属性表示只有 name 属性为 bookLists，bookLists 的组件会被缓存，（注意是组件的名字，不是路由的名字）其它组件不会被缓存 exclude 属性表示除了 name 属性为 indexLists 的组件不会被缓存，其它组件都会被缓存 vue.js 的两个核心是什么？答：数据驱动、组件系统 传参父组件传给子组件：子组件通过 props 方法接受数据;父组件调用子组件函数:ref this.$refs.子组件.function();子组件传给父组件：\$emit 方法传递参数子组件调用父组件函数:$emit 兄弟组件传参:1.eventBus 2.Vuex跨组件传参： 1.Vuex 2.Bus 3.( provide/inject ) 4.( $attrs/$listeners ) v-model 的原理？v-model 是个语法糖:v-bind:value=”value”v-on:input=”e =&gt; value = e.target.value”因为 V-model 并不仅限于 Form 表单, 目前还支持更改事件名称和变量名称model: {prop: ‘checked’,event: ‘change’} 对 vue 的表单修饰符.lazy 的理解input 标签 v-model 用 lazy 修饰之后，vue 并不会立即监听 input Value 的改变，会在 input 失去焦点之后，才会触发 input Value 的改变 vue 给组件绑定自定义事件无效怎么解决？两种方式 组件外部加修饰符.navtive 组件内部声明\$emit(‘自定义事件’) vue 的 sync 修饰符用法答：sync 修饰符是一个语法糖，类似 v-model，它主要是解决了父子组件的双向绑定问题。sync 不能使用表达式 使用: 传值通过 变量.sync=’变量’ 接收也是props 子组件修改必须this.$emit(“update:变量”, 新值); 因为 vue 提倡的是单向数据流动，因此不能直接在子组件里面修改父组件传过来的数据，父子组件一个数据修改要带一个自定义事件才能实现双向绑定，但是有了 sync 可以这么写: 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;visible = true&quot;&gt;点击&lt;/button&gt; &lt;my-alert :visible.sync=&quot;visible&quot;&gt;&lt;/my-alert&gt; &lt;/div&gt;&lt;/template&gt;&lt;scrip &gt;import myalert from &quot;./components/myalert&quot;;export default &#123; name: &quot;App&quot;, components: &#123; &quot;my-alert&quot;: myalert &#125;, data() &#123; return &#123; visible: false, &#125;; &#125;,&#125;;&lt; /scrip&gt;// myalert.vue:&lt;template&gt; &lt;div class=&quot;cont&quot; v-show=&quot;visible&quot;&gt; &lt;h2&gt;这是一个对话框&lt;/h2&gt; &lt;button @click=&quot;closeAlert&quot;&gt;关闭&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script &gt;export default &#123; name: &quot;myalert&quot;, props: &#123; visible: &#123; type: Boolean, default: false, &#125;, &#125;, methods: &#123; closeAlert() &#123; this.$emit(&quot;update:visible&quot;, false); &#125;, &#125;,&#125;;&lt;/script &gt; sync 和 v-model 的区别v-model 必须是 input 标签，它做了两步动作：1、父组件传给子组件 value2、子组件通过触发 input 事件来修改 value因此，子组件必须有 input 标签才行。而 sync 不限制标签，因此子组件在修改数据时，就必须约定使用@update:xxx 如何在子组件中访问父组件的实例？父组件想调用子组件的方法，可以在子组件中加上 ref，然后通过 this.\$refs.ref.method 调用 Vue 中子组件调用父组件的方法，这里有三种方法提供参考： 直接在子组件中通过 this.\$parent.event 来调用父组件的方法 在子组件里用\$emit 向父组件触发一个事件，父组件监听这个事件 父组件把方法传入子组件中，在子组件里直接调用这个方法 为什么父组件更新而子组件不更新在子组件中加入 watch 进行数据监听 12345678910111213141516&lt;&gt;data()&#123; return&#123; msg:&quot;&quot; &#125;&#125;,watch:&#123; parendData(n,o)&#123; //n为新值,o为旧值; this.msg = n; &#125;&#125;,props:[&quot;parendData&quot;],mounted()&#123; this.msg = this.parendData;&#125;&lt;/&gt; 视图不更新参考 Vue.set( target, key, value ) 或者 this.\$set(target, key, value); target 可以是 obj 或 arr 如 Vue.set( arr, arr[i], ‘newText’ ) nextick 可在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数在 DOM 更新完成后就会调用。例如： this.tableData = []for (let i in list) {this.$set(this.tableData,i,list[i])}this.tableData.splice(1,0); 1234567891011121314151617181920&lt;&gt;data()&#123; return&#123; message:&quot;未更新&quot; &#125;, methods:&#123; updataMessage()&#123; this.message=&quot;已经更新&quot; console.log(this.message) //未更新 this.$nextTick(=&gt;&#123; console.log(this.message) //已经更新 &#125;) // 因为 $nextTick()返回一个 Promise 对象，所以可以使用新的 ES2016 async/await简写为👇： await this.$nextTick() &#125; &#125;&#125;&lt;/&gt; 数组数据变动，有些方法无法被 vue 监测 (如 arr.items[i] = newValue)push()，pop()，shift()，unshift()，splice()，sort()，reverse()可被 vue 检测到filter(), concat(), slice()。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组。 vue 多层循环，动态改变数据后渲染的很慢或者不渲染添加 this.$forceUpdate();进行强制渲染。原因：因为数据层次太多，render 函数没有自动更新，需手动强制刷新。 nextTick 的内部实现原理http://www.bubuko.com/infodetail-3219154.html 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 数据的变化到 DOM 的重新渲染是一个异步过程!!! 当我们在实际开发中，比如从服务端接口去获取数据的时候，数据做了修改，如果我们的某些方法去依赖了数据修改后的 DOM 变化，我们就必须在 nextTick 后执行。如下： getData(res).then(()=&gt;{this.xxx = res.datathis.\$nextTick(() =&gt; {// 这里我们可以获取变化后的 DOM})}) vue.set 做了什么总结的来说就是内部使用了数组原生方法 splice 通过去修改原数据触发更新 跳转页面三种方式总结就三种 router-link $router.push $router.replace 12345678910&lt;router-link to=&apos;需要跳转到的页面的路&gt; &lt;/router-link &gt;&lt;router-link :to=&quot;&#123;path:&apos;/register&apos;,query:&#123;id:5,name:&apos;lili&apos;&#125;&#125;&quot;&gt; 注册 &lt;/router-link &gt;this.$router.push(&#123;name: &apos;page1&apos;,query: &#123;id: 3&#125;&#125;);this.$router.replace(&#123;path：&apos;/&apos; &#125;) push 会保存在历史记录 replace 没有历史记录 this.$router.push()描述：跳转到不同的 url，但这个方法会向 history 栈添加一个记录，点击后退会返回到上一个页面。 this.$router.replace()描述：同样是跳转到指定的 url，但是这个方法不会向 history 里面添加新的记录，点击返回，会跳转到上上一个页面。上一个记录是不存在的。 注： query 和 params 都可以带参 但是！！jquery 通过 path 来引入路由 展示在地址栏刷新不会丢：localhost:8080/users?id=123 不设置参数也可params 通过 name 来引入路由 不展示在地址栏刷新会丢：localhost:8080/users/123 必须设置参数 this.$router.push({path:”地址”,query:{id:”123”}}); 这是传递参数this.$route.query.id； 这是接受参数 this.$router.push({name:”地址”,params:{id:”123”}}); 这是传递参数this.$route.params.id; 这是接受参数 $router 和 $route 的区别\$router 是 VueRouter 实例 想要导航到不同的 url 就用它 $route是当前router跳转对象里面可以获取name path query params 如：this.$route.query.id 怎么定义 vue-router 的动态路由? 怎么获取传过来的值答：在 router 目录下的 index.js 文件中，对 path 属性加上 /:id，使用 router 对象的 params.id 获取。 vue 怎么去掉 url 中的vue-router 默认使用 hash 模式 所以在路由加载的时候 url 会自带# 使用 history 模式就不会有了 1new Router(&#123; mode:&apos;history&apos;, routes:[] &#125;) 怎么给 vue 定义全局的方法？ 通过 prototype，这个非常方便。Vue.prototype[method]=method; 通过插件 Vue.use(plugin)； 通过 mixin，Vue.mixin(mixins); 👇 12345678910// 创建全局方法this.$root.$on("test", function () &#123; console.log("test");&#125;);// 销毁全局方法this.$root.$off("test");// 调用全局方法this.$root.$emit("test"); vue 如果想扩展某个现有的组件时 使用 Vue.extend 直接扩展 使用 Vue.mixin 全局混入 HOC 封装 加 slot 扩展 vue 中怎么重置 databject.assign(this.$data, this.$options.data()) 或者逐个重新赋值或者强制刷新组件 如何是重置 data 中的某个表单数据 👇this.params = this.\$options.data().params vue 组件的 data 为什么必须是函数因为 data 是一个对象那么他就属于引用类型，当我们修改其中一个属性时 会影响所有 vue 实例数据如果将 data 作为一个函数返回对象 那么 data 属性都是独立的 不会互相影响 vue 变量名如果以_、\$开头的属性会发生什么问题报错 变量未定义以 _ 或 $ 开头的属性 不会 被 Vue 实例代理，因为它们可能和 Vue 内置的属性、API 方法冲突。你可以使用例如 $data.xxx 或者_data.xxx 的方式访问这些属性。 在使用计算属性的时，函数名和 data 数据源中的数据可以同名吗？不该同名 这属于命名不规范 props、methods、data、computed、watch 会按这个顺序挂载在 vm 实例上，重名会覆盖前者 因此不能同名 watch 和 computed 还有 methods 有什么区别？methods 只要发生重新渲染他就会执行watch 不支持缓存，只要重新渲染就会执行，支持异步。computed 基于依赖进行缓存 只有它的依赖发生改变时才会重新求值 不支持异步 watch 和 created 哪个先执行在 wacth 监控数据时，设置 immediate：true；会优先执行 watch,created 后执行; 反之则反 watch 如何创建时就立即执行要使用 handler 和 immediate 1234567//immediate设为true 监听方法会在创建的时候 执行handler里的方法watch: &#123; value:&#123; handler:function(o,n)&#123;&#125;, immediate: true &#125; &#125; vue 中 mixins 和 extends 有什么区别？其实 mixins 和 extends 都可以理解为继承，mixins 接收对象数组（可理解为多继承），extends 接收的是对象或函数（可理解为单继承） 优先级 Vue.extend&gt;extends&gt;mixins&gt; 组件本身 extends 和 Vue.extend,Vue.componentVue.extend 创建组件的构造函数,为了复用。 其主要用来服务于 Vue.component Vue.component 注册或获取全局组件,为了方便. 实际上当你直接传递选项给Vue.component()的时候，它会在背后调用Vue.extend()。 extends 为了扩展 与 mixins 类似 详解 👉 vue 如何批量引入组件？ 把需要批量引入的组件放在一个文件夹管理 用 require.context 函数(这个函数的目的是递归一个文件夹)，将所有文件都读出来，然后再配合 forEach，将所有组件批量注册即可。 如果是全局批量引入就把 👆 操作放在新建的 xxx.js 文件 然后在 main.js 引入 局部批量引入 第一步就够了 详解 👉 vue 动态组件使用方法引入组件还是用 import 的方式，但是渲染方式是直接使用 component，使用:is 来决定展示哪一个组件(is 的值为组件名称)，但子组件每一次渲染都是全新的，会导致一个现象就是之前用户的操作丢失，为了保证用户的操作的原本性，使用缓存的标签(keep-alive)就可以了 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div&gt; &lt;el-button @click=&quot;showChild(&apos;A&apos;)&quot;&gt;显示A组件&lt;/el-button&gt; &lt;el-button @click=&quot;showChild(&apos;B&apos;)&quot;&gt;显示B组件&lt;/el-button&gt; &lt;keep-alive&gt; &lt;component :is=&quot;currCom&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;/div&gt;&lt;/template&gt;&lt;&gt;import childA from &quot;../childComponent/childA.vue&quot;; //A组件import childB from &quot;../childComponent/childB.vue&quot;; //B组件export default &#123; components: &#123; childA, childB, &#125;, data() &#123; return &#123; currCom: childA, &#125;; &#125;, methods: &#123; showChild(Str) &#123; this.currCom = &quot;child&quot; + Str; &#125;, &#125;,&#125;;&lt;/&gt; vue 项目如何引入异步组件？12345678// 方式一: const LRC = Vue.component("lrc",(resolve)=&gt;require(["../components/LRC"],resolve)) // 全局组件:在引入组件的script中操作// 方式二: components: &#123; 'my-component': () =&gt; import('./my-async-component') &#125; 怎么解决 vue 动态设置 img 的 src 不生效的问题？因为动态添加 src 被当做静态资源处理了，没有进行编译，所以要加上 require。 1&lt;img :src="require('@/assets/images/xxx.png')" /&gt; vue 路由的钩子函数全局钩子 beforeEach 页面加载之前 主要有 3 个参数 to，from，next 判断需要登录的页面进行拦截，做登录跳转(读取 token，如果存在……) router.afterEach 是页面加载之后 某个路由独享的钩子 beforeEnter12345678910const router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125; &#125; ] 组件内的守卫 beforeRouteEnter (to, from, next) {// 在渲染该组件的对应路由被 confirm 前调用// 不！能！获取组件实例 this// 因为当钩子执行前，组件实例还没被创建}, beforeRouteUpdate (to, from, next) {// 在当前路由改变，但是该组件被复用时调用// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。// 可以访问组件实例 this}, beforeRouteLeave (to, from, next) {// 导航离开该组件的对应路由时调用// 可以访问组件实例 this} vue 实现判断页面是否编辑及编辑页面未保存离开弹窗提示用 watch 监听数据，如果数据发生变化，用户点击了其他地方链接要离开页面，则根据 beforeRouteLeave 离开该页面时出发的卫士 弹窗提示，如果 watch 监听数据没发生变化，则不必提示。 123456789101112131415161718192021222324252627// 监听代码watch: &#123; datas: &#123; handler (val) &#123; if (val) &#123; this.count++ //判断数据变化的次数，因为刚加载数据未完全加载的时候，datas是空对象，待加载完之后，则出现一次数据变化， &#125; &#125;, deep: true // deep主要是深层次监听，因为数据是层层对象，比较复杂 &#125;&#125;,// 判断要离开的代码是：beforeRouteLeave (to, from, next) &#123; if (this.count &gt; 1) &#123; // 判断数据是否修改，如果修改按这个执行，没修改，则直接执行离开此页面 if (this.status) &#123; next() return &#125; // 弹窗显示 this.$refs.leaveTip.changeLimitDialog(true) this.leave = to next(false) &#125; else &#123; next() &#125;&#125;, vuex简介：每一个 Vuex 应用的核心就是仓库(store) 它包含着应用中大部分的状态(state)。场景有：组件之间的状态、音乐播放、登录状态、加入购物车 五个核心 store 存放只用于读取数据 -通过 this.\$store.state 读数据 getters 就像计算属性一样 用来过滤和计算数据 (它接受 state 作为第一个参数) -通过 this.\$store.getters 读数据 mutations 同步操作 更改 Vuex 的 store 中的状态的唯一方法 必须是同步函数 通过 store.commit 方法触发👇 以下写法都可以 12345678910111213141516171819202122// 定义const store = new Vuex.Store(&#123; state: &#123; count: 0, &#125;, mutations: &#123; increment(state) &#123; state.count++; &#125;, &#125;,&#125;);// 触发this.$store.commit("increment");this.$store.commit("increment", 10);this.$store.commit("increment", &#123; age: 10,&#125;);this.$store.commit(&#123; type: "increment", age: 10,&#125;); mutations 规则：👇最好提前在 store 中初始化所需属性。当需要在对象上添加新属性时，应该使用 Vue.set(obj, ‘newProp’, 123), 或者以新对象替换老对象如利用对象展开运算符 state.obj = { …state.obj, newProp: 123 } action 异步操作 提交的是 mutation，而不是直接变更状态。可以包含任意异步操作。 通过 store.dispatch 方法触发 Module 将 store 分割成模块（module） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 定义const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit('increment') &#125;, actionA (&#123; commit &#125;) &#123; // dispatch可以处理函数返回的Promise，且dispatch仍旧返回Promise return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit('someMutation') resolve() &#125;, 1000) &#125;) &#125;, actionB (&#123; dispatch, commit &#125;) &#123; return dispatch('actionA').then(() =&gt; &#123; commit('someOtherMutation') &#125;) &#125; // 假设actionA和actionB返回的都是Promise actions: &#123; async actionA (&#123; commit &#125;) &#123; commit('gotData', await getData()) &#125;, async actionB (&#123; dispatch, commit &#125;) &#123; await dispatch('actionA') commit('gotOtherData', await getOtherData()) &#125; &#125; &#125;,&#125;)// 调用this.$store.dispatch('increment')this.$store.dispatch('actionA').then(() =&gt; &#123; // ...&#125;) Vuex 和单纯的全局对象有以下两点不同： Vuex 的状态存储是响应式的。 当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交(commit) mutation。 取值在 computed 通过 👇store.state(getters)来获取 state(getters)中的状态：this.$store.state.xxx来获取vuex中的statethis.$store.getters.xxx (getter 这种通过属性访问时是可以缓存的)this.\$store.getters.xxx(10) (当 getter 返回一个函数 通过方法访问时，每次都会调用不会缓存结果) mutations 同步操作操作通过 commit 方法触发action 异步操作通过 dispatch 方法触发 为什么不在 data 中取 vuex 值？因为 data 中的内容只会在 created 钩子触发前初始化一次， 而 Vuex 的状态存储是响应式的 则之后 vuex 状态的变化影响不到初始值而 computed 则是通过【依赖追踪】在它的相关依赖发生改变时会重新求值 辅助函数 mapState mapGetters mapMutations mapActions 当一个组件需要获取多个状态的时候，我们可以使用辅助函数帮助我们生成计算属性 让代码更加简洁 1234567891011121314151617181920212223242526272829303132333435import &#123; mapState,mapGetters,mapMutations,mapActions &#125; from "vuex"; //先引入computed: &#123; // 两种写法 ...mapState(["1xx", "2xx"]), ...mapState(&#123; 1xx名字不一样: 'xx1', 2xx个名字不一样: 'xx2',, &#125;), // 也是两种写法 ...mapGetters(["1xx", "2xx"]) ...mapGetters(&#123; 1xx名字不一样: 'xx1', 2xx个名字不一样: 'xx2', &#125;), &#125;,&#125;methods: &#123; ...mapMutations([ 'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')` ]), ...mapMutations(&#123; add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')` &#125;)&#125;methods: &#123; ...mapActions([ 'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')` ]), ...mapActions(&#123; add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')` &#125;)&#125; 列如: 123456789101112131415161718192021222324252627//-----storeconst state = &#123; userData: &#123; xxx: &#123;&#125; &#125;&#125;;//------matutionsetValue(state,xxx)&#123; state.userData.xxx= xxx;&#125;//-----组件内存值methods: &#123; fn() &#123; this.$store.commit('xxx', 10) &#125;&#125;// dispatch 异步操作 this.$store.dispatch('actions的方法'，arg)// commit 同步操作 this.$store.commit('mutations的方法'，arg)//组件内取值 computed: &#123; value() &#123; return this.$store.state.userData.xxx; &#125; &#125; Vue.observable 你有了解过吗vue2.6 发布一个新的 API 类轻量级 vuex，可以处理一些简单的跨组件共享数据状态的问题 123456789101112//store.jsimport Vue from "vue";export let store = Vue.observable(&#123; count: 0, name: "张三" &#125;);export let mutations = &#123; setCount(count) &#123; store.count = count; &#125;, setName(name) &#123; store.name = name; &#125;,&#125;; vue-cli 如何新增自定义指令？场景 https://blog.51cto.com/u_15302032/3068128 directives() Vue.directive(id, definition)传入的两个参数，id 是指指令 ID，definition 是指定义对象。其中，定义对象可以提供一些钩子函数 12345678910111213141516171819Vue.directive("my-directive", &#123; // 一个指令定义对象可以提供如下几个钩子函数 bind: function () &#123; //只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置 &#125;, inserted: function () &#123; //按钮权限一般用这个钩子 https://www.jianshu.com/p/6a072b906cef //被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 &#125;, update: function () &#123; //根据获得的新值执行对应的更新 //对于初始值也会调用一次 &#125;, componentUpdated: function () &#123; //指令所在组件的 VNode 及其子 VNode 全部更新后调用。 &#125;, unbind: function () &#123; // 只调用一次，指令与元素解绑时调用。 做清理操作 &#125;,&#125;); 场景-输入框自动聚焦 123456789// 注册一个全局自定义指令 `v-focus`Vue.directive('focus', &#123; // 当被绑定的元素插入到 DOM 中时 inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;)&lt;input v-focus&gt; 场景-相对时间转换 类似微博、朋友圈发布动态后的相对时间，比如刚刚、两分钟前等等 123456789101112131415161718192021&lt;span v-relativeTime="time"&gt;&lt;/span&gt;;new Vue(&#123; el: "#app", data: &#123; time: 1565753400000, &#125;,&#125;);Vue.directive("relativeTime", &#123; bind(el, binding) &#123; // Time.getFormatTime() 方法，自行补充 el.innerHTML = Time.getFormatTime(binding.value); el.__timeout__ = setInterval(() =&gt; &#123; el.innerHTML = Time.getFormatTime(binding.value); &#125;, 6000); &#125;, unbind(el) &#123; clearInterval(el.innerHTML); delete el.__timeout__; &#125;,&#125;); vue 几种常用的指令答：v-for 、 v-if 、v-bind、v-on、v-show、v-else 监听多个事件使用 v-on 指令绑定多个事件 –第四种方法 1234567891011&lt;!--1. 普通绑定方法 --&gt;&lt;button v-on:click=&quot;onClick&quot;&gt;&lt;/button&gt;&lt;!--2. 内联语句，传参 --&gt;&lt;button v-on:click=&quot;onClick(&apos;hello&apos;, $event)&quot;&gt;&lt;/button&gt;&lt;!-- 3. 缩写 --&gt;&lt;button @click=&quot;onClick&quot;&gt;&lt;/button&gt;&lt;!--4. 对象语法 (2.4.0+) --&gt;&lt;button v-on=&quot;&#123; click: onClick, focus: onFocus, blur: onBlur &#125;&quot;&gt;&lt;/button&gt; v-if 和 v-show 哪个优先级更高？v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。注意，v-show 不支持 &lt; template &gt; 元素，也不支持 v-else。 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 v-show 指令算是重排吗？页面渲染时，当页面中元素的位置，大小或结构、定位发生改变，或者对 HTML 结构增删查改时，浏览器会对所有的 dom 进行重新排序，这就是 DOM 回流，严重影响浏览器性能。 因 v-show 指令改变 display 的属性，会发生重排。 v-if 和 v-for 的优先级是什么？如果这两个同时出现时，那应该怎么优化才能得到更好的性能？ 答： v-for 的优先级更高这意味着 v-if 将分别重复运行于每个 v-for 循环中，所以不推荐同时使用 v-if 和 v-for 避免出现这种情况，如果实在需要，则在外嵌套 template，在这一层进行 v-if 判断，然后在内部进行 v-for 循环 v-for 如何倒序输出 先把数组做一层 reverse()倒叙处理，然后在执行 v-for ❀ 据说我没测 css 的 flex 容器的 order 也是种骚方法 温习：push() 数组末尾添加pop() 数组末尾取出shift() 数组开头取出unshift() 数组开头添加splice() 删除并插入sort() 排序reverse() 数组顺序颠倒 vue 如何自定义一个过滤器？ Vue2.0 不再支持这种写法像金钱格式\$7000.00, 时间格式 ,小数点filters: {} 里面定义函数 filtersName 1234&lt;div&gt; &#123;&#123;msg| filtersName &#125;&#125; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 目前能用的是 全局方法（推介） computed 属性 \$options.filters（推介） 详解 👉 vue 怎么实现强制刷新组件？强制重新渲染 this.\$forceUpdate() v-if强制重新刷新某组件 12345678910//模版上绑定key&lt;SomeComponent :key="theKey"/&gt;//选项里绑定datadata()&#123; return&#123; theKey:0 &#125;&#125;//刷新key达到刷新组件的目的theKey++; 跟 keep-alive 有关的生命周期是哪些？描述下这些生命周期 keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。 keep-alive 的生命周期 activated： 页面第一次进入的时候，钩子触发的顺序是 created-&gt;mounted-&gt;activated deactivated: 页面退出的时候会触发 deactivated，当再次前进或者后退的时候只触发 activated 如何在 keep-alive 缓存界面实时获取后台数据实时获取数据用 websoket 或者轮询由于用到了 keepalive, 所以页面在再次加载时不会触发 created 而是触发 activated 所以接收数据，重置数据要用 Vue.set()方法写到 activated 方法下 你知道 vue 中 key 的原理吗？说说你对它的理解 vue 中 key 值的作用？ 给元素标记的唯一性 作用主要是为了高效的更新虚拟 DOM。 需要使用 key 来给每个节点做一个唯一标识，Diff 算法就可以正确的识别此节点，找到正确的位置区插入新的节点。作用：便于 diff 算法的更新，key 的唯一性，能让算法更快的找到需要更新的 dom（高效的更新虚拟 DOM） vue 业务代码阐述 style 标签中写入 scoped 即可只在当前组件起作用 列举样式穿透符 1. /deep/ 2. &gt;&gt;&gt; 3. ::v-deep vue 等单页面应用及其优缺点答：优点：Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件，核心是一个响应的数据绑定系统。MVVM、数据驱动、组件化、轻量、简洁、高效、快速、模块友好。缺点：不支持低版本的浏览器，最低只支持到 IE9；不利于 SEO 的优化（如果要支持 SEO，建议通过服务端来进行渲染组件）；第一次加载首页耗时相对长一些；不可以使用浏览器的导航按钮需要自行实现前进、后退。 使用 vue 后怎么针对搜索引擎做 SEO 优化？ssr,即单页面后台渲染 vue-meta-info 与 prerender-spa-plugin 预渲染 nuxt 服务器配置 node 环境。 phantomjs 针对爬虫做处理 解决 vue 首次白屏路由懒加载 使用 CDN 使用首页广告 优化性能分页 图片跟路由懒加载 精灵图 打包压缩 懒加载怎么做以往 compont 的引入方式就是（../../啥的）现在要改成 resolve =&gt; require([‘../components/PromiseDemo’], resolve) ajax、fetch、axios 这三都有什么区别？ ajax 是最早出现发送后端请求的技术，属于原生 js 范畴,核心是使用 XMLHttpRequest 对象,使用较多并有先后顺序的话，容易产生回调地狱。 fetch 号称可以代替 ajax 的技术，是基于 es6 中的 Promise 对象设计的，参数和 jQuery 中的 ajax 类似，它并不是对 ajax 进一步封装，它属于原生 js 范畴。没有使用 XMLHttpRequest 对象。 axios 不是原生 js,使用时需要对其进行安装，客户端和服务器端都可以使用，可以在请求和相应阶段进行拦截，基于 promise 对象。 如何在全局使用 axios 的实例呢在 main.js 文件下导入 axiso，并挂载到 vue 实例上import axios from ‘axios’;Vue.prototype.\$axios = axios; axios 同时请求多个接口，如果当 token 过期时，怎么取消后面的请求？axios 的话可以使用 cancelToken 来实现。如果是原生的 XMLhttprequest 的话，需要使用 abort()方法实现。 详情 👉 vue 为什么要求组件模板只能有一个根元素答：我们只有指定了唯一的 el 根元素，才能交给 Vue 实例在内部通过 createElement(创建元素节点)方法生成一个对应的虚拟 DOM 结构映射真实的 DOM 元素进行操作渲染成真正的 HTML 换句话来说，可以把 el 对应的元素理解成 Vue 接管部分中的一个顶级标签，就像基本的 HTML 结构中，顶级标签是 ，只能有一个这样的标签存在。对应到 Vue 中也是这样，如果你给它两个顶级标签，那么对应的 DOM 结构就无法生成了，这也就解释了之前的疑惑：为什么不能指定多个入口让 Vue 实例一个个的试。 虚拟 dom虚拟 DOM 是对 DOM 的抽象，本质上是 JavaScript 对象 虚拟 DOM 最初的目的，就是更好的跨平台，比如 Node.js 就没有 DOM,如果想实现 SSR(服务端渲染),那么一个方式就是借助虚拟 DOM,因为虚拟 DOMDOM 本身是 JavaScript 对象.前端频繁操作 DOM 导致的重排重绘是最影响前端性能的 而生成虚拟 DOM 可以与旧的 DOM 通过 diff 算法对比找出更新的节点再更新到视图 diff 算法Vue 数据渲染中最核心的的部分就是 diff 算法的应用 (vue 虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较更新时，就用到了该算法) vdom 为何用 diff 算法 DOM 操作是昂贵的，因此尽量减少 DOM 操作找出本次 DOM 必须更新的节点来更新，其他的不更新这个’找出’的过程，就需要 diff 算法 diff 算法有两个比较显著的特点： 比较只会在同层级进行, 不会跨层级比较。在 diff 比较的过程中，循环从两边向中间收拢 这也是为什么循环列表中要用 key 标记元素的唯一性 diff 比较的过程中方便比对详细解说 .vue 文件中 style 是必须的吗？那 script 是必须的吗都不是必须的，如果是普通组件那么只能是一个静态 html，如果是函数式组件， 那么可以直接使用 props 等函数式组件属性。 vue 渲染模板时怎么保留模板中的 HTML 注释呢？设置 comments 属性，官网默认为舍弃注释 1&lt;template comments&gt; ... &lt;/template&gt; vue 项目本地开发完成后部署到服务器后报 404 或许是什么原因呢？ 检查 nginx 配置，是否正确设置了资源映射条件； 检查 vue.config.js 中是否配置了 publicPath，若有则检查是否和项目资源文件在服务器摆放位置一致。 使用了 history 模式，而后端又没有进行相关资源配置。 预渲染和 SSR(服务端渲染)有什么区别服务端渲染和预渲染的使用场景还是有较明显的区别的。预渲染的使用场景更多是我们所说的静态页面的形式。服务端渲染适用于大型的、页面数据处理较多且较为复杂的、与服务端有数据交互的功能型网站，一个明显的使用场景就是电商网站。 你有用过预渲染技术吗？怎么做的？预渲染的核心是使用 prerender-spa-pluginnew PrerenderSPAPlugin({staticDir: path.join(__dirname, ‘dist’),routes: [ ‘/‘, ‘/home’, ‘/infomation’, ‘/ticket’, ‘/scenery’, ‘/about’ ],renderer: new Renderer({headless: false,renderAfterDocumentEvent: ‘render-event’})}),项目所有的路由，最终生成后有几个页面，都是以这个配置为依据，而不是你在 vue-router 中配置的路由。 说说你对 vue 的错误处理的了解？分为 errorCaptured 与 errorHandler。errorCaptured 是组件内部钩子，可捕捉本组件与子孙组件抛出的错误，接收 error、vm、info 三个参数，return false 后可以阻止错误继续向上抛出。errorHandler 为全局钩子，使用 Vue.config.errorHandler 配置，接收参数与 errorCaptured 一致，2.6 后可捕捉 v-on 与 promise 链的错误，可用于统一错误处理与错误兜底。https://blog.fundebug.com/2019/06/17/handling-errors-in-vuejs/ vue 版本以及御其他框架差异你知道 vue2.0 兼容 IE 哪个版本以上吗？不兼容 ie8 及以下，是因为 vue 的响应式原理是基于 es5 的 Object.defineProperty 的,而这个方法不支持 ie8 及以下。部分兼容 ie9 ，完全兼容 10 以上 你是从 vue 哪个版本开始用的？你知道 1.x 和 2.x 有什么区别吗？2016 年发布的 vue2.0 版本，区别：1、 2.0 生命生命周期变化感觉变得更加语义化一点（有规律可寻，更好记了），而且增加了 beforeUpdate、updated、activated、deactivated，删除了 attached、detached。2、2.0 将 1.0 所有自带的过滤器都删除了，也就是说，在 2.0 中，要使用过滤器，则需要我们自己编写3、vue1.0 的数据绑定完全依赖于数据侦测，使用 Object.defineProperty 方法使数据去通知相应 watch，改变 dom 结构。vue2.0 引入了虚拟 dom，只通知到组件，提升了颗粒度。 vue2 和 vue3 的区别 重构响应式系统，使用 Proxy 替换 Object.defineProperty 新增 Composition API，更好的逻辑复用和代码组织 重构 Virtual DOM 跳转答案详解 vue3.0 特性支持 TypeScript兼容 IE11双向数据绑定原理：Vue2.x：其双向数据绑定原理是通过 es5 的 Object.defineProperty，中的 set 方法来实现数据劫持的，但是有一个弊端就是无法兼听到数组内部的数据变化(当然我们可以通过 arr = arr.concat([]))，来实现内部数据变化的检测。相比 Vue3 有一定的性能问题。Vue3.x：是用 ES6 的语法 Proxy（Proxy 怎么用大家可自行百度，网上教程大把，我就不在这赘述了）对象来实现的，这个玩意儿也可以实现数据的劫持，相比 Object.defineProperty 的优势是：可以检测到数组内部数据的变化（IE 系列都不兼容 Proxy，所以可能还是用 Object.defineProperty） vue 与 React 的区别?两者本质的区别：模板和组件化的区别Vue 本质是 MVVM 框架，由 MVC 发展而来；React 是前端组件化框架，由后端组件化发展而来；Vue 使用模板React 使用 JSXReact 本身就是组件化Vue 是在 MVVM 上扩展的共同点：都支持组件化，都是数据驱动视图 21.说说 vue 的优缺点优点： 数据驱动 模块化 轻量级 SPA 版本 3.0 的界面化管理工具比较好使 vue 易入门 中文社区强大，入门简单，提升也有很多的参考资料。 缺点： 8. 吃内存（每个组件都会实例化一个 Vue 实例，实例的属性和方法很多） 9. 定义在 data 里面的对象，实例化时，都会递归的遍历转成响应式数据，然而有的响应式数据我们并不会用到，造成性能上的浪费 10. 像 keep-alive transition transition-group 这些内置组件，不管用不用其实都已经挂到 Vue.options.components 上，如果不用，造成对象变大，从而占用内存 11. 父子组件更新，没有明确的来源 12. 不支持 IE8 及以下浏览器 为什么我们写组件的时候可以写在.vue 里呢？可以是别的文件名后缀吗？以什么后缀跟 VUE 没有任何关系，vue 只是个特殊的 text 文件而已，就算你用 .abc 都行。这一切都该归功于 webpack，在 webpack 的 loaders 配置中，能让你给指定文件一个，或多个加载器。你也可以把这些加载器理解为预编译工具。 123456789module: &#123; rules: [ &#123; test: /\.vue$/, // 这里指定 .vue 文件通过 vue-loader 解析，你可以指定任何类型的文件。 loader: "vue-loader", options: vueLoaderConfig, &#125;, ];&#125; 你有看过 vue 推荐的风格指南吗？列举几条 使用 v-for 时记得加 key，可以快速定位到需要更新的 DOM 节点，提高效率。 永远不要把 v-if 和 v-for 同时用在同一个元素上。提高渲染效率 为组件样式设置 scoped 作用域 优先通过 Vuex 管理全局状态，而不是通过 this.\$root 或一个全局事件总线 官方风格指南:👉 实现一个双向绑定的微型框架方案： 利用 ES6 中的 Proxy(代理)和 Reflect 实现简单的双向数据绑定vue3 也把 obj.defineProperty() 换成了 Proxy+Reflect。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;proxy&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;使用Proxy 和 Reflect 实现双向数据绑定&lt;/h1&gt; &lt;input type="text" id="input" /&gt; &lt;h2&gt;您输入的内容是： &lt;i id="txt"&gt;&lt;/i&gt;&lt;/h2&gt; &lt;&gt; //获取dom元素 let oInput = document.getElementById("input"); let oTxt = document.getElementById("txt"); //初始化代理对象 let obj = &#123;&#125;; //给obj增加代理对象 let newProxy = new Proxy(obj, &#123; get: (target, key, recevier) =&gt; &#123; //console.log("get:"+ key) return Reflect.get(target, key, recevier); &#125;, set: (target, key, value, recevier) =&gt; &#123; //监听newProxy是否有新的变化 if (key == "text") &#123; oTxt.innerHTML = value; &#125; //将变化反射回原有对象 return Reflect.set(target, key, value, recevier); &#125;, &#125;); //监听input输入事件 oInput.addEventListener("keyup", (e) =&gt; &#123; //修改代理对象的值 newProxy.text = e.target.value; &#125;); &lt;/&gt; &lt;/body&gt;&lt;/html&gt; 监听 input 的时候修改 newProxy 的值，检测到 newProxy 重新设置了值得时候，因为 newProxy 代理了 obj 这个对象， 所以可以调用 Reflcet 反射到原 obj.所以修改了 Input 的值后，然后控制台输入 obj,会打印出 input 的值。 小程序#小程序 优化总结https://blog.csdn.net/weixin_29603489/article/details/112036759 小程序自定义头部怎样设置 在 app.json 里面把 “navigationStyle” 设置为 “custom” 计算相关值因为在不同的手机型号头部那条栏目高度可能不一致，所以为了我们适配更多型号，我们需要计算 3 个值： 1.整个导航栏高度 = statausBarHeight + height + (top-statausBarHeight )*2； 2.胶囊按钮与顶部的距离 = top； 3.胶囊按钮与右侧的距离 = windowWidth - right。 因为这个头部导航是公共的，所以我们最好把它设置成一个组件，命名为 navbar在 index.json 中引用该组件 在 index.wxml 中使用该组件 如下：https://www.cnblogs.com/sese/p/9761713.html 文件类型wxml wxss js json 小程序与 vue 双向绑定哪里不一样vue 通过 this.data 同步数据小程序必须调用 this.setData({}) 小程序传递数据的方法 全局变量 在 app.js 文件中定义全局变量 globalData 获取通过 getApp()拿到存的全局变量 通过 wx.navigateTo 将数据放在 url 里面 在 onload 的时候初始化 小程序的生命周期函数onLoad 页面加载时触发。一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数onShow() 页面显示/切入前台时触发onReady() 页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互onHide() 页面隐藏/切入后台时触发。 如 navigateTo 或底部 tab 切换到其他页面，小程序切入后台等onUnload() 页面卸载时触发。如 redirectTo 或 navigateBack 到其他页面时 小程序跳转页面的方式小程序分包整个小程序所有分包大小不超过 4M，单个分包/主包大小不能超过 2M分包数量目前没有限制，也就是说你可以放 N 个分包，甚至每个页面一个分包入口页面/TAB 页面必须在主包里 小程序用户标识微信官方提供了两种标识： OpenId 是一个用户对于一个小程序／公众号的标识，开发者可以通过这个标识识别出用户。 UnionId 是一个用户对于同主体微信小程序／公众号／APP 的标识，开发者需要在微信开放平台下绑定相同账号的主体。开发者可通过UnionId，实现多个小程序、公众号、甚至 APP 之间的数据互通。 同一个用户的这两个 ID 对于同一个小程序来说是永久不变的，就算用户删了小程序，下次用户进入小程序，开发者依旧可以通过后台的记录标识出来 小程序登陆流程https://blog.csdn.net/Ed7zgeE9X/article/details/116724843https://www.cnblogs.com/hjk1124/p/12881926.html 「静默登录」和「用户登录」的区别静默登录」是获取微信登录态的过程，通过获取微信提供的用户身份标识，快速建立小程序内的用户体系。用户登录」是用户授权个人开放数据成为会员的过程，是指从游客态转换成会员态的，拥有购买等操作权限。 静默登陆 总结为以下三步： 小程序端调用 wx.login() 获取 临时登录凭证code(目前有效时长目前为5分钟) ，并回传到开发者服务器。 服务器端调用 auth.code2Session 接口，换取用户唯一标识 OpenID 和 session_key。 此时服务器会返回一个token作为登陆状的标识 将登陆态的标识token进行存储，以便下次使用 请求需要登陆态标识的接口时，携带token 储存token值: 使用getGlobolData存储，以供本次小程序运行使用， 使用wx.Setstorage存储token,以便下次小程序运行使用 tips: 很多开发者会把 wx.login 和 wx.getUserInfo 捆绑调用当成登录使用，其实 wx.login 已经可以完成登录，wx.getUserInfo 只是获取额外的用户信息。wx.getUserInfo 只是为了提供更优质的服务而存在，比如获取用户的手机号注册会员，或者展示头像昵称，判断性别，开发者可通过 unionId 和其他公众号上已有的用户画像结合来提供历史数据。因此开发者不必在用户刚刚进入小程序的时候就强制要求授权。 登陆失效https://blog.csdn.net/hjh15827475896/article/details/110098433?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;utm_relevant_index=2 UnionID获取途径https://www.jianshu.com/p/46efa68d9033 调用接口wx.getUserInfo，从解密数据中获取UnionID。注意本接口需要用户授权，请开发者妥善处理用户拒绝授权后的情况。 如果开发者帐号下存在同主体的公众号，并且该用户已经关注了该公众号。开发者可以直接通过wx.login获取到该用户UnionID，无须用户再次授权。 如果开发者帐号下存在同主体的公众号或移动应用，并且该用户已经授权登录过该公众号或移动应用。开发者也可以直接通过wx.login获取到该用户UnionID，无须用户再次授权 webpack https://www.quxingdong.com/1309.html 原理简介参考https://www.jianshu.com/p/e24ed38d89fdwebpack 是一个打包模块的机制 他就是识别你的入口文件 模块依赖 然后将这些模块转化成静态文件webpack 做的就是分析代码。转换代码，编译代码，输出代码。webpack 本身是一个 node 的模块，所以 webpack.config.js 是以 commonjs 形式书写的(node 中的模块化是 commonjs 规范的) 核心概念1 入口 entry 2. 输出 output 3. loader 处理非 js 文件 因为 webpack 只能理解 js 文件4.plugins 执行更多的任务 从打包优化和压缩到重新定义环境中的变量5.mode 选择 develoment(开发) 或 production(生产) 来设置 mode 参数 启用相应模式下的 webpack 内置优化 development 模式下 启用 NamedChunksPlugin 和 NamedModulesPlugin 打包后，一些没有依赖的方法 变量 文件会保留，production 则会移除。 development 模式下 启用众多优化插件(如 UglifyJsPlugin 移除没有用的 css js) 打包后，代码会进行压缩，比 development 的文件小。 什么是模块化https://www.cnblogs.com/Yellow-ice/p/10639029.html 模块化开发是一种管理方式，是一种生产方式，一种解决问题的方案，一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块但是模块开发需要遵循一定的规范，否则就都乱套了，因此，才有了后来大家熟悉的 AMD 规范，CMD 规范 AMD AMD 即 Asynchronous Module Definition，中文名是“异步模块定义”的意思，它采用异步方式加载模块，模块的加载不影响它后面语句的运行，所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行 一般来说，AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出，因为平时在开发中比较常用的是 require.js 进行模块的定义和加载，一般是使用 define 来定义模块，使用 require 来加载模块 CMD CMD 即 Common Module Definition 通用模块定义，CMD 规范是国内发展出来的，同时，CMD 是在 SeaaJS 推广的过程中形成的，CMD 和 AMD 要解决的都是同个问题，在使用上也都很像，只不过两者在模块定义方式和模块加载时机上有所不同 webpack 的构建流程是什么?初始化参数开始编译：确定入口：编译模块：完成模块编译：输出资源：输出完成： 怎么配置单页应用？怎么配置多页应用？单页应用可以理解为 webpack 的标准模式，直接在 entry 中指定单页应用的入口即可，这里不再赘述多页应用的话，可以使用 webpack 的 AutoWebPlugin 来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范 有哪些常见的 Loader？他们是解决什么问题的？file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去source-map-loader：加载额外的 Source Map 文件，以方便断点调试image-loader：加载并且压缩图片文件babel-loader：把 ES6 转换成 ES5css-loader：加载 CSS，支持模块化、压缩、文件导入等特性style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。eslint-loader：通过 ESLint 检查 JavaScript 代码 打包优化按需加载 路由以及三方组件按需引入提取公共代码 webpack3 使用 CommonsChunkPlugin webpack4 使用 splitChunksCDN 优化优化 loader 配置 优化正则匹配 开启缓存 减少被处理的文件。生产环境关闭 sourceMap (开启得话打包出来的 js 文件中的代码可以映射到代码文件的具体位置,这种映射关系会帮助我们直接找到在源代码中的错误。)代码压缩 ParallelUglifyPlugin 开启多个子进程同时压缩 webpack 的 4.0 打包优化 (更加高效) 优化 loader 配置1.1 缩小文件匹配范围(include/exclude) 缩小了 loader 加载搜索范围 高概率命中文件1.2 缓存 loader 的执行结果(cacheDirectory) 减少 webpack 构建时 Babel 重新编译过程 HappyPack 多线程打包HappyPack 是让 webpack 对 loader 的执行过程，从单一进程形式扩展为多进程模式，也就是将任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。从而加速代码构建 与 DLL 动态链接库结合来使用更佳。 地址 https://www.php.cn/js-tutorial-391843.html 怎么解决 vue 打包后静态资源图片失效的问题？找到 config/index.js 配置文件，找 build 打包对象里的 assetsPublicPath 属性默认值为/，更改为./就好了最新的 vue-cli 需要在根目录下建一个 vue.config.js 在里面配置 publicPath 即可 打包产生的页面缓存怎么办webpack 配置 filename 可规定 index.html 页面需要引入的 js 文件名称，index 页面内其他的按需加载的文件可生成名称为[模块名].[hash].js。(hash 在每次打包后会改变)。&lt; script src=”/js/index_v2.js”&gt; &lt;/ script&gt; 怎么修改 vue 打包后生成文件路径 webpack：output.path vue-cli3: vue.config.js 中设置 outputDir 打包优化 按需加载 路由以及三方组件按需引入 提取公共代码 webpack3 使用 CommonsChunkPlugin webpack4 使用 splitChunks CDN 优化 优化 loader 配置 优化正则匹配 开启缓存 减少被处理的文件。 生产环境关闭 sourceMap (开启得话打包出来的 js 文件中的代码可以映射到代码文件的具体位置,这种映射关系会帮助我们直接找到在源代码中的错误。) 代码压缩 ParallelUglifyPlugin 开启多个子进程同时压缩 vue-loader 在 webpack 编译流程中的哪个阶段编译模板的阶段从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理 有哪些常见的 Plugin(插件)? 他们是解决什么问题的？html-webpack-plugin //生成 html 文件copy-webpack-plugin //复制到剪切板clean-webpack-plugin //这个插件是在打包的时候使用的 因为打包的 output 中使用了 hash 码，使文件名是唯一的，不删除的话 dist 文件夹里面就会一堆文件define-plugin：//定义环境变量commons-chunk-plugin：//提取公共代码uglifyjs-webpack-plugin：//通过 UglifyES 压缩 ES6 代码extract-text-webpack-plugin //提取样式到单独的 css 文件CommonsChunkPlugin //提取公共的 JS 库 webpack 本地开发怎么解决跨域使用 webpack-dev-server 插件步骤：下载插件 在 webpack.config 文件中引入插件 使用 devServer 配置端口和代理重写路径 __dirname 和 ./ 的区别_dirname 总是指向被执行 js 文件所在的绝对路径，所以当你在 /d1/d2/myscript.js 文件中写了 **dirname， 它的值就是 /d1/d2 。 相反，./ 会返回你执行 node 命令的路径，例如你的工作路径。 有一个特殊情况是在 require() 中使用 ./ 时，这时的路径就会是含有 require() 的脚本文件的相对路径。 Hash（散列函数哈希 是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。HASH 是根据文件的内容的数据通过逻辑运算得到的数值, 不同的文件(即使是相同的文件名)得到的 HASH 值是不同的, 所以 HASH 值就成了每一个文件在 EMULE 里的身份证.不同 HASH 值的文件在 EMULE 里被认为是不同的文件,相同的 HASH 值的文件的内容肯定是完全相同(即使文件名不同).HASH 值还有文件校验的功能,相当于文件的校验码.所以还可以用来检查文件下载是否正确(所以 EMULE 下载完毕时,都会在 HASH 文件一遍, 检查文件是否出错) Typescript简介： Typescript 是强类型的 Javascript 超集，支持 ES6 语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript 并不直接在浏览器上运行，需要编译器编译成纯 Javascript 来运行。 他解决了什么呢 解决前端的规范问题 提前暴露问题 比如防止了团队合作中有人改错数据导致 bug2. 链接 👉 https://www.jianshu.com/p/c8aaba6e8ce0 Typescript 有哪些基础类型？1：number 2：string 3：boolean 4：Symbol 5：Array 6：Tuple(元组) 7：enum(枚举) 8：object 9：never 表示那些永不存在的值类型。如总是抛出异常或者根本不会有返回值的函数的返回值类型。 10：void 类型的变量只能赋值为 undefined 和 null。函数没有返回值时用 void。 11：null 和 undefined 它们是所有类型的子类型。当你指定 structNullChecks 时，它们只能赋值给 void 或者它们自己本身。 12：any 表示任何类型的值 NUXT对于 nuxt 来说，有两个特点： 摒弃了 vue 中的路由表，改为文件结构自动生成的路由，比如 pages/users/index.vue，即生成 /users 对应的路由，当然也可以使用 pages/users.vue 渲染该路由，比较灵活。将 Vue 中的 Layout 单独抽为 视图 概念，在 nuxt 项目根目录的 layouts 文件夹内编写。 业务问题权限设计你现在做的项目最复杂功能有哪些大文件上传 如一个 G 的文件或者 500M 的文件https://www.6hu.cc/archives/11164.html大文件上传将大文件转换成二进制流的格式使用流能够切开的特色，将二进制流切开成多份拼装和切开块持平数量的央求块，并行或串行的方法宣告央求断点续传为每一个文件切开块添加不同的标识当上传成功的之后，记载上传成功的标识当咱们暂停或许发送失利后，能够从头发送没有上传成功的切开文件 HTML5 的 FILE api，有一个 slice 方法，可以将 BLOB 对象进行分割。前端通过 FileList 对象获取到相应的文件，按照指定的分割方式将大文件分段，然后一段一段地传给后端，后端再按顺序一段段将文件进行拼接。断点续传原理目前比较常用的断点续传的方法有两种，一种是通过 websocket 接口进行文件上传，另一种是通过 ajax，两种方法各有千秋，虽然 websocket 听起来比较高端些，但是除了用了不同的协议外其他的算法基本上都是很相似的，并且服务端要开启 ws 接口，这里用相对方便的 ajax 来说明断点上传的思路。说来说去，断点续传最核心的内容就是把文件“切片”然后再一片一片的传给服务器，但 WEB 前端实现在线预览、编辑 Office 文档https://blog.csdn.net/nuclear2011/article/details/117369109 使用插件：Spire.Cloud 在线 Office 文档编辑器（官网：https://cloud.e-iceblue.cn/） 重点：该方案仅需浏览器支持 HTML5，提供中英文双语界面，不需要安装 Office 或控件，也不需要做环境配置就可以直接调用插件，非常简单。 更新项目版本后如何不强制刷新更新页面https://www.jianshu.com/p/a5a32acbf205 一、meta 标签处理vue-cli 里的默认配置，css 和 js 的名字都加了哈希值，所以新版本 css、js 和就旧版本的名字是不同的，不会有缓存问题。关键在于 index.html 文件它会被浏览器缓存。浏览器访问的还是旧的静态资源。解决办法如下，在 meta 标签禁止浏览器缓存 html 123&lt;meta http-equiv="cache-control" content="no-cache,no-store, must-revalidate" /&gt;&lt;meta http-equiv="pragma" content="no-cache" /&gt;&lt;meta http-equiv="Expires" content="0" /&gt; 二、版本号 + 定时器每次发版都应该有个版本号，很多开发者忽略了这个问题。这里我就用大白话说下我的思路。发版的时候我们把更新的版本号存放到静态文件中。然后定时用 ajax 请求获取这个静态文件的版本号。最后跟浏览器内存中的版本号进行对比，如果不一致则说明有更新。js 执行刷新页面。 12345678910111213141516171819202122// 定时获取版本号setInterval(() =&gt; &#123; checkUpdate();&#125;, 6000);function checkUpdate() &#123; axios .get(`/getVersion?timestamp=$&#123;Date.parse(new Date())&#125;`) .then(function (response) &#123; // 判断版本号是否与本地一致 if (response.version != localStorage.getItem("version")) &#123; localStorage.setItem("version", response.version); location.reload(); &#125; else &#123; //版本号一致不做处理 console("版本号一致不做处理"); &#125; &#125;) .catch(function (error) &#123; console.log(error); &#125;);&#125; 开发中遇到的 bug,难点 怎么解决的 小程序 setdata 性能差解决: 为了提升数据更新的性能，开发者在执行 setData 调用时，最好遵循以下原则：不要过于频繁调用 setData，应考虑将多次 setData 合并成一次 setData 调用；数据通信的性能与数据量正相关，因而如果有一些数据字段不在界面中展示且数据结构比较复杂或包含长字符串，则不应使用 setData 来设置这些数据； // 不要频繁调用 setData this.setData({ a: 1 }) this.setData({ b: 2 })// 绝大多数时候可优化为this.setData({ a: 1, b: 2 }) // 不要设置不在界面渲染时使用的数据，并将界面无关的数据放在 data 外this.setData({myData: {a: ‘这个字符串在 WXML 中用到了’,b: ‘这个字符串未在 WXML 中用到，而且它很长…………………………’}}) // 可以优化为this.setData({‘myData.a’: ‘这个字符串在 WXML 中用到了’}) this._myData = {b: ‘这个字符串未在 WXML 中用到，而且它很长…………………………’} Vue 电商 SKU 组合算法问题 https://www.cnblogs.com/ykCoder/p/10942055.html 前端大量数据检索 优化https://blog.csdn.net/weixin_42048805/article/details/113058577通过建立字典树（Trie）来优化搜索。无论用户想访问任何属性的值，只要从树的根节点出发，依据属性字母出现的顺序访问树的叶子节点，即可得到该属性的值。 如何高性能的渲染十万条数据(虚拟列表)有时会遇到需要一些不能使用分页方式来加载列表数据的业务情况，对于此，我们称这种列表叫做长列表。比如，在一些外汇交易系统中，前端会实时的展示用户的持仓情况(收益、亏损、手数等)，此时对于用户的持仓列表一般是不能分页的。 https://hefeng6500.github.io/blog/performance/virtual-scroll 只对可见区域进行渲染，对非可见区域中的数据不渲染或部分渲染的技术，从而达到极高的渲染性能。假设有 1 万条记录需要同时渲染，我们屏幕的可见区域的高度为500px,而列表项的高度为50px，则此时我们在屏幕中最多只能看到 10 个列表项，那么在首次渲染的时候，我们只需加载 10 条即可。 步骤:在首屏加载的时候，只加载可视区域内需要的列表项，当滚动发生时，动态通过计算获得可视区域内的列表项，并将非可视区域内存在的列表项删除。计算当前可视区域起始数据索引(startIndex)计算当前可视区域结束数据索引(endIndex)计算当前可视区域的数据，并渲染到页面中计算startIndex对应的数据在整个列表中的偏移位置startOffset并设置到列表上 单点登录手写算法题 已知如下数组，编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]; 答：使用 Set 方法去重，flat(Infinity)扁平化 sort() 排序Array.from(new Set(arr.flat(Infinity))).sort((a,b)=&gt;{ return a-b})//输出 [1,2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14] js 实现点击不同的按钮后各自返回被点击的次数-关于闭包 12345678910111213141516171819202122232425262728293031323334353637383940&lt;input type="button" value="按钮A" onclick="countA()"&gt;&lt;input type="button" value="按钮B" onclick="countB()"&gt;&lt;input type="button" value="按钮C" onclick="countC()"&gt;&lt;script&gt; //方案1 大于两个时候比较繁琐 var counter=0; var counter2=0; function count1()&#123; //1、全局变量适合做返回所有按钮的总点击数，否则用全局变量的话每一个按钮要多一个函数，用闭包就很方便 counter+=1; alert('您共点击了我'+counter+'次') &#125; function count2()&#123; counter2+=1; alert('您共点击了我'+counter2+'次') &#125; //方案2 function count() &#123; var counter = 0; function increment() &#123; counter += 1; //2、闭包实现原理：这个匿名函数用了外面函数的变量，外面函数的变量被常驻内存，有几个匿名函数，匿名函数中用的的这个变量就有多少个在内存， alert('您共点击了我'+counter+'次'); &#125; return increment &#125; var countA=count(); var countB=count() var countC=count() // function count() &#123; // var counter = 0; // (function () &#123; // return(function()&#123; // counter += 1; // alert('您共点击了我'+counter+'次'); // &#125; // )() // &#125;)() // &#125; &lt;/script&gt; 关于作用域 123456789101112(function () &#123; var a = (b = 3);&#125;)();console.log(b); // 3console.log(a); // a is not defined/*首先分析 var a = b = 3 可以拆分为 b = 3 b是全局变量，在立即执行函数里赋值为3var a = b a是立即执行函数里声明的变量，函数执行完a就被释放， 并没有生成全局变量a，所以在全局输出a会报错：a is not defined*/ return 12345678910111213function foo1() &#123; return &#123; bar: "hello", &#125;;&#125;function foo2() &#123; return; &#123; bar: "hello"; &#125;&#125;console.log(foo1()); //&#123;bar: "hello"&#125;console.log(foo2()); //undefined 先看他们的区别就是 return 后面的“{}”一个是在同一行一个是换了一行，那么我们看见这个就能想到return 有个特点就是：其后面同一行内跟的值就返回，要是换了一行的话，return 后面会自动补一个分号，那么下一行的内容就不会再执行（1）因为 return 标志着函数的结束，其后面的内容不执行。（2）并且 return 没有明确返回值的话，就会默认返回一个 undefined。（3）用函数加括号就等于函数内 return 的值。 css 实现对元素自动排序 在 CSS2.1 中的自动编号由两个属性控制，它们分别为：“counter-increment”和“counter-reset”。由这些属性定义的计数器（counter）与“content”属性的 counter()和 counters()函数一起使用。 . 例：显示了使用“第 1 章”，“1.1”，“1.2”等对章节进行编号的方法。 12345678 &lt;h1&gt;大标题&lt;/h1&gt; &lt;h2&gt;小标题1&lt;/h2&gt; &lt;h2&gt;小标题2&lt;/h2&gt; 123456789101112131415161718192021222324252627 body&#123; counter-reset:chapter;/*创建章节计数器范围*/ &#125; h1:before&#123; content:"第"counter(chapter)"章、"; counter-increment:chapter;/*在章节中添加1*/ &#125; h1&#123; counter-reset:section;/*将部分设置为0*/ &#125; h2:before&#123; content:counter(chapter)"."counter(section)""; counter-increment:section; &#125; 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合，左括号必须以正确的顺序闭合。输入：s = “([)]” 输出：false输入：s = “{[]}” 输出：true 1234567891011121314151617181920212223242526public boolean isValid(String s) &#123; //假如长度是1或者不为偶数 if(s.length()&lt;2||s.length()%2!=0)&#123; if(s.isEmpty())&#123; return true; &#125; else&#123; return false; &#125; &#125; int count = 0; int length = s.length(); //循环替换，最大次数为s.length()/2 while(count&lt;length/2)&#123; s = s.replace("&#123;&#125;","").replace("[]","").replace("()",""); count++; &#125; //假如循环替换完，还有值，那么肯定就不是对称结构 if(s.length()&gt;0)&#123; return false; &#125; else&#123; return true; &#125;&#125; 当 for 嵌套这定时器由于变量 i 直接暴露在全局作用域内，当调用 console.log 函数开始输出时，这是循环已经结束，所以会输出 10 个 10。 12345for (var i = 0; i &lt; 10; i++) &#123; setTimeout(function () &#123; console.log(i); &#125;, 1000);&#125; 这种情况下如何才能按循环循序输出打印呢 使用闭包相当于利用一个匿名函数的壳模拟出一个块级作用域 1234567for (var i = 0; i &lt; 10; i++) &#123; (function (e) &#123; setTimeout(function () &#123; console.log(e); &#125;, 1000); &#125;)(i);&#125; &amp;&amp; 和 || &amp;&amp; 1.1 两边条件都为 true 时，结果才为 true；1.2 如果有一个为 false，结果就为 false；1.3 当第一个条件为 false 时，就不再判断后面的条件 注意：当数值参与逻辑与运算时，结果为 true，那么会返回的会是第二个为真的值；如果结果为 false，返回的会是第一个为假的值。 || 2.1 只要有一个条件为 true 时，结果就为 true；2.2 当两个条件都为 false 时，结果才为 false；2.3 当一个条件为 true 时，后面的条件不再判断 注意：当数值参与逻辑或运算时，结果为 true，会返回第一个为真的值；如果结果为 false，会返回第二个为假的值； console.log( 0 || 1 );// 1console.log( 1 || 2 );// 1console.log( 0 &amp;&amp; 1 );// 0console.log( 1 &amp;&amp; 2 );// 2 对象键名称只能是字符串var a={},b={key:’b’},c={key:’c’}; a[b]=123;a[c]=456; console.log(a[b]);//为什么是 456？ 因为键名称只能是字符串，b/c 单做键会调用 toString 得到的都是[object Object]，a[b],a[c]都等价于 a[“[object Object]”]，那不就是更新[object Object]这个键的值了 高阶函数 fun()()1234567891011121314151617function sum() &#123; var num = arguments[0]; if (arguments.length === 1) &#123; return function (sec) &#123; return num + sec; &#125;; &#125; else &#123; var num = 0; for (var i = 0; i &lt; arguments.length; i++) &#123; num = num + arguments[i]; &#125; return num; &#125;&#125;sum(2, 3); //5sum(2)(3); //5 arguments 是一个对应于传递给函数的参数的类数组对象。类数组：是数组的形式，有 length，但不具有数组的一切方法 ## 以下哪条语句会产生运行错误（ ） A、var obj = ( ); 错 B、var obj = [ ]; C、var obj = { }; D、var obj =/ /; 这个中间每空格注释写法而已 NaNnull === undefined //falsenull == undefined //trueNaN == NaN //false JavaScript 的规定，NaN 表示的是非数字， 但是这个非数字也是不同的，因此，NaN 不等于 NaN，并且两个 NaN 永远不可能相等。 实现一个 sleep 函数比如 sleep(1000)代表等待 1000ms 12345678910111213141516171819202122232425262728293031323334353637// 方法一：ES5 方式实现function sleep(callback, time) &#123; if (typeof callback == "function") &#123; setTimeout(callback, time); &#125;&#125;function output() &#123; console.log(1);&#125;sleep(output, 2000);// 方法二：使用 promise 方式const sleep = (time) =&gt; &#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve, time); &#125;);&#125;;sleep(2000).then(() =&gt; &#123; console.log(1);&#125;);// 方法三：利用 asyncfunction sleep(ms) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function init() &#123; var temp = await sleep(2000); console.log("YJJ"); //2s后执行&#125;init(); 如何让(a===1&amp;&amp;a===2&amp;&amp;a===3)判断成立 先监听 a 这个变量，当每次访问 a 的时候返回自拟定的值 12345678910111213141516171819// 第一种方法 还用tostring方法const a = &#123; value: 0 &#125;;a.valueOf = function () &#123; return (this.value += 1);&#125;;console.log(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3); //true// 第二种方法var value = 0;Object.defineProperty(window, "a", &#123; get() &#123; //使用defineProperty的get属性 return (value += 1); //每访问一次a 就a++ &#125;,&#125;);if (a === 1 &amp;&amp; a === 2 &amp;&amp; a === 3) &#123; console.log("success");&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript]]></title>
    <url>%2F2012%2F03%2F01%2FTypeScript%2F</url>
    <content type="text"><![CDATA[简介TypeScript 是 JavaScript 的一个超集，主要提供了 类型系统 和对 ES6 的支持，由 Microsoft 开发。 编译型语言：编译为 js 后运行，单独无法运行;强类型语言;面向对象的语言; 个人觉得写起来比较麻烦 优点是增加了代码的可读性和可维护性以及减少运行时出错(因为错误会在定义的时候就报错) 目前只使用到数据类型这一块 希望以后有机会拓展 数据类型12345678910111213141516171819// 布尔值 booleanlet isDone: boolean = false;// 数字 numberlet number: number = 6;let notANumber: number = NaN;// 字符串 stringlet string: string = "Tom";let sentence: string = `my name is $&#123;aString&#125;`;// 空值 void// void 类型的变量只能赋值为 undefined 和 nulllet unusable: void = undefined;// 任意值 any//any 用来表示允许赋值为任意类型 好用let anyType: any = "seven";anyType = 7;]]></content>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js]]></title>
    <url>%2F2012%2F03%2F01%2Fnode%2F</url>
    <content type="text"></content>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nuxt]]></title>
    <url>%2F2012%2F03%2F01%2Fnuxt%2F</url>
    <content type="text"><![CDATA[简单来说，Nuxt 就是基于 Vue 的一个应用框架，采用服务端渲染，让你的 SPA 应用(Vue)也可以拥有 SEO官方文档 项目结构 生命周期众所周知，Vue 的生命周期全都跑在客户端(浏览器)，而 Nuxt 的生命周期有些在服务端(Node)，客户端，甚至两边都在: 生命周期流程图，红框内的是 Nuxt 的生命周期(运行在服务端)，黄框内同时运行在服务端&amp;&amp;客户端上，绿框内则运行在客户端]]></content>
      <tags>
        <tag>nuxt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python]]></title>
    <url>%2F2012%2F03%2F01%2Fpython%2F</url>
    <content type="text"><![CDATA[Mac 安装和使用python 如你先建一个.py的文件如果要使用 Python 2 来运行此文件，因为 OS X 自带 Python 2，所以直接输入:python “python”文件夹的绝对路径/文件名.py 回车即可 如果要使用 Python 3 来运行此文件，则需要去 Python 官网 https://www.python.org/downloads/ 下载最新版的 Python 3 安装包，然后在 Mac 上安装后再打开终端，并输入python3 “python”文件夹的绝对路径/文件名.py 回车 可以通过直接将 .py 文件拖入终端的方式来获取该文件的绝对路径。 安装里面的模块 我们用pip 所以先安装一下pipmac里面python自带easy_install的，最快的应该就是在terminal里面sudo easy_install pip了，网络好几秒就ok。运行完可以用pip help测试一下是否安装成功，成功安装后，直接pip install numpy或者其他包就可以了。ps：用sudo的时候需要输入密码，这个密码是你自己电脑的密码，输入的时候采取了“保密措施”，你看不到自己输入的字符，完整的输入进去以后，回车就可以了。 比如用pip安装 pip install beautifulsoup4 Python的open()方法不指明路径进行创建文件的默认存储路径http://blog.sina.com.cn/s/blog_a03baecd0102wyms.html]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ui框架]]></title>
    <url>%2F2012%2F03%2F01%2Fui%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[大约记录一下用过的 ui 框架 bootstrapBootstrap 是 Twitter 推出的一个用于前端开发的开源工具包. 看文档吧 想起啥了再补充bootstrap 12345678910&lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-sm"&gt; One of three columns &lt;/div&gt; &lt;div class="col-sm"&gt; One of three columns &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; Element看文档吧 想起啥了再补充Element 123&lt;el-row&gt; &lt;el-col :span="24"&gt;&lt;div class="grid-content bg-purple-dark"&gt;&lt;/div&gt;&lt;/el-col&gt;&lt;/el-row&gt; iviewiView 是一套基于 Vue.js 的开源 UI 组件库，主要服务于 PC 界面的中后台产品。 看文档吧 想起啥了再补充iview 123456789&lt;template&gt; &lt;Row&gt; &lt;i-col span="12"&gt;col-12&lt;/i-col&gt; &lt;i-col span="12"&gt;col-12&lt;/i-col&gt; &lt;/Row&gt;&lt;/template&gt;&lt;script&gt; export default &#123;&#125;;&lt;/script&gt; AntD - Ant Design of Vue高质量 Vue 组件。 看文档吧 想起啥了再补充AntD 12345678&lt;template&gt; &lt;div&gt; &lt;a-row&gt; &lt;a-col :span="12"&gt;col-12&lt;/a-col&gt; &lt;a-col :span="12"&gt;col-12&lt;/a-col&gt; &lt;/a-row&gt; &lt;/div&gt;&lt;/template&gt;]]></content>
      <tags>
        <tag>ui框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[魑魅]]></title>
    <url>%2F2012%2F01%2F02%2F%E8%AF%97%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[回首向来萧瑟处,归去,也无风雨也无晴 且君子之交淡如水，小人之交甘若醴 黑发不知勤学早，白首方悔读书迟。 夕阳 “长河落日圆”、“落霞与孤鹜齐飞” 春 “逃之夭夭，灼灼其华”；夏 “接天莲叶无穷碧”、“水光潋滟晴方好”；秋 “老树呈秋色”、“苒苒物华休”；冬 “红泥小火炉”、“晚来天欲雪” 老骥伏枥，志在千里；烈士暮年，壮心不已。 昨夜风疏雨骤，浓睡不消残酒。试问卷帘人，却道海棠依旧。知否，知否？应是绿肥红瘦。 十二生肖是十二地支的形象化代表，即子（鼠）、丑（牛）、寅（虎）、卯（兔）、辰（龙）、巳（蛇）、午（马）、未（羊）、申（猴）、酉（鸡）、戌（狗）、亥（猪） 二十四节气中国古代订立的一种用来指导农事的补充历法，分别是：立春、雨水、惊蛰、春分、清明、谷雨、立夏、小满、芒种、夏至、小暑、大暑、立秋、处暑、白露、秋分、寒露、霜降、立冬、小雪、大雪、冬至、小寒、大寒。 噫吁嚱，危乎高哉！蜀道之难，难于上青天！ 《生于忧患，死于安乐》 选自《孟子》（战国） [原文] 舜发于畎亩之中，傅说举于版筑之中，胶鬲举于鱼盐之中，管夷吾举于士，孙叔敖举于海，百里奚举于市。 故天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。 人恒过，然后能改；困于心，衡于虑，而后作；征于色，发于声，而后喻。入则无法家拂士，出则无敌国外患者，国恒亡。 然后知生于忧患，而死于安乐也。]]></content>
      <categories>
        <category>诗词拓展</category>
      </categories>
      <tags>
        <tag>诗书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2021]]></title>
    <url>%2F1988%2F03%2F13%2FZ%E5%B9%B4%E5%BA%A62021%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Decrypt U2FsdGVkX1/UKzccwabiybMqrzygDDe9Wii+IrmXn525tETZ22xrELfaATifE69yAgE3l7OS8/FS4AtHpNW23oD9j/i5w0BAWZiqRyFNNByfmBwpkXj++fA6iyC3x0V0gvC7ukt+pvJhgWtiYXalqRqQgP5IcgzkhwYSGhm07/rVPjON2uaBgZvq4VP07Akmk9UPh6YAaZAUZAr9WGGSIL5C/MKUH4Zs8gCtSHueEU5w0yUuh9sYuf0tPHvAvcbvK7HW5vy8wPyHPtr5Lf5lH3qDIPxVFc24nqDv6no9YgXqzTBYtgWJWaxqMNkUF1Xb515QwoTopLalmdrXVxK4OVHMn8ztfSMnK289PdPuO8s3lXwB6q5EaSFmgZ+Gi73brZThNbjFtn/2SarfYBY0SXJchnNBlaT9OjSnztGR76nxUk1pn2yfhauhdSkhvUKMA/3IV0MPDj9/Q7n1HghSH2C53fDd8IfjUugGmIuyBo/psDVgcGbifeBnfNhF+2YGdVIFqizxpJzx4evVb69ykHANAGxfgl9+2o4Qzy6iU0gVcdB6VS64utgEaEInTrZ2GKpD3bBn4JxgdLwrlhrXxKov3mlOXwGSfr4mEQHLBkDeWDletXG4LQbclWbGBJSG8MeEbnJxw1ZJZ8HU1izW1pODEmLWfEM0Tzq0myjaSYyaLauVskqeFkqgltZnPp4Lg2QU1oKY+AIeFeM6HRoZjY5UCwwbyI7gPLg591nrwJ+mYZuqypmbFfTPaSn97R0NDIB06pqAf8wBk2INoAqMgVFODPHhk+l4Tmb9ezeI2pRCfog1p5MGBW7smQmyYxQHkrYDz0uMMSlpK6QrEkxKYAhgXpSB3lXlanSGqnF7qo5w8HaAgnz4LLGTNIZYsmUOr6iGXD74okdJGSfbztEDM3At51u1rjsfkF5AEJMDQdh13F5Xof+GMesBXHTys2sdPBgKuLcAkpEq8M6hlRpeR1S+vK39xamS974OgSoralMi9h/2iE+2ZeESdDO+OIGg3shXPYxB09qb3YdbXsLCMtRxxhRA3dQuUW450GXU9+5BLMG7D5fO7WL8MsuMsGJ2twSNMAdG/fMhvbLgGESokjBhXIC5uTmhDqaq+pz/tBQaUKtmAUa/7IwjtEkr/hgOsK+bikKLOpKWrlxKyJUJ3BYS/sbhS5idN398cTQCCMV4vWcVJCit9lESlBADzPz8n4UkeCMjYpPmbamVysEtpUow469G9QSg6uHaXO/ljhOtBO3zSnbmt82xluZzbbkPmGVr8UK9zAS2l610nIa5aYPALqNSoXqCoRX+nZDIvqDC3lOWU1W+XxP9QwgE4QGwYQSEJODVlW2HMZsZBZHtmemSfupAwZSn6/QXD7fnQkcvI/Rj0hBh2wC1CTnvy1up3v2LdXI/P1DYdzv8WYYhNOeYyXnM6w1/ayHKCZdSOIt6RFRDCaV02OZsPlS4H1LHOEiMCeS8JFEN9PWulJf+Lw7WjHrIpzA/Yn8LGxa710aG7qV3vsc6eWUluc1BkIHoBUvjbpX6oAz5ZM7i7h9pCZCb/qztW0V8h6+yr6Mdlv2THxrv3bg6ACydhbl6ulYMp9Sxo4tsGM0ZXY7KeOJA99KpZ8z5DA7S8GbAKMTcGEC63YimEWnt+qATYKoL+Sb/SsonYfP2in54DTc2VuUp0Uz1HdbSlGn3ya6pwXI8wXM=]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019]]></title>
    <url>%2F1988%2F02%2F24%2FZ%E5%B9%B4%E5%BA%A62019%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Decrypt U2FsdGVkX1+X2nbb0Ml5GpXoqIdugc+mpR1H8r6CHOhZRjinBB9VqqtVnm2VyXFAWUdgd9e7egVpW8iFNTq5L3q1jeAR3ZNAC0Fdnzh7DBp9D4cmYZidEbCNAvvSHQoAt3VKWymNA7VfPo7u5U7FRcEqUJcV9NC9QYiSS63PJc6Ll7I5JSgJRU9mgAyL/NJ3+IgTO/n/tQJLDYtkwRzrb3GiWcIpg03RSk08YFbqA55Q1wSvNi5vy4GwpWK4/+SddllFbs0cZdR2noQwGiAydU2kW3g6wiTLiqBzmu84aU7Z5rU+tBfKIBd/CjH8wTDiRoCpNtZjcU2xXjAz3cvme8soX8/lQi8zIj6tnCapmYydy60aq4qpk5oijWibwn/Bc1+UBwCd+42u/ac11ELN89sLKDLYoD/OgdPQQTXN9n0ynta5fuhj4eCv6ZlFJySGeYTm04pLBY0LdfWIeCCTI0MSM2Y1pNu8I27oUoglUM3XFUOSJrtF4xpFTIz9Gb57vL5oHlr5M8DXU6/sqntM7sscNjYdctAg+4AoqDePAyHqn+fDNbFchLmPocPX3h432dg9FxVOKKrk1Ty5JqcrYtEbI449YgdngTsny029rIhZ843CGMKP0CL3B2Mc80Z2SaU2X3mVRuj7Av6E59KGndVhJePBtVPTgiOYHH59/CDT8Jg2W8flFbuTP0hXBWEkXahfVbtS559RAzhWQXiRlP8qX6eFpcafNG2I29+poYH6NR6qWgw5R8uz7gr6R5kUZChTIIXYEfnxmswN4ftM6mOQ5WsuGh2EvgQxVJxxT3EuvugkELr0afc+950hDHzqt5C9G6yjphcu22O/FvtMjAGATeU6QHCGgF0RiwaKMlRWY/8Lg98RwkaoQZOuYmo0cGbFerkNMOVGPkDsk+JkGAPycJtzmSO9kb/7YregZlT5jaXuByYYWdrfdYIka2G44qUZ+Y9Mg6ZuiQCmZ+MUheBG3vJqSTnUk94Mv8XYKtV6nVnNgIbJuOft1izibPID5rPaHT51+CICIwTKyfPHtQTUH0h+WPvgQ2Bms0rriGDZSuaYuOLK65ttS1GsaS8J6xsfQLXDyOEtR9O5NvLf2bn8AxBdx9pVB5ma715QEL6b8aHv6XdzXuJJd8rSnzIYoaPLX3sda75DiqKJpVv5sZ0iytFAH8dH50RvVCVGecorjNWx1aqplJqEH7xYuA7t33gD9BFPFJnI/ONQHZ6Ahi4mJrbqWa9vcxwgnyv9JJfRm6PQKWEe5+knviq33LrG3Mqf6NXS3Vwg/w9KOb5S/xGmLF7iNvyBCFQLq2A2Png=]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020]]></title>
    <url>%2F1988%2F02%2F24%2FZ%E5%B9%B4%E5%BA%A62020%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Decrypt U2FsdGVkX18zNHLYqA0hEW3y6iqr/RKUD94RDA81Q1IsidDELKPg8JGKooa21XOZEGZNtHrkFQfmUl4u9tJ5rst0YRHL/XcIm0RbZ1ogTQ7Km545mNa/BuqDQ5ZDWcGK]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018]]></title>
    <url>%2F1988%2F01%2F07%2FZ%E5%B9%B4%E5%BA%A62018%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Decrypt U2FsdGVkX19uFHJmriY+VWPizCKzKElIM3RyjJU5mu4KArKptqGt2Fn8ILMWLdNnfvxDkItwlpHHxaGT0B8ha/YKwuNWgCgZ+/tzMjnlZYcQcKJUpdgL8Illm6F/qsNv0S5s5eOJigDBbQW5pVw8n/IIFUNEMOm66K9Ac7E9+NJAkrbk8fGVTpk2NayNNbuWP7wFmdWxs1VPBE5Qcl0oQVZtAd0Yk5LERTGARLgJ9ZkC67Xqu2He3ZBSSFqCxhRbWgsq5F7zR/NTBRN3cDmG5TBwF9C+ivVPIb1G7cSvDxwbufLR46QRRSy1+FY87N5JQXeE6g8QVOAwuBMxpX0EBmloLV1R7FdTGlm+6WgcdBh4eydyM3NhBOy6+69g09MgYyH79MeX8cDyWHgDuyBCcFPorujuLuIdLWhequr+6KgqL+0c0VMh0VHdOFvTEBcK23L+h77u8fZnQJx4m2gt4JGQImoRsx9WFs4d8ivDdtRfnFHy2p5fFsRKbRhiyoLqBkSrUK9rmOj787JPvkwtOdBIE9slhBqlWzMIjcDIrnq31KjvARgBVOzGtofXBZ08ip8HOB/0hzeEQz0KwD/4N4EHFrCgHP+f4MaEDUOU3loDYqfPnY+nNz2ZHDjNqBGkAzv0lA4D4HEonPTigr98UBcD8t5qexD7dVgTwNJHgi6QoJ/Jhcn8WI3heuYXl3slwuBcgfw+OBPuucPEaUy1MKRilvDARV0/bD0atQ4ZIx/Pgts9eVjkPQqK3BTe7lQdpOq1ntNGnhg6kQkoxWb15yyvLLuA9bGNkIGiFv1ij11Uax1N/S7mtJLLO4PciRKw6fdhfgiFlbzdryVUKGC2qMX0TC4ST5E+IAr1M3pdLr+67CD+F3VXHm77IX4eHD41yIe/1+m6jHMRs9a7p/uGS+7sqeaZ9XqmBpF7Xp24ckvTx1EhJpbI8or24kFpM1Lm3frk5+T7x5YLXcGQf9/NsUqmK2K+ls7mf9mcUkCWzZqhWN+YPsQUY3PGcFMlY8iXXOitTG4Gq5CpBP3qngHFsN/SRLR6dRi7saqvmp9ru4c64Lr/rxDKIQfxI9O/67W0+ZF92Xt9fN8lttaxhmok5otv2gNnRKNAXnW47iYH6fnYvcePOBBesWEa23jL5ik1V5ZcMic2dICmWY9+2FoEXYRyH5xm4Z3gUNF5ab8UJxZqE6owbjNLgNpXSHBS0sMq1jnM2O6KdfuiXy2vT4BB5LPGvQBgVrS/Uc1miX73GQbop4ZHM9AlCc7zDBpaQ7DjWJCX9/HG1YO8Tp6N7YwTL5VT71j3pKbyT4S2Btqx8ucqRRMLBfsV6fNtnTWY14BxY8i6TQWVzx+Yzlm7QreSjcL/Rrz1fL9yOHnfGWIcAMnpgw8mDDiFJRafnRIRnb6jiPZHotkqhtFsTTeONdRm5uJ8gS2KogFt/wd0Gbc9DbuYLI6ZO/plVXSYQud38Fmk+GCNo1SFcGFwNvYd8pVCw+mCFuwcNpT4aVKnjE+HzkGaq3h3+5KvEgUti8KkHP0TWJwMOMQkzXo8seVQTFbjl9zAGUBjzyMFEF4ax3oTLi12OtcvXR5HaLhu2Gujhu1ng+a3MbipfRkokoEKKlMDBA==]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
